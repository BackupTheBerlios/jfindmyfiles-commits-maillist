<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Jfindmyfiles-commits] r188 - in trunk: docs libs libs/Hibernate libs/JDBC Drivers project/JFindMyFiles project/JFindMyFiles/JFindMyFilesGui/nbproject project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui project/JFindMyFiles/nbproject project/JFindMyFiles/org-netbeans-swing-outline project/JFindMyFiles/org-netbeans-swing-outline/nbproject project/JFindMyFiles/org-netbeans-swing-outline/release project/JFindMyFiles/org-netbeans-swing-outline/release/modules project/JFindMyFiles/org-netbeans-swing-outline/release/modules/ext project/JFindMyFiles/org-netbeans-swing-outline/src project/JFindMyFiles/org-netbeans-swing-outline/src/org project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans/swing project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans/swing/etable project/JFindMyFiles/tableview project/JFindMyFiles/tableview/nbproject project/JFindMyFiles/tableview/src project/JFindMyFi! les/tableview/src/org project/JFindMyFiles/tableview/src/org/netbeans project/JFindMyFiles/tableview/src/org/netbeans/api project/JFindMyFiles/tableview/src/org/netbeans/api/tableview project/JFindMyFiles/tableview/src/org/netbeans/modules project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview/resources project/JFindMyFiles/tableview/src/org/netbeans/swing project/JFindMyFiles/tableview/src/org/netbeans/swing/etable project/JFindMyFiles/tableview/src/org/netbeans/swing/outline project/JFindMyFiles/tableview/test project/JFindMyFiles/tableview/test/org project/JFindMyFiles/tableview/test/org/netbeans project/JFindMyFiles/tableview/test/org/netbeans/swing project/JFindMyFiles/tableview/test/org/netbeans/swing/etable project/JFindMyFiles/tableview/test/unit project/JFindMyFiles/tableview/test/unit/src project/JFindMyFiles/tableview/test/unit/src/org project/JFindMyFiles/tableview/test/unit/src/org/net! beans project/JFindMyFiles/tableview/test/unit/src/org/netbean! s/swing
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/jfindmyfiles-commits/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:jfindmyfiles-commits%40lists.berlios.de?Subject=Re%3A%20%5BJfindmyfiles-commits%5D%20r188%20-%20in%20trunk%3A%20docs%20libs%20libs/Hibernate%0A%20libs/JDBC%20Drivers%20project/JFindMyFiles%0A%20project/JFindMyFiles/JFindMyFilesGui/nbproject%0A%20project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui%0A%20project/JFindMyFiles/nbproject%0A%20project/JFindMyFiles/org-netbeans-swing-outline%0A%20project/JFindMyFiles/org-netbeans-swing-outline/nbproject%0A%20project/JFindMyFiles/org-netbeans-swing-outline/release%0A%20project/JFindMyFiles/org-netbeans-swing-outline/release/modules%0A%20project/JFindMyFiles/org-netbeans-swing-outline/release/modules/ext%0A%20project/JFindMyFiles/org-netbeans-swing-outline/src%0A%20project/JFindMyFiles/org-netbeans-swing-outline/src/org%0A%20project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans%0A%20project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans/swing%0A%20project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans/swing/etable%0A%20project/JFindMyFiles/tableview%20project/JFindMyFiles/tableview/nbproject%0A%20project/JFindMyFiles/tableview/src%20project/JFindMyFi%21%20les/tableview/src/org%0A%20project/JFindMyFiles/tableview/src/org/netbeans%0A%20project/JFindMyFiles/tableview/src/org/netbeans/api%0A%20project/JFindMyFiles/tableview/src/org/netbeans/api/tableview%0A%20project/JFindMyFiles/tableview/src/org/netbeans/modules%0A%20project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview%0A%20project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview/resources%0A%20project/JFindMyFiles/tableview/src/org/netbeans/swing%0A%20project/JFindMyFiles/tableview/src/org/netbeans/swing/etable%0A%20project/JFindMyFiles/tableview/src/org/netbeans/swing/outline%0A%20project/JFindMyFiles/tableview/test%20project/JFindMyFiles/tableview/test/org%0A%20project/JFindMyFiles/tableview/test/org/netbeans%0A%20project/JFindMyFiles/tableview/test/org/netbeans/swing%0A%20project/JFindMyFiles/tableview/test/org/netbeans/swing/etable%0A%20project/JFindMyFiles/tableview/test/unit%0A%20project/JFindMyFiles/tableview/test/unit/src%0A%20project/JFindMyFiles/tableview/test/unit/src/org%0A%20project/JFindMyFiles/tableview/test/unit/src/org/net%21%20beans%0A%20project/JFindMyFiles/tableview/test/unit/src/org/netbean%21%20s/swing&In-Reply-To=%3C200807081704.m68H4RCX006400%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000182.html">
   <LINK REL="Next"  HREF="000184.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Jfindmyfiles-commits] r188 - in trunk: docs libs libs/Hibernate libs/JDBC Drivers project/JFindMyFiles project/JFindMyFiles/JFindMyFilesGui/nbproject project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui project/JFindMyFiles/nbproject project/JFindMyFiles/org-netbeans-swing-outline project/JFindMyFiles/org-netbeans-swing-outline/nbproject project/JFindMyFiles/org-netbeans-swing-outline/release project/JFindMyFiles/org-netbeans-swing-outline/release/modules project/JFindMyFiles/org-netbeans-swing-outline/release/modules/ext project/JFindMyFiles/org-netbeans-swing-outline/src project/JFindMyFiles/org-netbeans-swing-outline/src/org project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans/swing project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans/swing/etable project/JFindMyFiles/tableview project/JFindMyFiles/tableview/nbproject project/JFindMyFiles/tableview/src project/JFindMyFi! les/tableview/src/org project/JFindMyFiles/tableview/src/org/netbeans project/JFindMyFiles/tableview/src/org/netbeans/api project/JFindMyFiles/tableview/src/org/netbeans/api/tableview project/JFindMyFiles/tableview/src/org/netbeans/modules project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview/resources project/JFindMyFiles/tableview/src/org/netbeans/swing project/JFindMyFiles/tableview/src/org/netbeans/swing/etable project/JFindMyFiles/tableview/src/org/netbeans/swing/outline project/JFindMyFiles/tableview/test project/JFindMyFiles/tableview/test/org project/JFindMyFiles/tableview/test/org/netbeans project/JFindMyFiles/tableview/test/org/netbeans/swing project/JFindMyFiles/tableview/test/org/netbeans/swing/etable project/JFindMyFiles/tableview/test/unit project/JFindMyFiles/tableview/test/unit/src project/JFindMyFiles/tableview/test/unit/src/org project/JFindMyFiles/tableview/test/unit/src/org/net! beans project/JFindMyFiles/tableview/test/unit/src/org/netbean! s/swing</H1>
    <B>knitter at mail.berlios.de</B> 
    <A HREF="mailto:jfindmyfiles-commits%40lists.berlios.de?Subject=Re%3A%20%5BJfindmyfiles-commits%5D%20r188%20-%20in%20trunk%3A%20docs%20libs%20libs/Hibernate%0A%20libs/JDBC%20Drivers%20project/JFindMyFiles%0A%20project/JFindMyFiles/JFindMyFilesGui/nbproject%0A%20project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui%0A%20project/JFindMyFiles/nbproject%0A%20project/JFindMyFiles/org-netbeans-swing-outline%0A%20project/JFindMyFiles/org-netbeans-swing-outline/nbproject%0A%20project/JFindMyFiles/org-netbeans-swing-outline/release%0A%20project/JFindMyFiles/org-netbeans-swing-outline/release/modules%0A%20project/JFindMyFiles/org-netbeans-swing-outline/release/modules/ext%0A%20project/JFindMyFiles/org-netbeans-swing-outline/src%0A%20project/JFindMyFiles/org-netbeans-swing-outline/src/org%0A%20project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans%0A%20project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans/swing%0A%20project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans/swing/etable%0A%20project/JFindMyFiles/tableview%20project/JFindMyFiles/tableview/nbproject%0A%20project/JFindMyFiles/tableview/src%20project/JFindMyFi%21%20les/tableview/src/org%0A%20project/JFindMyFiles/tableview/src/org/netbeans%0A%20project/JFindMyFiles/tableview/src/org/netbeans/api%0A%20project/JFindMyFiles/tableview/src/org/netbeans/api/tableview%0A%20project/JFindMyFiles/tableview/src/org/netbeans/modules%0A%20project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview%0A%20project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview/resources%0A%20project/JFindMyFiles/tableview/src/org/netbeans/swing%0A%20project/JFindMyFiles/tableview/src/org/netbeans/swing/etable%0A%20project/JFindMyFiles/tableview/src/org/netbeans/swing/outline%0A%20project/JFindMyFiles/tableview/test%20project/JFindMyFiles/tableview/test/org%0A%20project/JFindMyFiles/tableview/test/org/netbeans%0A%20project/JFindMyFiles/tableview/test/org/netbeans/swing%0A%20project/JFindMyFiles/tableview/test/org/netbeans/swing/etable%0A%20project/JFindMyFiles/tableview/test/unit%0A%20project/JFindMyFiles/tableview/test/unit/src%0A%20project/JFindMyFiles/tableview/test/unit/src/org%0A%20project/JFindMyFiles/tableview/test/unit/src/org/net%21%20beans%0A%20project/JFindMyFiles/tableview/test/unit/src/org/netbean%21%20s/swing&In-Reply-To=%3C200807081704.m68H4RCX006400%40sheep.berlios.de%3E"
       TITLE="[Jfindmyfiles-commits] r188 - in trunk: docs libs libs/Hibernate libs/JDBC Drivers project/JFindMyFiles project/JFindMyFiles/JFindMyFilesGui/nbproject project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui project/JFindMyFiles/nbproject project/JFindMyFiles/org-netbeans-swing-outline project/JFindMyFiles/org-netbeans-swing-outline/nbproject project/JFindMyFiles/org-netbeans-swing-outline/release project/JFindMyFiles/org-netbeans-swing-outline/release/modules project/JFindMyFiles/org-netbeans-swing-outline/release/modules/ext project/JFindMyFiles/org-netbeans-swing-outline/src project/JFindMyFiles/org-netbeans-swing-outline/src/org project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans/swing project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans/swing/etable project/JFindMyFiles/tableview project/JFindMyFiles/tableview/nbproject project/JFindMyFiles/tableview/src project/JFindMyFi! les/tableview/src/org project/JFindMyFiles/tableview/src/org/netbeans project/JFindMyFiles/tableview/src/org/netbeans/api project/JFindMyFiles/tableview/src/org/netbeans/api/tableview project/JFindMyFiles/tableview/src/org/netbeans/modules project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview/resources project/JFindMyFiles/tableview/src/org/netbeans/swing project/JFindMyFiles/tableview/src/org/netbeans/swing/etable project/JFindMyFiles/tableview/src/org/netbeans/swing/outline project/JFindMyFiles/tableview/test project/JFindMyFiles/tableview/test/org project/JFindMyFiles/tableview/test/org/netbeans project/JFindMyFiles/tableview/test/org/netbeans/swing project/JFindMyFiles/tableview/test/org/netbeans/swing/etable project/JFindMyFiles/tableview/test/unit project/JFindMyFiles/tableview/test/unit/src project/JFindMyFiles/tableview/test/unit/src/org project/JFindMyFiles/tableview/test/unit/src/org/net! beans project/JFindMyFiles/tableview/test/unit/src/org/netbean! s/swing">knitter at mail.berlios.de
       </A><BR>
    <I>Tue Jul  8 19:04:27 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000182.html">[Jfindmyfiles-commits] r187 - in trunk/docs: . Documentos	Externos/images
</A></li>
        <LI>Next message: <A HREF="000184.html">[Jfindmyfiles-commits] r189 - in trunk/project/JFindMyFiles:	JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui	org-netbeans-swing-outline	org-netbeans-swing-outline/nbproject tableview tableview/nbproject
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#183">[ date ]</a>
              <a href="thread.html#183">[ thread ]</a>
              <a href="subject.html#183">[ subject ]</a>
              <a href="author.html#183">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: knitter
Date: 2008-07-08 19:02:52 +0200 (Tue, 08 Jul 2008)
New Revision: 188

Added:
   trunk/libs/Hibernate/
   trunk/libs/Hibernate/antlr-2.7.6.jar
   trunk/libs/Hibernate/asm-attrs.jar
   trunk/libs/Hibernate/asm.jar
   trunk/libs/Hibernate/cglib-2.1.3.jar
   trunk/libs/Hibernate/commons-collections-2.1.1.jar
   trunk/libs/Hibernate/commons-logging-1.0.4.jar
   trunk/libs/Hibernate/dom4j-1.6.1.jar
   trunk/libs/Hibernate/hibernate3.jar
   trunk/libs/Hibernate/jta.jar
   trunk/libs/Hibernate/log4j-1.2.11.jar
   trunk/libs/JDBC Drivers/
   trunk/libs/JDBC Drivers/jaybird-pool-2.1.5.jar
   trunk/libs/JDBC Drivers/jtds-1.2.2.jar
   trunk/libs/JDBC Drivers/mysql-connector-java-5.1.6-bin.jar
   trunk/libs/JDBC Drivers/postgresql-8.3-603.jdbc4.jar
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/build.xml
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/manifest.mf
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/build-impl.xml
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/genfiles.properties
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/platform.properties
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/project.properties
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/project.xml
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/suite.properties
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/release/
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/release/modules/
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/release/modules/ext/
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/release/modules/ext/org-netbeans-swing-outline.jar
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/src/
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/src/org/
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans/
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans/swing/
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans/swing/etable/
   trunk/project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans/swing/etable/Bundle.properties
   trunk/project/JFindMyFiles/tableview/
   trunk/project/JFindMyFiles/tableview/build.xml
   trunk/project/JFindMyFiles/tableview/license.txt
   trunk/project/JFindMyFiles/tableview/manifest.mf
   trunk/project/JFindMyFiles/tableview/nbproject/
   trunk/project/JFindMyFiles/tableview/nbproject/build-impl.xml
   trunk/project/JFindMyFiles/tableview/nbproject/genfiles.properties
   trunk/project/JFindMyFiles/tableview/nbproject/platform.properties
   trunk/project/JFindMyFiles/tableview/nbproject/project.properties
   trunk/project/JFindMyFiles/tableview/nbproject/project.xml
   trunk/project/JFindMyFiles/tableview/nbproject/suite.properties
   trunk/project/JFindMyFiles/tableview/src/
   trunk/project/JFindMyFiles/tableview/src/org/
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/Bundle.properties
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/NodePopupFactory.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/NodeRenderDataProvider.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/NodeTableModel.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/OutlineView.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/PropertiesRowModel.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/SheetCell.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/TableView.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/modules/
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview/
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview/resources/
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview/resources/Bundle.properties
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview/resources/layer.xml
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ColumnSelectionPanel.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETable.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETableColumn.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETableColumnModel.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETableTransferHandler.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETableTransferable.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/QuickFilter.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/TestJFrame.form
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/TestJFrame.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/columns.gif
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/DefaultOutlineCellRenderer.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/DefaultOutlineModel.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/EventBroadcaster.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/ExtTreeWillExpandListener.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/Outline.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/OutlineModel.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/ProxyTableModel.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/RenderDataProvider.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/RowModel.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/TestOutline.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/TestOutlineDynamic.java
   trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/TreePathSupport.java
   trunk/project/JFindMyFiles/tableview/test/
   trunk/project/JFindMyFiles/tableview/test/build-unit.xml
   trunk/project/JFindMyFiles/tableview/test/build.xml
   trunk/project/JFindMyFiles/tableview/test/cfg-unit.xml
   trunk/project/JFindMyFiles/tableview/test/org/
   trunk/project/JFindMyFiles/tableview/test/org/netbeans/
   trunk/project/JFindMyFiles/tableview/test/org/netbeans/swing/
   trunk/project/JFindMyFiles/tableview/test/org/netbeans/swing/etable/
   trunk/project/JFindMyFiles/tableview/test/org/netbeans/swing/etable/ETableColumnModelTest.java
   trunk/project/JFindMyFiles/tableview/test/org/netbeans/swing/etable/ETableColumnTest.java
   trunk/project/JFindMyFiles/tableview/test/org/netbeans/swing/etable/ETableTest.java
   trunk/project/JFindMyFiles/tableview/test/unit/
   trunk/project/JFindMyFiles/tableview/test/unit/src/
   trunk/project/JFindMyFiles/tableview/test/unit/src/org/
   trunk/project/JFindMyFiles/tableview/test/unit/src/org/netbeans/
   trunk/project/JFindMyFiles/tableview/test/unit/src/org/netbeans/swing/
   trunk/project/JFindMyFiles/tableview/test/unit/src/org/netbeans/swing/etable/
   trunk/project/JFindMyFiles/tableview/test/unit/src/org/netbeans/swing/etable/ETableColumnModelTest.java
   trunk/project/JFindMyFiles/tableview/test/unit/src/org/netbeans/swing/etable/ETableColumnTest.java
   trunk/project/JFindMyFiles/tableview/test/unit/src/org/netbeans/swing/etable/ETableTest.java
Removed:
   trunk/libs/antlr-2.7.6.jar
   trunk/libs/asm-attrs.jar
   trunk/libs/asm.jar
   trunk/libs/cglib-2.1.3.jar
   trunk/libs/commons-collections-2.1.1.jar
   trunk/libs/commons-logging-1.0.4.jar
   trunk/libs/dom4j-1.6.1.jar
   trunk/libs/hibernate3.jar
   trunk/libs/jta.jar
   trunk/libs/log4j-1.2.11.jar
   trunk/libs/mysql-connector-java-5.1.6-bin.jar
Modified:
   trunk/docs/jFindMyFiles - Relatorio com estrutura Alternativa - Office 2007.doc
   trunk/project/JFindMyFiles/JFindMyFilesGui/nbproject/genfiles.properties
   trunk/project/JFindMyFiles/JFindMyFilesGui/nbproject/project.xml
   trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/Bundle.properties
   trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/DetailsViewTopComponent.form
   trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/DetailsViewTopComponent.java
   trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/WindowTestingAction.java
   trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/WindowTestingTopComponent.java
   trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/layer.xml
   trunk/project/JFindMyFiles/nbproject/project.properties
Log:
Actualiza?\195?\167?\195?\181es de documenta?\195?\167?\195?\163o e estrutura da pasta libs.
Envio de dois novos m?\195?\179dulos para tentar criar interface com tabela.

Modified: trunk/docs/jFindMyFiles - Relatorio com estrutura Alternativa - Office 2007.doc
===================================================================
(Binary files differ)

Added: trunk/libs/Hibernate/antlr-2.7.6.jar
===================================================================
(Binary files differ)


Property changes on: trunk/libs/Hibernate/antlr-2.7.6.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/libs/Hibernate/asm-attrs.jar
===================================================================
(Binary files differ)


Property changes on: trunk/libs/Hibernate/asm-attrs.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/libs/Hibernate/asm.jar
===================================================================
(Binary files differ)


Property changes on: trunk/libs/Hibernate/asm.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/libs/Hibernate/cglib-2.1.3.jar
===================================================================
(Binary files differ)


Property changes on: trunk/libs/Hibernate/cglib-2.1.3.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/libs/Hibernate/commons-collections-2.1.1.jar
===================================================================
(Binary files differ)


Property changes on: trunk/libs/Hibernate/commons-collections-2.1.1.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/libs/Hibernate/commons-logging-1.0.4.jar
===================================================================
(Binary files differ)


Property changes on: trunk/libs/Hibernate/commons-logging-1.0.4.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/libs/Hibernate/dom4j-1.6.1.jar
===================================================================
(Binary files differ)


Property changes on: trunk/libs/Hibernate/dom4j-1.6.1.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/libs/Hibernate/hibernate3.jar
===================================================================
(Binary files differ)


Property changes on: trunk/libs/Hibernate/hibernate3.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/libs/Hibernate/jta.jar
===================================================================
(Binary files differ)


Property changes on: trunk/libs/Hibernate/jta.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/libs/Hibernate/log4j-1.2.11.jar
===================================================================
(Binary files differ)


Property changes on: trunk/libs/Hibernate/log4j-1.2.11.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/libs/JDBC Drivers/jaybird-pool-2.1.5.jar
===================================================================
(Binary files differ)


Property changes on: trunk/libs/JDBC Drivers/jaybird-pool-2.1.5.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/libs/JDBC Drivers/jtds-1.2.2.jar
===================================================================
(Binary files differ)


Property changes on: trunk/libs/JDBC Drivers/jtds-1.2.2.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/libs/JDBC Drivers/mysql-connector-java-5.1.6-bin.jar
===================================================================
(Binary files differ)


Property changes on: trunk/libs/JDBC Drivers/mysql-connector-java-5.1.6-bin.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/libs/JDBC Drivers/postgresql-8.3-603.jdbc4.jar
===================================================================
(Binary files differ)


Property changes on: trunk/libs/JDBC Drivers/postgresql-8.3-603.jdbc4.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Deleted: trunk/libs/antlr-2.7.6.jar
===================================================================
(Binary files differ)

Deleted: trunk/libs/asm-attrs.jar
===================================================================
(Binary files differ)

Deleted: trunk/libs/asm.jar
===================================================================
(Binary files differ)

Deleted: trunk/libs/cglib-2.1.3.jar
===================================================================
(Binary files differ)

Deleted: trunk/libs/commons-collections-2.1.1.jar
===================================================================
(Binary files differ)

Deleted: trunk/libs/commons-logging-1.0.4.jar
===================================================================
(Binary files differ)

Deleted: trunk/libs/dom4j-1.6.1.jar
===================================================================
(Binary files differ)

Deleted: trunk/libs/hibernate3.jar
===================================================================
(Binary files differ)

Deleted: trunk/libs/jta.jar
===================================================================
(Binary files differ)

Deleted: trunk/libs/log4j-1.2.11.jar
===================================================================
(Binary files differ)

Deleted: trunk/libs/mysql-connector-java-5.1.6-bin.jar
===================================================================
(Binary files differ)

Modified: trunk/project/JFindMyFiles/JFindMyFilesGui/nbproject/genfiles.properties
===================================================================
--- trunk/project/JFindMyFiles/JFindMyFilesGui/nbproject/genfiles.properties	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/JFindMyFilesGui/nbproject/genfiles.properties	2008-07-08 17:02:52 UTC (rev 188)
@@ -1,8 +1,8 @@
-build.xml.data.CRC32=83a598ae
+build.xml.data.CRC32=cf74214f
 build.xml.script.CRC32=6fe2168f
 build.xml.stylesheet.CRC32=79c3b980
 # This file is used by a NetBeans-based IDE to track changes in generated files such as build-impl.xml.
 # Do not edit this file. You may delete it but then the IDE will never regenerate such files for you.
-nbproject/build-impl.xml.data.CRC32=83a598ae
+nbproject/build-impl.xml.data.CRC32=cf74214f
 nbproject/build-impl.xml.script.CRC32=fc3c2090
 nbproject/build-impl.xml.stylesheet.CRC32=deb65f65

Modified: trunk/project/JFindMyFiles/JFindMyFilesGui/nbproject/project.xml
===================================================================
--- trunk/project/JFindMyFiles/JFindMyFilesGui/nbproject/project.xml	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/JFindMyFilesGui/nbproject/project.xml	2008-07-08 17:02:52 UTC (rev 188)
@@ -74,6 +74,15 @@
                     &lt;/run-dependency&gt;
                 &lt;/dependency&gt;
                 &lt;dependency&gt;
+                    &lt;code-name-base&gt;org.netbeans.modules.tableview&lt;/code-name-base&gt;
+                    &lt;build-prerequisite/&gt;
+                    &lt;compile-dependency/&gt;
+                    &lt;run-dependency&gt;
+                        &lt;release-version&gt;1&lt;/release-version&gt;
+                        &lt;specification-version&gt;0.3&lt;/specification-version&gt;
+                    &lt;/run-dependency&gt;
+                &lt;/dependency&gt;
+                &lt;dependency&gt;
                     &lt;code-name-base&gt;org.openide.awt&lt;/code-name-base&gt;
                     &lt;build-prerequisite/&gt;
                     &lt;compile-dependency/&gt;

Modified: trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/Bundle.properties
===================================================================
--- trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/Bundle.properties	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/Bundle.properties	2008-07-08 17:02:52 UTC (rev 188)
@@ -1,99 +1,105 @@
-AdvancedOption_DisplayName_Linux=Linux
-AdvancedOption_Tooltip_Linux=Linux media options
-###
- #  Copyright (C) 2008  Patr\u00EDcia Monteiro e S\u00E9rgio Lopes
- #
- #  This file is part of JFindMyFiles.
- #
- #  JFindMyFiles is free software: you can redistribute it and/or modify
- #  it under the terms of the GNU General Public License as published by
- #  the Free Software Foundation, either version 2 of the License, or
- #  (at your option) any later version.
- #
- #  JFindMyFiles is distributed in the hope that it will be useful,
- #  but WITHOUT ANY WARRANTY; without even the implied warranty of
- #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- #  GNU General Public License for more details.
- #
- #  You should have received a copy of the GNU General Public License
- #  along with JFindMyFiles.  If not, see 
- # &lt;<A HREF="http://www.gnu.org/licenses/gpl.html">http://www.gnu.org/licenses/gpl.html</A>&gt;.
- ##
-CTL_DuplicateResultsAction=DuplicateResults
-CTL_DuplicateResultsTopComponent=DuplicateResults Window
-CTL_LoanAction=Loan
-CTL_LoanTopComponent=Loan Window
-CTL_ManageUsersAction=ManageUsers
-CTL_ManageUsersTopComponent=ManageUsers Window
-CTL_SearchWindowAction=SearchWindow
-CTL_SearchWindowTopComponent=SearchWindow Window
-CTL_StatisticsAction=Statistics
-CTL_StatisticsTopComponent=Statistics Window
-CTL_WindowTestingAction=WindowTesting
-CTL_WindowTestingTopComponent=WindowTesting Window
-HINT_DuplicateResultsTopComponent=This is a DuplicateResults window
-HINT_LoanTopComponent=This is a Loan window
-HINT_ManageUsersTopComponent=This is a ManageUsers window
-HINT_SearchWindowTopComponent=This is a SearchWindow window
-HINT_StatisticsTopComponent=This is a Statistics window
-HINT_WindowTestingTopComponent=This is a WindowTesting window
-Installer.ClosingMessage=Exit JFindMyFiles?\n\nYou can change this behavior in the options panel.
-Installer.ClosingTitle=Confirm Exit
-AdvancedOption_DisplayName_MiscUser=General Behavior
-AdvancedOption_Tooltip_MiscUser=User information
-CTL_DetailsViewAction=DetailsView
-CTL_DetailsViewTopComponent=DetailsView Window
-CTL_NavigationTreeAction=NavigationTree
-CTL_NavigationTreeTopComponent=NavigationTree Window
-HINT_DetailsViewTopComponent=This is a DetailsView window
-HINT_NavigationTreeTopComponent=This is a NavigationTree window
-OpenIDE-Module-Name=JFindMyFilesGui
-CatalogOptionsCategory_Name=Catalog
-CatalogOptionsCategory_Title=Catalog
-PluginsOptionsCategory_Name=Plugins
-PluginsOptionsCategory_Title=Plugins
-CatalogOptionsPanel.jlblDatabase.text=Database:
-CatalogOptionsPanel.jlblPassword.text=Password:
-CatalogOptionsPanel.jlblPort.text=Port:
-CatalogOptionsPanel.jlblUsername.text=Username:
-CatalogOptionsPanel.jlblHostname.text=Hostname:
-CatalogOptionsPanel.jchkUserinternalDB.text=Use internal database
-CatalogOptionsPanel.jlblDefaultLocation.text=Default Location:
-CatalogOptionsPanel.jtfDefaultLocation.text=
-CatalogOptionsPanel.jbtnBrowse.text=...
-PluginsPanel.jlblPluginFolder.text=Plugin Folder:
-PluginsPanel.jtfPluginFolder.text=
-PluginsPanel.jbtnBrowse.text=...
-CatalogOptionsPanel.jLabel1.text=Server
-MiscPanel.jlblRememberedCatalogs.text=Nr. Remembered Catalogs:
-MiscPanel.jtfUserName.text=
-MiscPanel.jlblDisabeRememberCatalogsTip.text=(0 - disable)
-MiscPanel.jlblUserDataTitle.text=User Data:
-MiscPanel.jlblUserName.text=Name:
-MiscPanel.jlblEmail.text=E-mail:
-MiscPanel.jlblWebAddress.text=Web Address:
-MiscPanel.jtfEmail.text=
-MiscPanel.jtfWebAddress.text=
-MiscPanel.jlblBehaviorTitle.text=Behavior
-MiscPanel.jchkConfirmExit.text=Confirm exit on close
-SearchWindowTopComponent.jlbText.text=Text:
-SearchWindowTopComponent.jrdbDiskGroupOnly.text=Disk Group
-SearchWindowTopComponent.jrdbEntireCatalog.text=Entire Catalog
-SearchWindowTopComponent.jchkUseReGex.text=Use Regular Expressions
-SearchWindowTopComponent.jchkCaseSensitive.text=Case sensitive
-SearchWindowTopComponent.jchkSearchInDesc.text=Search in descriptions
-SearchWindowTopComponent.jbtnSearch.text=Search
-SearchWindowTopComponent.jtfSearchText.text=
-StatisticsTopComponent.jButton1.text=jButton1
-StatisticsTopComponent.jButton2.text=jButton2
-StatisticsTopComponent.jButton3.text=jButton3
-StatisticsTopComponent.jButton4.text=jButton4
-StatisticsTopComponent.jButton5.text=jButton5
-ManageUsersTopComponent.jbtnAddUser.text=
-ManageUsersTopComponent.jbtnRemoveUser.text=
-LinuxPanel.jlblMountFolder.text=Mount folder:
-LinuxPanel.jtfMountFolder.text=
-LinuxPanel.jbtnAdd.text=Add
-LinuxPanel.jbtnRemove.text=Remove
-LinuxPanel.jtbnBrowse.text=...
-LinuxPanel.jchkScanMedia.text=Scan /media to find CD-ROM, DVD-ROM and FLASH disks?
+AdvancedOption_DisplayName_Linux=Linux
+AdvancedOption_Tooltip_Linux=Linux media options
+###
+ #  Copyright (C) 2008  Patr\u00EDcia Monteiro e S\u00E9rgio Lopes
+ #
+ #  This file is part of JFindMyFiles.
+ #
+ #  JFindMyFiles is free software: you can redistribute it and/or modify
+ #  it under the terms of the GNU General Public License as published by
+ #  the Free Software Foundation, either version 2 of the License, or
+ #  (at your option) any later version.
+ #
+ #  JFindMyFiles is distributed in the hope that it will be useful,
+ #  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ #  GNU General Public License for more details.
+ #
+ #  You should have received a copy of the GNU General Public License
+ #  along with JFindMyFiles.  If not, see 
+ # &lt;<A HREF="http://www.gnu.org/licenses/gpl.html">http://www.gnu.org/licenses/gpl.html</A>&gt;.
+ ##
+CTL_DuplicateResultsAction=DuplicateResults
+CTL_DuplicateResultsTopComponent=DuplicateResults Window
+CTL_FileListAction=FileList
+CTL_FileListTopComponent=FileList Window
+CTL_FilePropertiesAction=FileProperties
+CTL_FilePropertiesTopComponent=FileProperties Window
+CTL_LoanAction=Loan
+CTL_LoanTopComponent=Loan Window
+CTL_ManageUsersAction=ManageUsers
+CTL_ManageUsersTopComponent=ManageUsers Window
+CTL_SearchWindowAction=SearchWindow
+CTL_SearchWindowTopComponent=SearchWindow Window
+CTL_StatisticsAction=Statistics
+CTL_StatisticsTopComponent=Statistics Window
+CTL_WindowTestingAction=WindowTesting
+CTL_WindowTestingTopComponent=WindowTesting Window
+HINT_DuplicateResultsTopComponent=This is a DuplicateResults window
+HINT_FileListTopComponent=This is a FileList window
+HINT_FilePropertiesTopComponent=This is a FileProperties window
+HINT_LoanTopComponent=This is a Loan window
+HINT_ManageUsersTopComponent=This is a ManageUsers window
+HINT_SearchWindowTopComponent=This is a SearchWindow window
+HINT_StatisticsTopComponent=This is a Statistics window
+HINT_WindowTestingTopComponent=This is a WindowTesting window
+Installer.ClosingMessage=Exit JFindMyFiles?\n\nYou can change this behavior in the options panel.
+Installer.ClosingTitle=Confirm Exit
+AdvancedOption_DisplayName_MiscUser=General Behavior
+AdvancedOption_Tooltip_MiscUser=User information
+CTL_DetailsViewAction=DetailsView
+CTL_DetailsViewTopComponent=DetailsView Window
+CTL_NavigationTreeAction=NavigationTree
+CTL_NavigationTreeTopComponent=NavigationTree Window
+HINT_DetailsViewTopComponent=This is a DetailsView window
+HINT_NavigationTreeTopComponent=This is a NavigationTree window
+OpenIDE-Module-Name=JFindMyFilesGui
+CatalogOptionsCategory_Name=Catalog
+CatalogOptionsCategory_Title=Catalog
+PluginsOptionsCategory_Name=Plugins
+PluginsOptionsCategory_Title=Plugins
+CatalogOptionsPanel.jlblDatabase.text=Database:
+CatalogOptionsPanel.jlblPassword.text=Password:
+CatalogOptionsPanel.jlblPort.text=Port:
+CatalogOptionsPanel.jlblUsername.text=Username:
+CatalogOptionsPanel.jlblHostname.text=Hostname:
+CatalogOptionsPanel.jchkUserinternalDB.text=Use internal database
+CatalogOptionsPanel.jlblDefaultLocation.text=Default Location:
+CatalogOptionsPanel.jtfDefaultLocation.text=
+CatalogOptionsPanel.jbtnBrowse.text=...
+PluginsPanel.jlblPluginFolder.text=Plugin Folder:
+PluginsPanel.jtfPluginFolder.text=
+PluginsPanel.jbtnBrowse.text=...
+CatalogOptionsPanel.jLabel1.text=Server
+MiscPanel.jlblRememberedCatalogs.text=Nr. Remembered Catalogs:
+MiscPanel.jtfUserName.text=
+MiscPanel.jlblDisabeRememberCatalogsTip.text=(0 - disable)
+MiscPanel.jlblUserDataTitle.text=User Data:
+MiscPanel.jlblUserName.text=Name:
+MiscPanel.jlblEmail.text=E-mail:
+MiscPanel.jlblWebAddress.text=Web Address:
+MiscPanel.jtfEmail.text=
+MiscPanel.jtfWebAddress.text=
+MiscPanel.jlblBehaviorTitle.text=Behavior
+MiscPanel.jchkConfirmExit.text=Confirm exit on close
+SearchWindowTopComponent.jlbText.text=Text:
+SearchWindowTopComponent.jrdbDiskGroupOnly.text=Disk Group
+SearchWindowTopComponent.jrdbEntireCatalog.text=Entire Catalog
+SearchWindowTopComponent.jchkUseReGex.text=Use Regular Expressions
+SearchWindowTopComponent.jchkCaseSensitive.text=Case sensitive
+SearchWindowTopComponent.jchkSearchInDesc.text=Search in descriptions
+SearchWindowTopComponent.jbtnSearch.text=Search
+SearchWindowTopComponent.jtfSearchText.text=
+StatisticsTopComponent.jButton1.text=jButton1
+StatisticsTopComponent.jButton2.text=jButton2
+StatisticsTopComponent.jButton3.text=jButton3
+StatisticsTopComponent.jButton4.text=jButton4
+StatisticsTopComponent.jButton5.text=jButton5
+ManageUsersTopComponent.jbtnAddUser.text=
+ManageUsersTopComponent.jbtnRemoveUser.text=
+LinuxPanel.jlblMountFolder.text=Mount folder:
+LinuxPanel.jtfMountFolder.text=
+LinuxPanel.jbtnAdd.text=Add
+LinuxPanel.jbtnRemove.text=Remove
+LinuxPanel.jtbnBrowse.text=...
+LinuxPanel.jchkScanMedia.text=Scan /media to find CD-ROM, DVD-ROM and FLASH disks?

Modified: trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/DetailsViewTopComponent.form
===================================================================
--- trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/DetailsViewTopComponent.form	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/DetailsViewTopComponent.form	2008-07-08 17:02:52 UTC (rev 188)
@@ -15,31 +15,13 @@
   &lt;Layout&gt;
     &lt;DimensionLayout dim=&quot;0&quot;&gt;
       &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
-          &lt;Component id=&quot;jscpDetailsScroll&quot; alignment=&quot;1&quot; pref=&quot;468&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+          &lt;EmptySpace min=&quot;0&quot; pref=&quot;468&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
       &lt;/Group&gt;
     &lt;/DimensionLayout&gt;
     &lt;DimensionLayout dim=&quot;1&quot;&gt;
       &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
-          &lt;Component id=&quot;jscpDetailsScroll&quot; alignment=&quot;0&quot; pref=&quot;342&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+          &lt;EmptySpace min=&quot;0&quot; pref=&quot;342&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
       &lt;/Group&gt;
     &lt;/DimensionLayout&gt;
   &lt;/Layout&gt;
-  &lt;SubComponents&gt;
-    &lt;Container class=&quot;javax.swing.JScrollPane&quot; name=&quot;jscpDetailsScroll&quot;&gt;
-      &lt;AuxValues&gt;
-        &lt;AuxValue name=&quot;autoScrollPane&quot; type=&quot;java.lang.Boolean&quot; value=&quot;true&quot;/&gt;
-      &lt;/AuxValues&gt;
-
-      &lt;Layout class=&quot;org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout&quot;/&gt;
-      &lt;SubComponents&gt;
-        &lt;Component class=&quot;javax.swing.JTable&quot; name=&quot;jtDetailsTable&quot;&gt;
-          &lt;Properties&gt;
-            &lt;Property name=&quot;model&quot; type=&quot;javax.swing.table.TableModel&quot; editor=&quot;org.netbeans.modules.form.RADConnectionPropertyEditor&quot;&gt;
-              &lt;Connection code=&quot;nModel&quot; type=&quot;code&quot;/&gt;
-            &lt;/Property&gt;
-          &lt;/Properties&gt;
-        &lt;/Component&gt;
-      &lt;/SubComponents&gt;
-    &lt;/Container&gt;
-  &lt;/SubComponents&gt;
 &lt;/Form&gt;

Modified: trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/DetailsViewTopComponent.java
===================================================================
--- trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/DetailsViewTopComponent.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/DetailsViewTopComponent.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -47,16 +47,11 @@
 
     private static DetailsViewTopComponent instance;
     private static final String PREFERRED_ID = &quot;DetailsViewTopComponent&quot;;
-    private NodeModel nModel;
     private CatalogEngine eng;
-    private Lookup.Result catalogResult = null;
-    private Lookup.Result diskResult = null;
-    private Lookup.Result groupResult = null;
-    private Lookup.Result fileResult = null;
 
+
     private DetailsViewTopComponent() {
         eng = Lookup.getDefault().lookup(CatalogEngine.class);
-        nModel = new NodeModel();
         initComponents();
         setName(NbBundle.getMessage(DetailsViewTopComponent.class, &quot;CTL_DetailsViewTopComponent&quot;));
         setToolTipText(NbBundle.getMessage(DetailsViewTopComponent.class, &quot;HINT_DetailsViewTopComponent&quot;));
@@ -70,26 +65,18 @@
     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Generated Code&quot;&gt;//GEN-BEGIN:initComponents
     private void initComponents() {
 
-        jscpDetailsScroll = new javax.swing.JScrollPane();
-        jtDetailsTable = new javax.swing.JTable();
-
-        jtDetailsTable.setModel(nModel);
-        jscpDetailsScroll.setViewportView(jtDetailsTable);
-
         org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
         this.setLayout(layout);
         layout.setHorizontalGroup(
             layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-            .add(org.jdesktop.layout.GroupLayout.TRAILING, jscpDetailsScroll, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 468, Short.MAX_VALUE)
+            .add(0, 468, Short.MAX_VALUE)
         );
         layout.setVerticalGroup(
             layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-            .add(jscpDetailsScroll, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 342, Short.MAX_VALUE)
+            .add(0, 342, Short.MAX_VALUE)
         );
     }// &lt;/editor-fold&gt;//GEN-END:initComponents
     // Variables declaration - do not modify//GEN-BEGIN:variables
-    private javax.swing.JScrollPane jscpDetailsScroll;
-    private javax.swing.JTable jtDetailsTable;
     // End of variables declaration//GEN-END:variables
     /**
      * Gets default instance. Do not use directly: reserved for *.settings files only,
@@ -130,29 +117,12 @@
     @Override
     @SuppressWarnings(&quot;unchecked&quot;)
     public void componentOpened() {
-        diskResult = Utilities.actionsGlobalContext().lookup(new Lookup.Template(Media.class));
-        diskResult.addLookupListener(nModel);
 
-        catalogResult = Utilities.actionsGlobalContext().lookup(new Lookup.Template(CatalogEngine.class));
-        catalogResult.addLookupListener(nModel);
-
-        fileResult = Utilities.actionsGlobalContext().lookup(new Lookup.Template(FileWrapper.class));
-        fileResult.addLookupListener(nModel);
-
-        groupResult = Utilities.actionsGlobalContext().lookup(new Lookup.Template(DiskGroup.class));
-        groupResult.addLookupListener(nModel);
     }
 
     @Override
     public void componentClosed() {
-        diskResult.removeLookupListener(nModel);
-        diskResult = null;
-        catalogResult.removeLookupListener(nModel);
-        catalogResult = null;
-        fileResult.removeLookupListener(nModel);
-        fileResult = null;
-        groupResult.removeLookupListener(nModel);
-        groupResult = null;
+
     }
 
     /** replaces this in object stream */
@@ -174,248 +144,4 @@
             return DetailsViewTopComponent.getDefault();
         }
     }
-
-    private class NodeModel extends AbstractTableModel implements LookupListener {
-
-        private List catalogChildren;
-        private Object[] sItem = new Object[4];
-        private int sItemIndex;
-
-        public NodeModel() {
-            super();
-            loadCatalogChildren();
-            sItem[0] = eng;
-            catalogChildren = new ArrayList();
-        }
-
-        @SuppressWarnings(&quot;unchecked&quot;)
-        private void loadCatalogChildren() {
-            Session s = eng.sessionFactory.getCurrentSession();
-            s.beginTransaction();
-            catalogChildren.addAll(s.createQuery(&quot;from DiskGroup where parent.id is null&quot;).list());
-            catalogChildren.addAll(s.createQuery(&quot;from Media where group.id is null&quot;).list());
-            s.getTransaction().commit();
-        }
-
-        public int getRowCount() {
-            switch (sItemIndex) {
-                case 0://Catalog
-                    return catalogChildren.size();
-                case 1://Group
-                    return ((DiskGroup) sItem[1]).getGroupList().size() + ((DiskGroup) sItem[1]).getDiskList().size();
-                case 2://Media
-                    return ((Media) sItem[2]).getFileList().size();
-                case 3://File
-                    return ((FileWrapper) sItem[3]).getChildrenList().size();
-                default:
-                    return 0;
-            }
-        }
-
-        public int getColumnCount() {
-            switch (sItemIndex) {
-                case 0://CatalogEngine
-                    return 7;
-                case 1://Group
-                    return 7;
-                case 2://Media
-                case 3://File
-                    return 6;
-                default:
-                    return 0;
-            }
-        }
-
-        public Object getValueAt(int rowIndex, int columnIndex) {
-            Object o = null;
-            switch (sItemIndex) {
-                case 0://CatalogEngine
-                    o = catalogChildren.get(rowIndex);
-                    if (o instanceof DiskGroup) {
-                        switch (columnIndex) {
-                            case 0: //name;
-                                return ((DiskGroup) o).getName();
-                            case 1: //capacity;
-                                return ((DiskGroup) o).getCapacity();
-                            case 2: //freeSpace;
-                            case 3: //lastModified;
-                                return 0;
-                            case 6: //type;
-                                return &quot;Disk Group&quot;;//TODO: i18n
-                            case 4: //description;
-                                return ((DiskGroup) o).getDescription();
-                            case 5: //location;
-                                return &quot;&quot;;
-                        }
-                    } else {
-                        switch (columnIndex) {
-                            case 0: //name;
-                                return ((Media) o).getName();
-                            case 1: //capacity;
-                                return ((Media) o).getCapacity();
-                            case 2: //freeSpace;
-                                return ((Media) o).getFreeSpace();
-                            case 3: //lastModified;
-                                return ((Media) o).getLastModified();
-                            case 4: //type;
-                                return CatalogConstants.getTypeName(((Media) o).getType());
-                            case 5: //location;
-                                return ((Media) o).getLocation();
-                            case 6: //description;
-                                return ((Media) o).getDescription();
-                        }
-                    }
-                    return new Object();
-                case 1://Group
-                    if (rowIndex &lt; ((DiskGroup) sItem[1]).getGroupList().size()) {
-                        o = ((DiskGroup) sItem[1]).getGroupList().get(rowIndex);
-                    } else {
-                        o = ((DiskGroup) sItem[1]).getDiskList().get(rowIndex - ((DiskGroup) sItem[1]).getGroupList().size());
-                    }
-                    if (o instanceof DiskGroup) {
-                        switch (columnIndex) {
-                            case 0: //name;
-                                return ((DiskGroup) o).getName();
-                            case 1: //description;
-                                return ((DiskGroup) o).getDescription();
-                            case 2: //capacity;
-                                return ((DiskGroup) o).getCapacity();
-                            case 3: //lastModified;
-                            case 4: //freeSpace;
-                                return 0;
-                            case 5: //location;
-                                return &quot;&quot;;
-                            case 6: //type;
-                                return &quot;Disk Group&quot;;//TODO: i18n
-                        }
-                    } else {
-                        switch (columnIndex) {
-                            case 0: //name;
-                                return ((Media) o).getName();
-                            case 1: //description;
-                                return ((Media) o).getDescription();
-                            case 2: //capacity;
-                                return ((Media) o).getCapacity();
-                            case 3: //lastModified;
-                                return ((Media) o).getLastModified();
-                            case 4: //freeSpace;
-                                return ((Media) o).getFreeSpace();
-                            case 5: //location;
-                                return ((Media) o).getLocation();
-                            case 6: //type;
-                                return CatalogConstants.getTypeName(((Media) o).getType());
-                        }
-                    }
-                    return new Object();
-                case 2://Media
-                case 3://File
-                    if (o instanceof Media) {
-                        switch (columnIndex) {
-                            case 0://name
-                                return ((Media) o).getName();
-                            case 1://extension;
-                                return &quot;&quot;;
-                            case 2://size;
-                                return ((Media) o).getCapacity() - ((Media) o).getFreeSpace();
-                            case 3://lastModified;
-                                return ((Media) o).getLastModified();
-                            case 4://sha1;
-                                return &quot;&quot;;
-                            case 5://description;
-                                return ((Media) o).getDescription();
-                        }
-                    } else {
-                        switch (columnIndex) {
-                            case 0://name
-                                return ((FileWrapper) o).getName();
-                            case 1://extension;
-                                return ((FileWrapper) o).getExtension();
-                            case 2://size;
-                                return ((FileWrapper) o).getSize();
-                            case 3://lastModified;
-                                return ((FileWrapper) o).getLastModified();
-                            case 4://sha1;
-                                return ((FileWrapper) o).getSha1();
-                            case 5://description;
-                                return ((FileWrapper) o).getDescription();
-                        }
-                    }
-                    return new Object();
-                default:
-                    return new Object();
-            }
-        }
-
-        @Override
-        public Class getColumnClass(int columnIndex) {
-            Object o = null;
-            switch (sItemIndex) {
-                case 0://CatalogEngine
-                    switch (columnIndex) {
-                        case 1: //capacity;
-                        case 2: //freeSpace;
-                        case 3: //lastModified;
-                            return long.class;
-                        case 0: //name;
-                        case 6: //type;
-                        case 4: //description;
-                        case 5: //location;
-                            return String.class;
-                        default:
-                            return Object.class;
-                    }
-                case 1://Group
-                    switch (columnIndex) {
-                        case 0: //name;
-                        case 1: //description;
-                        case 5: //location;
-                        case 6: //type;
-                            return String.class;
-                        case 2: //capacity;
-                        case 3: //lastModified;
-                        case 4: //freeSpace;
-                            return long.class;
-                        default:
-                            return Object.class;
-                    }
-                case 2://Media
-                case 3://File
-                    switch (columnIndex) {
-                        case 0://name
-                        case 1://extension;
-                        case 4://sha1;
-                        case 5://description;
-                            return String.class;
-                        case 2://size;
-                        case 3://lastModified;
-                            return long.class;
-                        default:
-                            return Object.class;
-                    }
-                default:
-                    return Object.class;
-            }
-        }
-
-        public void resultChanged(LookupEvent evt) {
-            Collection c = ((Lookup.Result) evt.getSource()).allInstances();
-            Object o;
-            if (!c.isEmpty()) {
-                o = c.iterator().next();
-                if (o instanceof CatalogEngine) {
-                    sItemIndex = 0;
-                } else if (o instanceof DiskGroup) {
-                    sItem[1] = o;
-                    sItemIndex = 1;
-                } else if (o instanceof Media) {
-                    sItem[2] = o;
-                    sItemIndex = 2;
-                } else if (o instanceof FileWrapper) {
-                    sItem[3] = o;
-                    sItemIndex = 3;
-                }
-                fireTableDataChanged();
-            }
-        }
-    }
 }

Modified: trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/WindowTestingAction.java
===================================================================
--- trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/WindowTestingAction.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/WindowTestingAction.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -26,4 +26,8 @@
         win.open();
         win.requestActive();
     }
+    
+    public boolean isEnabled() {
+        return false;
+    }
 }

Modified: trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/WindowTestingTopComponent.java
===================================================================
--- trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/WindowTestingTopComponent.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/WindowTestingTopComponent.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -27,6 +27,8 @@
 import javax.swing.table.AbstractTableModel;
 import javax.swing.table.TableCellRenderer;
 import org.hibernate.Session;
+import org.netbeans.api.tableview.TableView;
+import org.openide.explorer.ExplorerManager;
 import org.openide.explorer.propertysheet.PropertyPanel;
 import org.openide.explorer.propertysheet.PropertySheet;
 import org.openide.explorer.view.NodeTableModel;
@@ -43,12 +45,14 @@
 /**
  * Top component which displays something.
  */
-final class WindowTestingTopComponent extends TopComponent implements /*ExplorerManager.Provider,*/ LookupListener {
+final class WindowTestingTopComponent extends TopComponent implements ExplorerManager.Provider, LookupListener {
 
     private NodeTableModel ntModel;
     private static WindowTestingTopComponent instance;
     private static final String PREFERRED_ID = &quot;WindowTestingTopComponent&quot;;
-
+    private org.netbeans.api.tableview.NodeTableModel ntm2;
+    private ExplorerManager man;
+    
     private WindowTestingTopComponent() {
         ntModel = new NodeTableModel();
         ntModel.addTableModelListener(new TableModelListener() {
@@ -57,15 +61,27 @@
                 System.err.println(&quot;VALUE CLASS: &quot; + ntModel.getColumnClass(e.getColumn()));
             }
         });
+
+
         Lookup.Result r = Utilities.actionsGlobalContext().lookup(new Lookup.Template&lt;Media&gt;(Media.class));
         r.addLookupListener(this);
         initComponents();
+        ntm2 = new org.netbeans.api.tableview.NodeTableModel();
+        ntm2.addTableModelListener(new TableModelListener() {
+
+            public void tableChanged(TableModelEvent e) {
+                System.err.println(&quot;VALUE CLASS: &quot; + ntModel.getColumnClass(e.getColumn()));
+            }
+        });
+        
+        TableView tf = new TableView(ntm2);
+        add(tf, BorderLayout.NORTH);
         smallInit();
         setName(NbBundle.getMessage(WindowTestingTopComponent.class, &quot;CTL_WindowTestingTopComponent&quot;));
         setToolTipText(NbBundle.getMessage(WindowTestingTopComponent.class, &quot;HINT_WindowTestingTopComponent&quot;));
-        //
-        //WORK DAMN YOU!!!!!!!!!!!!!!!!!!!
-        //jTable1.setDefaultRenderer(Node.Property.class, new AnotherPropertyCellRenderer());
+    //
+    //WORK DAMN YOU!!!!!!!!!!!!!!!!!!!
+    //jTable1.setDefaultRenderer(Node.Property.class, new AnotherPropertyCellRenderer());
 //        setIcon(Utilities.loadImage(ICON_PATH, true));
     }
 
@@ -164,32 +180,32 @@
         //Node[] act = registry.getCurrentNodes();
         ntModel.setNodes(act);
         //ntModel.fireTableStructureChanged();
-        ps.setNodes(act);
+        //ps.setNodes(act);
+        //ntm2.setNodes(act);
         for (Node n : act) {
             System.out.println(n);
         }
     }
-    
     PropertySheet ps = new PropertySheet();
-    
+
     private void smallInit() {
-        add(ps, BorderLayout.NORTH);
+        /*add(ps, BorderLayout.NORTH);
         /*jTable1.setModel(new AbstractTableModel() {
-
-            public int getRowCount() {
-                return 5;
-            }
-
-            public int getColumnCount() {
-                return 10;
-            }
-
-            public Object getValueAt(int rowIndex, int columnIndex) {
-                return &quot;value&quot;;
-            }
+        
+        public int getRowCount() {
+        return 5;
+        }
+        
+        public int getColumnCount() {
+        return 10;
+        }
+        
+        public Object getValueAt(int rowIndex, int columnIndex) {
+        return &quot;value&quot;;
+        }
         });*/
-        jTable1.setDefaultRenderer(Node.Property.class, new AnotherPropertyCellRenderer());
-        jTable1.setModel(ntModel);
+        /*jTable1.setDefaultRenderer(Node.Property.class, new AnotherPropertyCellRenderer());
+        jTable1.setModel(ntModel);*/
     }
 
     class AnotherPropertyCellRenderer extends JLabel implements TableCellRenderer {
@@ -199,8 +215,8 @@
             setBackground(Color.GREEN);
             return this;
         }
-    }    
-    
+    }
+
     class PropertyCellRenderer implements TableCellRenderer {
 
         public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
@@ -233,4 +249,12 @@
             }
         }
     }
+
+    public ExplorerManager getExplorerManager() {
+        if(man == null) {
+            NavigationTreeTopComponent c = NavigationTreeTopComponent.findInstance();
+            man = c.getExplorerManager();
+        }
+        return man;
+    }
 }

Modified: trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/layer.xml
===================================================================
--- trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/layer.xml	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui/layer.xml	2008-07-08 17:02:52 UTC (rev 188)
@@ -46,6 +46,8 @@
         &lt;folder name=&quot;Window&quot;&gt;
             &lt;file name=&quot;de-berlios-jfindmyfiles-jfindmyfilesgui-DetailsViewAction.instance&quot;/&gt;
             &lt;file name=&quot;de-berlios-jfindmyfiles-jfindmyfilesgui-DuplicateResultsAction.instance&quot;/&gt;
+            &lt;file name=&quot;de-berlios-jfindmyfiles-jfindmyfilesgui-FileListAction.instance&quot;/&gt;
+            &lt;file name=&quot;de-berlios-jfindmyfiles-jfindmyfilesgui-FilePropertiesAction.instance&quot;/&gt;
             &lt;file name=&quot;de-berlios-jfindmyfiles-jfindmyfilesgui-LoanAction.instance&quot;/&gt;
             &lt;file name=&quot;de-berlios-jfindmyfiles-jfindmyfilesgui-ManageUsersAction.instance&quot;/&gt;
             &lt;file name=&quot;de-berlios-jfindmyfiles-jfindmyfilesgui-NavigationTreeAction.instance&quot;/&gt;
@@ -187,6 +189,12 @@
             &lt;file name=&quot;DuplicateResultsAction.shadow&quot;&gt;
                 &lt;attr name=&quot;originalFile&quot; stringvalue=&quot;Actions/Window/de-berlios-jfindmyfiles-jfindmyfilesgui-DuplicateResultsAction.instance&quot;/&gt;
             &lt;/file&gt;
+            &lt;file name=&quot;FileListAction.shadow&quot;&gt;
+                &lt;attr name=&quot;originalFile&quot; stringvalue=&quot;Actions/Window/de-berlios-jfindmyfiles-jfindmyfilesgui-FileListAction.instance&quot;/&gt;
+            &lt;/file&gt;
+            &lt;file name=&quot;FilePropertiesAction.shadow&quot;&gt;
+                &lt;attr name=&quot;originalFile&quot; stringvalue=&quot;Actions/Window/de-berlios-jfindmyfiles-jfindmyfilesgui-FilePropertiesAction.instance&quot;/&gt;
+            &lt;/file&gt;
             &lt;file name=&quot;LoanAction.shadow&quot;&gt;
                 &lt;attr name=&quot;originalFile&quot; stringvalue=&quot;Actions/Window/de-berlios-jfindmyfiles-jfindmyfilesgui-LoanAction.instance&quot;/&gt;
             &lt;/file&gt;
@@ -253,6 +261,8 @@
         &lt;folder name=&quot;Components&quot;&gt;
             &lt;file name=&quot;DetailsViewTopComponent.settings&quot; url=&quot;DetailsViewTopComponentSettings.xml&quot;/&gt;
             &lt;file name=&quot;DuplicateResultsTopComponent.settings&quot; url=&quot;DuplicateResultsTopComponentSettings.xml&quot;/&gt;
+            &lt;file name=&quot;FileListTopComponent.settings&quot; url=&quot;FileListTopComponentSettings.xml&quot;/&gt;
+            &lt;file name=&quot;FilePropertiesTopComponent.settings&quot; url=&quot;FilePropertiesTopComponentSettings.xml&quot;/&gt;
             &lt;file name=&quot;LoanTopComponent.settings&quot; url=&quot;LoanTopComponentSettings.xml&quot;/&gt;
             &lt;file name=&quot;ManageUsersTopComponent.settings&quot; url=&quot;ManageUsersTopComponentSettings.xml&quot;/&gt;
             &lt;file name=&quot;NavigationTreeTopComponent.settings&quot; url=&quot;NavigationTreeTopComponentSettings.xml&quot;/&gt;
@@ -263,6 +273,7 @@
         &lt;folder name=&quot;Modes&quot;&gt;
             &lt;folder name=&quot;editor&quot;&gt;
                 &lt;file name=&quot;DetailsViewTopComponent.wstcref&quot; url=&quot;DetailsViewTopComponentWstcref.xml&quot;/&gt;
+                &lt;file name=&quot;FileListTopComponent.wstcref&quot; url=&quot;FileListTopComponentWstcref.xml&quot;/&gt;
                 &lt;file name=&quot;LoanTopComponent.wstcref&quot; url=&quot;LoanTopComponentWstcref.xml&quot;/&gt;
                 &lt;file name=&quot;ManageUsersTopComponent.wstcref&quot; url=&quot;ManageUsersTopComponentWstcref.xml&quot;/&gt;
                 &lt;file name=&quot;SearchWindowTopComponent.wstcref&quot; url=&quot;SearchWindowTopComponentWstcref.xml&quot;/&gt;
@@ -275,6 +286,9 @@
             &lt;folder name=&quot;output&quot;&gt;
                 &lt;file name=&quot;DuplicateResultsTopComponent.wstcref&quot; url=&quot;DuplicateResultsTopComponentWstcref.xml&quot;/&gt;
             &lt;/folder&gt;
+            &lt;folder name=&quot;properties&quot;&gt;
+                &lt;file name=&quot;FilePropertiesTopComponent.wstcref&quot; url=&quot;FilePropertiesTopComponentWstcref.xml&quot;/&gt;
+            &lt;/folder&gt;
         &lt;/folder&gt;
     &lt;/folder&gt;
 &lt;/filesystem&gt;

Modified: trunk/project/JFindMyFiles/nbproject/project.properties
===================================================================
--- trunk/project/JFindMyFiles/nbproject/project.properties	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/nbproject/project.properties	2008-07-08 17:02:52 UTC (rev 188)
@@ -13,7 +13,9 @@
     ${project.com.toedter.plaf}:\
     ${project.de.berlios.jfindmyfiles.importengine}:\
     ${project.jonelo.jacksum}:\
-    ${project.com.drew.lang}
+    ${project.com.drew.lang}:\
+    ${project.org.netbeans.swing.etable}:\
+    ${project.org.netbeans.modules.tableview}
 project.com.drew.lang=MetadataExtractor
 project.com.toedter.plaf=JCalendar
 project.de.berlios.jfindmyfiles.catalog=Catalog
@@ -25,3 +27,5 @@
 project.de.berlios.jfindmyfiles.persistence=Persistence
 project.de.berlios.jfindmyfiles.readingfiles=ReadingFiles
 project.jonelo.jacksum=JaCKSum
+project.org.netbeans.modules.tableview=tableview
+project.org.netbeans.swing.etable=org-netbeans-swing-outline

Added: trunk/project/JFindMyFiles/org-netbeans-swing-outline/build.xml
===================================================================
--- trunk/project/JFindMyFiles/org-netbeans-swing-outline/build.xml	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/org-netbeans-swing-outline/build.xml	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,8 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;!-- You may freely edit this file. See harness/README in the NetBeans platform --&gt;
+&lt;!-- for some information on what you could do (e.g. targets to override). --&gt;
+&lt;!-- If you delete this file and reopen the project it will be recreated. --&gt;
+&lt;project name=&quot;org.netbeans.swing.etable&quot; default=&quot;netbeans&quot; basedir=&quot;.&quot;&gt;
+    &lt;description&gt;Builds, tests, and runs the project org.netbeans.swing.etable.&lt;/description&gt;
+    &lt;import file=&quot;nbproject/build-impl.xml&quot;/&gt;
+&lt;/project&gt;

Added: trunk/project/JFindMyFiles/org-netbeans-swing-outline/manifest.mf
===================================================================
--- trunk/project/JFindMyFiles/org-netbeans-swing-outline/manifest.mf	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/org-netbeans-swing-outline/manifest.mf	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,5 @@
+Manifest-Version: 1.0
+OpenIDE-Module: org.netbeans.swing.etable
+OpenIDE-Module-Localizing-Bundle: org/netbeans/swing/etable/Bundle.properties
+OpenIDE-Module-Specification-Version: 1.0
+

Added: trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/build-impl.xml
===================================================================
--- trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/build-impl.xml	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/build-impl.xml	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,30 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;!--
+*** GENERATED FROM project.xml - DO NOT EDIT  ***
+***         EDIT ../build.xml INSTEAD         ***
+--&gt;
+&lt;project name=&quot;org.netbeans.swing.etable-impl&quot; basedir=&quot;..&quot;&gt;
+    &lt;property file=&quot;nbproject/private/suite-private.properties&quot;/&gt;
+    &lt;property file=&quot;nbproject/suite.properties&quot;/&gt;
+    &lt;fail unless=&quot;suite.dir&quot;&gt;You must set 'suite.dir' to point to your containing module suite&lt;/fail&gt;
+    &lt;property file=&quot;${suite.dir}/nbproject/private/platform-private.properties&quot;/&gt;
+    &lt;property file=&quot;${suite.dir}/nbproject/platform.properties&quot;/&gt;
+    &lt;macrodef uri=&quot;<A HREF="http://www.netbeans.org/ns/nb-module-project/2">http://www.netbeans.org/ns/nb-module-project/2</A>&quot; name=&quot;property&quot;&gt;
+        &lt;attribute name=&quot;name&quot;/&gt;
+        &lt;attribute name=&quot;value&quot;/&gt;
+        &lt;sequential&gt;
+            &lt;property value=&quot;${@{value}}&quot; name=&quot;@{name}&quot;/&gt;
+        &lt;/sequential&gt;
+    &lt;/macrodef&gt;
+    &lt;property file=&quot;${user.properties.file}&quot;/&gt;
+    &lt;nbmproject2:property xmlns:nbmproject2=&quot;<A HREF="http://www.netbeans.org/ns/nb-module-project/2">http://www.netbeans.org/ns/nb-module-project/2</A>&quot; value=&quot;nbplatform.${nbplatform.active}.harness.dir&quot; name=&quot;harness.dir&quot;/&gt;
+    &lt;nbmproject2:property xmlns:nbmproject2=&quot;<A HREF="http://www.netbeans.org/ns/nb-module-project/2">http://www.netbeans.org/ns/nb-module-project/2</A>&quot; value=&quot;nbplatform.${nbplatform.active}.netbeans.dest.dir&quot; name=&quot;netbeans.dest.dir&quot;/&gt;
+    &lt;fail message=&quot;You must define 'nbplatform.${nbplatform.active}.harness.dir'&quot;&gt;
+        &lt;condition&gt;
+            &lt;not&gt;
+                &lt;available type=&quot;dir&quot; file=&quot;${harness.dir}&quot;/&gt;
+            &lt;/not&gt;
+        &lt;/condition&gt;
+    &lt;/fail&gt;
+    &lt;import file=&quot;${harness.dir}/build.xml&quot;/&gt;
+&lt;/project&gt;

Added: trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/genfiles.properties
===================================================================
--- trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/genfiles.properties	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/genfiles.properties	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,8 @@
+build.xml.data.CRC32=7e04d8ea
+build.xml.script.CRC32=c7e7cfe4
+build.xml.stylesheet.CRC32=79c3b980
+# This file is used by a NetBeans-based IDE to track changes in generated files such as build-impl.xml.
+# Do not edit this file. You may delete it but then the IDE will never regenerate such files for you.
+nbproject/build-impl.xml.data.CRC32=7e04d8ea
+nbproject/build-impl.xml.script.CRC32=44951d3d
+nbproject/build-impl.xml.stylesheet.CRC32=deb65f65

Added: trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/platform.properties
===================================================================
--- trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/platform.properties	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/platform.properties	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,21 @@
+# Deprecated since 5.0u1; for compatibility with 5.0:
+disabled.clusters=\
+    apisupport1,\
+    cnd2,\
+    enterprise5,\
+    gsf1,\
+    ide9,\
+    identity2,\
+    java2,\
+    nb6.1,\
+    profiler3,\
+    uml5,\
+    visualweb2,\
+    xml2
+disabled.modules=\
+    org.netbeans.api.visual,\
+    org.netbeans.modules.apisupport.harness
+enabled.clusters=\
+    harness,\
+    platform8
+nbplatform.active=default

Added: trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/project.properties
===================================================================
--- trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/project.properties	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/project.properties	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1 @@
+is.autoload=true

Added: trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/project.xml
===================================================================
--- trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/project.xml	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/project.xml	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,19 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;project xmlns=&quot;<A HREF="http://www.netbeans.org/ns/project/1">http://www.netbeans.org/ns/project/1</A>&quot;&gt;
+    &lt;type&gt;org.netbeans.modules.apisupport.project&lt;/type&gt;
+    &lt;configuration&gt;
+        &lt;data xmlns=&quot;<A HREF="http://www.netbeans.org/ns/nb-module-project/3">http://www.netbeans.org/ns/nb-module-project/3</A>&quot;&gt;
+            &lt;code-name-base&gt;org.netbeans.swing.etable&lt;/code-name-base&gt;
+            &lt;suite-component/&gt;
+            &lt;module-dependencies/&gt;
+            &lt;public-packages&gt;
+                &lt;package&gt;org.netbeans.swing.etable&lt;/package&gt;
+                &lt;package&gt;org.netbeans.swing.outline&lt;/package&gt;
+            &lt;/public-packages&gt;
+            &lt;class-path-extension&gt;
+                &lt;runtime-relative-path&gt;ext/org-netbeans-swing-outline.jar&lt;/runtime-relative-path&gt;
+                &lt;binary-origin&gt;release/modules/ext/org-netbeans-swing-outline.jar&lt;/binary-origin&gt;
+            &lt;/class-path-extension&gt;
+        &lt;/data&gt;
+    &lt;/configuration&gt;
+&lt;/project&gt;

Added: trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/suite.properties
===================================================================
--- trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/suite.properties	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/org-netbeans-swing-outline/nbproject/suite.properties	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1 @@
+suite.dir=${basedir}/..

Added: trunk/project/JFindMyFiles/org-netbeans-swing-outline/release/modules/ext/org-netbeans-swing-outline.jar
===================================================================
(Binary files differ)


Property changes on: trunk/project/JFindMyFiles/org-netbeans-swing-outline/release/modules/ext/org-netbeans-swing-outline.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans/swing/etable/Bundle.properties
===================================================================
--- trunk/project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans/swing/etable/Bundle.properties	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/org-netbeans-swing-outline/src/org/netbeans/swing/etable/Bundle.properties	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1 @@
+OpenIDE-Module-Name=org-netbeans-swing-outline

Added: trunk/project/JFindMyFiles/tableview/build.xml
===================================================================
--- trunk/project/JFindMyFiles/tableview/build.xml	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/build.xml	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,8 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;!-- You may freely edit this file. See harness/README in the NetBeans platform --&gt;
+&lt;!-- for some information on what you could do (e.g. targets to override). --&gt;
+&lt;!-- If you delete this file and reopen the project it will be recreated. --&gt;
+&lt;project name=&quot;org.netbeans.modules.tableview&quot; default=&quot;netbeans&quot; basedir=&quot;.&quot;&gt;
+    &lt;description&gt;Builds, tests, and runs the project org.netbeans.modules.tableview.&lt;/description&gt;
+    &lt;import file=&quot;nbproject/build-impl.xml&quot;/&gt;
+&lt;/project&gt;

Added: trunk/project/JFindMyFiles/tableview/license.txt
===================================================================
--- trunk/project/JFindMyFiles/tableview/license.txt	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/license.txt	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,15 @@
+                Sun Public License Notice
+
+The contents of this file are subject to the Sun Public License
+Version 1.0 (the &quot;License&quot;). You may not use this file except in
+compliance with the License. A copy of the License is available at
+<A HREF="http://www.sun.com/">http://www.sun.com/</A>
+
+The Original Code is the Bookmarks module. The Initial Developer
+of the Original Code is Nokia. Portions Copyright 2005 Nokia.
+All Rights Reserved.
+
+
+------------------------------------------------------------------
+NOTE: See the docs/readme.txt file for information about the 
+origin of this module.
\ No newline at end of file

Added: trunk/project/JFindMyFiles/tableview/manifest.mf
===================================================================
--- trunk/project/JFindMyFiles/tableview/manifest.mf	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/manifest.mf	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,7 @@
+Manifest-Version: 1.0
+OpenIDE-Module-Specification-Version: 0.3
+Created-By: Nokia
+OpenIDE-Module: org.netbeans.modules.tableview/1
+OpenIDE-Module-Display-Category: Infrastructure
+OpenIDE-Module-Localizing-Bundle: org/netbeans/modules/tableview/resources/Bundle.properties
+

Added: trunk/project/JFindMyFiles/tableview/nbproject/build-impl.xml
===================================================================
--- trunk/project/JFindMyFiles/tableview/nbproject/build-impl.xml	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/nbproject/build-impl.xml	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,30 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;!--
+*** GENERATED FROM project.xml - DO NOT EDIT  ***
+***         EDIT ../build.xml INSTEAD         ***
+--&gt;
+&lt;project name=&quot;org.netbeans.modules.tableview-impl&quot; basedir=&quot;..&quot;&gt;
+    &lt;property file=&quot;nbproject/private/suite-private.properties&quot;/&gt;
+    &lt;property file=&quot;nbproject/suite.properties&quot;/&gt;
+    &lt;fail unless=&quot;suite.dir&quot;&gt;You must set 'suite.dir' to point to your containing module suite&lt;/fail&gt;
+    &lt;property file=&quot;${suite.dir}/nbproject/private/platform-private.properties&quot;/&gt;
+    &lt;property file=&quot;${suite.dir}/nbproject/platform.properties&quot;/&gt;
+    &lt;macrodef uri=&quot;<A HREF="http://www.netbeans.org/ns/nb-module-project/2">http://www.netbeans.org/ns/nb-module-project/2</A>&quot; name=&quot;property&quot;&gt;
+        &lt;attribute name=&quot;name&quot;/&gt;
+        &lt;attribute name=&quot;value&quot;/&gt;
+        &lt;sequential&gt;
+            &lt;property value=&quot;${@{value}}&quot; name=&quot;@{name}&quot;/&gt;
+        &lt;/sequential&gt;
+    &lt;/macrodef&gt;
+    &lt;property file=&quot;${user.properties.file}&quot;/&gt;
+    &lt;nbmproject2:property xmlns:nbmproject2=&quot;<A HREF="http://www.netbeans.org/ns/nb-module-project/2">http://www.netbeans.org/ns/nb-module-project/2</A>&quot; value=&quot;nbplatform.${nbplatform.active}.harness.dir&quot; name=&quot;harness.dir&quot;/&gt;
+    &lt;nbmproject2:property xmlns:nbmproject2=&quot;<A HREF="http://www.netbeans.org/ns/nb-module-project/2">http://www.netbeans.org/ns/nb-module-project/2</A>&quot; value=&quot;nbplatform.${nbplatform.active}.netbeans.dest.dir&quot; name=&quot;netbeans.dest.dir&quot;/&gt;
+    &lt;fail message=&quot;You must define 'nbplatform.${nbplatform.active}.harness.dir'&quot;&gt;
+        &lt;condition&gt;
+            &lt;not&gt;
+                &lt;available type=&quot;dir&quot; file=&quot;${harness.dir}&quot;/&gt;
+            &lt;/not&gt;
+        &lt;/condition&gt;
+    &lt;/fail&gt;
+    &lt;import file=&quot;${harness.dir}/build.xml&quot;/&gt;
+&lt;/project&gt;

Added: trunk/project/JFindMyFiles/tableview/nbproject/genfiles.properties
===================================================================
--- trunk/project/JFindMyFiles/tableview/nbproject/genfiles.properties	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/nbproject/genfiles.properties	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,8 @@
+build.xml.data.CRC32=c39d8c26
+build.xml.script.CRC32=c8f313fe
+build.xml.stylesheet.CRC32=79c3b980
+# This file is used by a NetBeans-based IDE to track changes in generated files such as build-impl.xml.
+# Do not edit this file. You may delete it but then the IDE will never regenerate such files for you.
+nbproject/build-impl.xml.data.CRC32=c39d8c26
+nbproject/build-impl.xml.script.CRC32=b9cfbea7
+nbproject/build-impl.xml.stylesheet.CRC32=deb65f65

Added: trunk/project/JFindMyFiles/tableview/nbproject/platform.properties
===================================================================
--- trunk/project/JFindMyFiles/tableview/nbproject/platform.properties	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/nbproject/platform.properties	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,17 @@
+# Deprecated since 5.0u1; for compatibility with 5.0:
+disabled.clusters=\
+    bundled_app_server_install,\
+    enterprise3,\
+    harness,\
+    identity1,\
+    profiler1,\
+    soa1,\
+    xmltools1
+disabled.modules=\
+    org.netbeans.modules.applemenu,\
+    org.openide.compat
+enabled.clusters=\
+    ide7,\
+    nb5.5,\
+    platform6
+nbplatform.active=default

Added: trunk/project/JFindMyFiles/tableview/nbproject/project.properties
===================================================================
--- trunk/project/JFindMyFiles/tableview/nbproject/project.properties	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/nbproject/project.properties	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,23 @@
+# The contents of this file are subject to the terms of the Common Development
+# and Distribution License (the License). You may not use this file except in
+# compliance with the License.
+#
+# You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+# or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+#
+# When distributing Covered Code, include this CDDL Header Notice in each file
+# and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+# If applicable, add the following below the CDDL Header, with the fields
+# enclosed by brackets [] replaced by your own identifying information:
+# &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+#
+# The Original Software is the Bookmarks module. The Initial Developer
+# of the Original Software is Nokia. Portions Copyright 2005 Nokia.
+# All Rights Reserved.
+
+
+# If adding dependencies on 3rd party jars (jdom, jgraph, etc.)
+# uncomment this section...
+#cp.extra=lib/jdom.jar: \
+#         lib/jgraph.jar
+

Added: trunk/project/JFindMyFiles/tableview/nbproject/project.xml
===================================================================
--- trunk/project/JFindMyFiles/tableview/nbproject/project.xml	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/nbproject/project.xml	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,65 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;project xmlns=&quot;<A HREF="http://www.netbeans.org/ns/project/1">http://www.netbeans.org/ns/project/1</A>&quot;&gt;
+    &lt;type&gt;org.netbeans.modules.apisupport.project&lt;/type&gt;
+    &lt;configuration&gt;
+        &lt;data xmlns=&quot;<A HREF="http://www.netbeans.org/ns/nb-module-project/2">http://www.netbeans.org/ns/nb-module-project/2</A>&quot;&gt;
+            &lt;code-name-base&gt;org.netbeans.modules.tableview&lt;/code-name-base&gt;
+            &lt;suite-component/&gt;
+            &lt;module-dependencies&gt;
+                &lt;dependency&gt;
+                    &lt;code-name-base&gt;org.openide.actions&lt;/code-name-base&gt;
+                    &lt;build-prerequisite/&gt;
+                    &lt;compile-dependency/&gt;
+                    &lt;run-dependency&gt;
+                        &lt;specification-version&gt;6.2&lt;/specification-version&gt;
+                    &lt;/run-dependency&gt;
+                &lt;/dependency&gt;
+                &lt;dependency&gt;
+                    &lt;code-name-base&gt;org.openide.awt&lt;/code-name-base&gt;
+                    &lt;build-prerequisite/&gt;
+                    &lt;compile-dependency/&gt;
+                    &lt;run-dependency&gt;
+                        &lt;specification-version&gt;6.2&lt;/specification-version&gt;
+                    &lt;/run-dependency&gt;
+                &lt;/dependency&gt;
+                &lt;dependency&gt;
+                    &lt;code-name-base&gt;org.openide.dialogs&lt;/code-name-base&gt;
+                    &lt;build-prerequisite/&gt;
+                    &lt;compile-dependency/&gt;
+                    &lt;run-dependency&gt;
+                        &lt;specification-version&gt;6.2&lt;/specification-version&gt;
+                    &lt;/run-dependency&gt;
+                &lt;/dependency&gt;
+                &lt;dependency&gt;
+                    &lt;code-name-base&gt;org.openide.explorer&lt;/code-name-base&gt;
+                    &lt;build-prerequisite/&gt;
+                    &lt;compile-dependency/&gt;
+                    &lt;run-dependency&gt;
+                        &lt;implementation-version/&gt;
+                    &lt;/run-dependency&gt;
+                &lt;/dependency&gt;
+                &lt;dependency&gt;
+                    &lt;code-name-base&gt;org.openide.nodes&lt;/code-name-base&gt;
+                    &lt;build-prerequisite/&gt;
+                    &lt;compile-dependency/&gt;
+                    &lt;run-dependency&gt;
+                        &lt;specification-version&gt;6.2&lt;/specification-version&gt;
+                    &lt;/run-dependency&gt;
+                &lt;/dependency&gt;
+                &lt;dependency&gt;
+                    &lt;code-name-base&gt;org.openide.util&lt;/code-name-base&gt;
+                    &lt;build-prerequisite/&gt;
+                    &lt;compile-dependency/&gt;
+                    &lt;run-dependency&gt;
+                        &lt;specification-version&gt;6.2&lt;/specification-version&gt;
+                    &lt;/run-dependency&gt;
+                &lt;/dependency&gt;
+            &lt;/module-dependencies&gt;
+            &lt;public-packages&gt;
+                &lt;package&gt;org.netbeans.api.tableview&lt;/package&gt;
+                &lt;package&gt;org.netbeans.swing.etable&lt;/package&gt;
+                &lt;package&gt;org.netbeans.swing.outline&lt;/package&gt;
+            &lt;/public-packages&gt;
+        &lt;/data&gt;
+    &lt;/configuration&gt;
+&lt;/project&gt;

Added: trunk/project/JFindMyFiles/tableview/nbproject/suite.properties
===================================================================
--- trunk/project/JFindMyFiles/tableview/nbproject/suite.properties	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/nbproject/suite.properties	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1 @@
+suite.dir=${basedir}/..

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/Bundle.properties
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/Bundle.properties	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/Bundle.properties	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,43 @@
+# The contents of this file are subject to the terms of the Common Development
+# and Distribution License (the License). You may not use this file except in
+# compliance with the License.
+#
+# You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+# or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+#
+# When distributing Covered Code, include this CDDL Header Notice in each file
+# and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+# If applicable, add the following below the CDDL Header, with the fields
+# enclosed by brackets [] replaced by your own identifying information:
+# &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+#
+# The Original Software is NetBeans. The Initial Developer of the Original
+# Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+# Microsystems, Inc. All Rights Reserved.
+
+
+
+# TreeView
+VetoSelectedNodes=Selected Nodes
+
+#TableSheet
+ACS_TableSheet=Table of properties
+ACSD_TableSheet=N/A
+ACS_NullPanel=No property
+# {0} - bean
+ACSD_NullPanel=No property. Bean: {0}
+# {0} - property name
+# {1} - property value
+ACS_PropertyPanelRenderer={0}: {1}
+# {0} - property description
+# {1} - property type
+# {2} - bean
+ACSD_PropertyPanelRenderer={0} Type: {1} Bean: {2}
+CTL_No_value=&lt;No Value&gt;
+CTL_No_type=&lt;No type&gt;
+
+#a11y
+ACSN_TreeTable=N/A
+ACSD_TreeTable=N/A
+
+LBL_QuickFilter=Show only rows where

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/NodePopupFactory.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/NodePopupFactory.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/NodePopupFactory.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,72 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2005 Nokia. All Rights Reserved.
+ */
+package org.netbeans.api.tableview;
+
+import java.awt.Component;
+import javax.swing.Action;
+import javax.swing.JPopupMenu;
+import org.netbeans.swing.etable.ETable;
+import org.openide.nodes.Node;
+import org.openide.nodes.NodeOp;
+import org.openide.util.NbBundle;
+import org.openide.util.Utilities;
+
+/**
+ * Allows customization of the popup menus of TableView and OutlineView.
+ * Just create a subclass of this class and override method createPopupMenu
+ * (and call setNodePopupFactory() on TableView or OutlineView).
+ * @author David Strupl
+ */
+public class NodePopupFactory {
+
+    private boolean showQuickFilter = true;
+    
+    /** Creates a new instance of NodePopupFactory */
+    public NodePopupFactory() {
+    }
+    
+    /**
+     * Creates a popup menu with entries from the selected nodes
+     * related to the given component (usually a ETable subclass). The popup
+     * is created for the table element in given column and row (column
+     *  and row are in the view's coordinates (not the model's)).
+     */
+    public JPopupMenu createPopupMenu(int row, int column, Node[] selectedNodes,
+            Component component) {
+        
+        Action[] actions = NodeOp.findActions (selectedNodes);
+        JPopupMenu res = Utilities.actionsToPopup(actions, component);
+        if (showQuickFilter) {
+            if (component instanceof ETable) {
+                ETable et = (ETable)component;
+                Object val = et.getValueAt(row, column);
+                val = et.transformValue(val);
+                String s = NbBundle.getBundle(NodePopupFactory.class).getString(&quot;LBL_QuickFilter&quot;);
+                res.add(et.getQuickFilterPopup(column, val, s));
+            }
+        }
+        return res;
+    }
+
+    /**
+     * 
+     */
+    public void setShowQuickFilter(boolean show) {
+        this.showQuickFilter = show;
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/NodeRenderDataProvider.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/NodeRenderDataProvider.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/NodeRenderDataProvider.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,100 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2004 Nokia. All Rights Reserved.
+ */
+package org.netbeans.api.tableview;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import javax.swing.ImageIcon;
+import javax.swing.JTable;
+import javax.swing.tree.AbstractLayoutCache;
+import javax.swing.tree.TreeNode;
+import javax.swing.tree.TreePath;
+import org.netbeans.swing.outline.Outline;
+import org.netbeans.swing.outline.RenderDataProvider;
+import org.openide.explorer.view.Visualizer;
+import org.openide.nodes.Node;
+
+/**
+ *
+ * @author David Strupl
+ */
+class NodeRenderDataProvider implements RenderDataProvider {
+
+    private JTable table;
+
+    /** Creates a new instance of NodeRenderDataProvider */
+    public NodeRenderDataProvider(JTable table) {
+        this.table = table;
+    }
+
+    public java.awt.Color getBackground(Object o) {
+        return table.getBackground();
+    }
+
+    public String getDisplayName(Object o) {
+        Node n = Visualizer.findNode(o);
+        if (n == null) {
+            throw new IllegalStateException(&quot;TreeNode must be VisualizerNode but was: &quot; + o + &quot; of class &quot; + o.getClass().getName());
+        }
+        return n.getDisplayName();
+    }
+
+    public java.awt.Color getForeground(Object o) {
+        return table.getForeground();
+    }
+
+    public javax.swing.Icon getIcon(Object o) {
+        Node n = Visualizer.findNode(o);
+        if (n == null) {
+            throw new IllegalStateException(&quot;TreeNode must be VisualizerNode but was: &quot; + o + &quot; of class &quot; + o.getClass().getName());
+        }
+        boolean expanded = false;
+        if (o instanceof TreeNode) {
+            TreeNode tn = (TreeNode)o;
+            ArrayList al = new ArrayList();
+            while (tn != null) {
+                al.add(tn);
+                tn = tn.getParent();
+            }
+            Collections.reverse(al);
+            TreePath tp = new TreePath(al.toArray());
+            AbstractLayoutCache layout = ((Outline)table).getLayoutCache();
+            expanded = layout.isExpanded(tp);
+        }
+        java.awt.Image image = null;
+        if (expanded) {
+            image = n.getOpenedIcon(java.beans.BeanInfo.ICON_COLOR_16x16);
+        } else {
+            image = n.getIcon(java.beans.BeanInfo.ICON_COLOR_16x16);
+        }
+        return new ImageIcon(image);
+    }
+
+    public String getTooltipText(Object o) {
+        Node n = Visualizer.findNode(o);
+        if (n == null) {
+            throw new IllegalStateException(&quot;TreeNode must be VisualizerNode but was: &quot; + o + &quot; of class &quot; + o.getClass().getName());
+        }
+        return n.getShortDescription();
+    }
+
+    public boolean isHtmlDisplayName(Object o) {
+        return false;
+    }
+    
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/NodeTableModel.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/NodeTableModel.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/NodeTableModel.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,292 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is NetBeans. The Initial Developer of the Original
+ * Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+ * Microsystems, Inc. All Rights Reserved.
+ */
+
+package org.netbeans.api.tableview;
+
+import java.beans.PropertyChangeListener;
+import java.beans.PropertyChangeEvent;
+import java.util.Arrays;
+import java.util.List;
+import javax.swing.table.AbstractTableModel;
+import javax.swing.*;
+import java.awt.event.*;
+import java.util.ArrayList;
+import java.util.TreeMap;
+import java.util.Iterator;
+
+import org.openide.nodes.Node;
+import org.openide.nodes.Node.Property;
+import org.openide.DialogDescriptor;
+import org.openide.DialogDisplayer;
+import org.openide.util.NbBundle;
+
+/**
+* Table model with properties (&lt;code&gt;Node.Property&lt;/code&gt;) as columns and nodes (&lt;code&gt;Node&lt;/code&gt;) as rows.
+* It is used as model for displaying node properties in table. Each column is represented by
+* &lt;code&gt;Node.Property&lt;/code&gt; object. Each row is represented by &lt;code&gt;Node&lt;/code&gt; object.
+* Each cell contains &lt;code&gt;Node.Property&lt;/code&gt; property which equals with column object
+* and should be in property sets of row representant (&lt;code&gt;Node&lt;/code&gt;).
+*
+* @author David Strupl
+*/
+public class NodeTableModel extends AbstractTableModel {
+
+    /**
+     * Boolean attribute of Node.Property that can determine whether
+     * the column for the property will be sortable.
+     */
+    public static final String ATTR_SORTABLE_COLUMN = &quot;SortableColumn&quot;; // NOI18N
+    
+    /** all columns of model */
+    private Node.Property[] allPropertyColumns = new Node.Property[0];
+    /** rows of model */
+    private List/*&lt;Node&gt;*/ nodeRows = new ArrayList();
+    
+    /** listener on node properties changes, recreates displayed data */
+    private PropertyChangeListener pcl = new PropertyChangeListener() {
+        public void propertyChange(PropertyChangeEvent evt) {
+            //fireTableDataChanged();
+            int row = rowForNode((Node)evt.getSource());
+            if (row == -1) {
+                return;
+            }
+
+            int column = columnForProperty(evt.getPropertyName());
+            if (column == -1) {
+                fireTableRowsUpdated(row, row);
+            } else {
+                fireTableCellUpdated(row, column);
+            }
+        }
+    };
+    
+    /**
+     *
+     */
+    private int columnForProperty(String propName) {
+        for (int i = 0; i &lt; allPropertyColumns.length; i++) {
+            if (allPropertyColumns[i].getName().equals(propName))
+                return i;
+        }
+        return -1;
+    }
+    
+    /** Set rows.
+     * @param nodes the rows
+     */
+    public void setNodes(Node[] nodes) {
+        for (Iterator i = nodeRows.iterator(); i.hasNext(); ) {
+            Node n = (Node)i.next();
+            n.removePropertyChangeListener(pcl);
+        }
+        nodeRows = new ArrayList(Arrays.asList(nodes));
+        for (Iterator i = nodeRows.iterator(); i.hasNext(); ) {
+            Node n = (Node)i.next();
+            n.addPropertyChangeListener(pcl);
+        }
+        fireTableDataChanged();
+    }
+    
+    /**
+     * The passed in list can be mutable but you &lt;strong&gt;must&lt;/strong&gt; call
+     * fireTableDataChanged(...) after you do any changes in the list otherwise
+     * the view will not be updated.
+     */
+    public void setNodes(List/*&lt;Node&gt;*/ list) {
+        for (Iterator i = nodeRows.iterator(); i.hasNext(); ) {
+            Node n = (Node)i.next();
+            n.removePropertyChangeListener(pcl);
+        }
+        for (Iterator i = list.iterator(); i.hasNext(); ) {
+            Object o = i.next();
+            if (o == null) {
+                throw new IllegalArgumentException(&quot;Null value not allowed here!&quot;);
+            }
+            if (! (o instanceof Node)) {
+                throw new IllegalArgumentException(&quot;The list must contain Nodes but contained: &quot; + o + &quot; of class &quot; + o.getClass().getName());
+            }
+            Node n = (Node)o;
+            n.addPropertyChangeListener(pcl);
+        }
+        // ok - replace it:
+        nodeRows = list;
+        fireTableDataChanged();
+    }
+
+    /**
+     * Adds the given nodes to the end of the list.
+     */
+    public void appendNodes(Node[] nodes) {
+        for (int i = 0; i &lt; nodes.length; i++) {
+            nodes[i].addPropertyChangeListener(pcl);
+        }
+        nodeRows.addAll(Arrays.asList(nodes));
+        fireTableRowsInserted(nodeRows.size() - nodes.length, nodeRows.size());
+    }
+    
+    /**
+     * Deletes several rows (nodes).
+     */
+    public void deleteNodes(int first, int count) {
+        if ((first &lt; 0) || (count &lt; 0)) {
+            throw new IllegalArgumentException();
+        }
+        if (nodeRows.size() &lt; first+count) {
+            throw new IllegalArgumentException();
+        }
+        for (int i = first; i &lt; first + count; i++) {
+            Node n = (Node)nodeRows.get(first);
+            n.removePropertyChangeListener(pcl);
+            nodeRows.remove(first);
+        }
+        fireTableRowsDeleted(first, first+count-1);
+    }
+    
+    /**
+     * Inserts several rows (nodes).
+     */ 
+    public void insertNodes(int index, Node[] nodes) {
+        if ((index &lt; 0) || (index &gt;= nodeRows.size())) {
+            throw new IllegalArgumentException();
+        }
+        if (nodes.length == 0) {
+            return;
+        }
+        for (int i = 0; i &lt; nodes.length; i++) {
+            nodes[i].addPropertyChangeListener(pcl);
+            nodeRows.add(index + i, nodes[i]);
+        }
+        fireTableRowsInserted(index, index + nodes.length-1);
+    }
+    
+    /** Set columns.
+     * @param props the columns
+     */
+    public void setProperties(Property[] props) {
+        allPropertyColumns = props;
+        fireTableStructureChanged();
+    }
+    
+    /* If true, column property should be comparable - allows sorting
+     */
+    boolean isComparableColumn(int column) {
+        Property p = allPropertyColumns[column];
+        Object o = p.getValue(ATTR_SORTABLE_COLUMN);
+        if (o != null &amp;&amp; o instanceof Boolean) {
+            return ((Boolean)o).booleanValue();
+        }
+        return true;
+    }
+    
+    /** Returns node property if found in nodes property sets.
+     * @param node represents single row
+     * @param prop represents column
+     * @return nodes property
+     */
+    static Property getPropertyFor(Node node, Property prop) {
+        Node.PropertySet[] propSets = node.getPropertySets();
+        for (int i = 0; i &lt; propSets.length; i++) {
+            Node.Property[] props = propSets[i].getProperties();
+            for (int j = 0; j &lt; props.length; j++) {
+                if (prop.equals(props[j]))
+                    return props[j];
+            }
+        }
+        return null;
+    }
+    
+    /**
+     * 
+     */
+    public Node nodeForRow(int row) {
+        return (Node)nodeRows.get(row);
+    }
+    
+    /** Helper method to ask for a property representant of column.
+     */
+    public Property propertyForColumn(int column) {
+        return allPropertyColumns[column];
+    }
+
+    /**
+     * Not terribly efficient method for what it does ;-(
+     */
+    private int rowForNode(Node node) {
+        int i = 0; 
+        for (Iterator it = nodeRows.iterator(); it.hasNext(); i++) {
+            Node n = (Node)it.next();
+            if (node.equals(n)) {
+                return i;
+            }
+        }
+        return -1;
+    }
+    
+    //
+    // TableModel methods
+    //
+    
+    /** Getter for row count.
+     * @return row count
+     */
+    public int getRowCount() {
+        return nodeRows.size();
+    }
+
+    /** Getter for column count.
+     * @return column count
+     */
+    public int getColumnCount() {
+        return allPropertyColumns.length;
+    }
+
+    /** Getter for property.
+     * @param row table row index
+     * @param column table column index
+     * @return property at (row, column)
+     */
+    public Object getValueAt(int row, int column) {
+        return getPropertyFor((Node)nodeRows.get(row), allPropertyColumns[column]);
+    }
+
+    /** Cell is editable only if it has non null value.
+     * @param row table row index
+     * @param column table column index
+     * @return true if cell contains non null value
+     */
+    public boolean isCellEditable(int row, int column) {
+        return getValueAt(row, column) != null;
+    }
+
+    /** Getter for column class.
+     * @param column table column index
+     * @return  &lt;code&gt;Node.Property.class&lt;/code&gt;
+     */
+    public Class getColumnClass(int column) {
+        return Node.Property.class;
+    }
+
+    /** Getter for column name
+     * @param column table column index
+     * @return display name of property which represents column
+     */
+    public String getColumnName(int column) {
+        return allPropertyColumns[column].getDisplayName();
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/OutlineView.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/OutlineView.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/OutlineView.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,636 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2005 Nokia. All Rights Reserved.
+ */
+package org.netbeans.api.tableview;
+
+import java.awt.Component;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.MouseEvent;
+import java.beans.PropertyChangeListener;
+import java.beans.PropertyVetoException;
+import java.beans.VetoableChangeListener;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.text.MessageFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.EventObject;
+import java.util.Properties;
+import javax.swing.Action;
+import javax.swing.JMenuItem;
+import javax.swing.JPopupMenu;
+import javax.swing.JScrollPane;
+import javax.swing.JTable;
+import javax.swing.JViewport;
+import javax.swing.ListSelectionModel;
+import javax.swing.SwingUtilities;
+import javax.swing.event.ListSelectionListener;
+import javax.swing.event.PopupMenuEvent;
+import javax.swing.event.PopupMenuListener;
+import javax.swing.table.TableCellEditor;
+import javax.swing.table.TableCellRenderer;
+import javax.swing.table.TableColumn;
+import javax.swing.table.TableModel;
+import javax.swing.tree.AbstractLayoutCache;
+import javax.swing.tree.TreeModel;
+import javax.swing.tree.TreeNode;
+import javax.swing.tree.TreePath;
+import org.netbeans.swing.etable.ETable;
+import org.netbeans.swing.etable.ETableColumn;
+import org.netbeans.swing.etable.QuickFilter;
+import org.netbeans.swing.outline.DefaultOutlineModel;
+import org.netbeans.swing.outline.Outline;
+import org.netbeans.swing.outline.OutlineModel;
+import org.netbeans.swing.outline.RowModel;
+import org.openide.ErrorManager;
+import org.openide.awt.MouseUtils;
+import org.openide.explorer.ExplorerManager;
+import org.openide.explorer.view.NodeTreeModel;
+import org.openide.explorer.view.Visualizer;
+import org.openide.nodes.Node;
+import org.openide.nodes.NodeOp;
+import org.openide.util.NbBundle;
+import org.openide.util.Utilities;
+import org.openide.util.WeakListeners;
+
+/**
+ * Explorer view displaying nodes in a tree table.
+ * @author David Strupl
+ */
+public class OutlineView extends JScrollPane {
+
+    /** The table */
+    private Outline outline;
+    /** Explorer manager, valid when this view is showing */
+    private ExplorerManager manager;
+    /** not null if popup menu enabled */
+    private PopupAdapter popupListener;
+    /** the most important listener (on four types of events */
+    private TableSelectionListener managerListener = null;
+    /** weak variation of the listener for property change on the explorer manager */
+    private PropertyChangeListener wlpc;
+    /** weak variation of the listener for vetoable change on the explorer manager */
+    private VetoableChangeListener wlvc;
+    
+    private OutlineModel model;
+    private NodeTreeModel treeModel;
+    private PropertiesRowModel rowModel;
+    /** */
+    private NodePopupFactory popupFactory;
+
+    /** Creates a new instance of TableView */
+    public OutlineView() {
+        this(null);
+    }    
+    
+    /** Creates a new instance of TableView */
+    public OutlineView(String nodesColumnLabel) {
+        treeModel = new NodeTreeModel();
+        rowModel = new PropertiesRowModel();
+        model = createOutlineModel(treeModel, rowModel, nodesColumnLabel);
+        outline = new OutlineViewOutline(model);
+        rowModel.setOutline(outline);
+        outline.setRenderDataProvider(new NodeRenderDataProvider(outline));
+        SheetCell tableCell = new SheetCell.OutlineSheetCell(outline);
+        outline.setDefaultRenderer(Node.Property.class, tableCell);
+        outline.setDefaultEditor(Node.Property.class, tableCell);
+        setViewportView(outline);
+        setPopupAllowed(true);
+        // do not care about focus
+        setRequestFocusEnabled (false);
+        outline.setRequestFocusEnabled(true);
+        java.awt.Color c = javax.swing.UIManager.getColor(&quot;Table.background1&quot;);
+        if (c == null) {
+            c = javax.swing.UIManager.getColor(&quot;Table.background&quot;);
+        }
+        if (c != null) {
+            getViewport().setBackground(c);
+        }
+        getActionMap().put(&quot;org.openide.actions.PopupAction&quot;, new PopupAction());
+        popupFactory = new OutlinePopupFactory();
+    }
+
+    /**
+     * This method allows plugging own OutlineModel to the OutlineView.
+     * You can override it and create different model in the subclass.
+     */
+    protected OutlineModel createOutlineModel(TreeModel treeModel, RowModel rowModel, String label) {
+        return DefaultOutlineModel.createOutlineModel(treeModel, rowModel, false, label);
+    }
+    
+    /** Requests focus for the tree component. Overrides superclass method. */
+    public void requestFocus () {
+        outline.requestFocus();
+    }
+    
+    /** Requests focus for the tree component. Overrides superclass method. */
+    public boolean requestFocusInWindow () {
+        return outline.requestFocusInWindow();
+    }
+    
+    /**
+     * Getter for the embeded table component.
+     */
+    public Outline getOutline() {
+        return outline;
+    }
+    
+    /** Is it permitted to display a popup menu?
+     * @return &lt;code&gt;true&lt;/code&gt; if so
+     */
+    public boolean isPopupAllowed () {
+        return popupListener != null;
+    }
+
+    public void setProperties(Node.Property[] newProperties) {
+        rowModel.setProperties(newProperties);
+        outline.tableChanged(null);
+    }
+    
+    /** Enable/disable displaying popup menus on tree view items.
+    * Default is enabled.
+    * @param value &lt;code&gt;true&lt;/code&gt; to enable
+    */
+    public void setPopupAllowed (boolean value) {
+        if (popupListener == null &amp;&amp; value) {
+            // on
+            popupListener = new PopupAdapter ();
+            outline.addMouseListener (popupListener);
+            return;
+        }
+        if (popupListener != null &amp;&amp; !value) {
+            // off
+            outline.removeMouseListener (popupListener);
+            popupListener = null;
+            return;
+        }
+    }
+    
+    /** Initializes the component and lookup explorer manager.
+     */
+    public void addNotify () {
+        super.addNotify ();
+        lookupExplorerManager ();
+    }
+    
+    /**
+     * Method allowing to read stored values.
+     * The stored values should be only those that the user has customized,
+     * it does not make sense to store the values that were set using 
+     * the initialization code because the initialization code can be run
+     * in the same way after restart.
+     */
+    public void readSettings(Properties p, String propertyPrefix) {
+        outline.readSettings(p, propertyPrefix);
+    }
+
+    /**
+     * Method allowing to store customization values.
+     * The stored values should be only those that the user has customized,
+     * it does not make sense to store the values that were set using 
+     * the initialization code because the initialization code can be run
+     * in the same way after restart.
+     */
+    public void writeSettings(Properties p, String propertyPrefix) {
+        outline.writeSettings(p, propertyPrefix);
+    }
+
+    /**
+     * Allows customization of the popup menus.
+     */
+    public void setNodePopupFactory(NodePopupFactory newFactory) {
+        popupFactory = newFactory;
+    }
+    
+    /**
+     * Getter for the current popup customizer factory.
+     */
+    public NodePopupFactory getNodePopupFactory() {
+        return popupFactory;
+    }
+    
+    /** Registers in the tree of components.
+     */
+    private void lookupExplorerManager () {
+        // Enter key in the tree
+
+        if (managerListener == null) {
+            managerListener = new TableSelectionListener();
+        }
+        
+        ExplorerManager newManager = ExplorerManager.find(this);
+        if (newManager != manager) {
+            if (manager != null) {
+                manager.removeVetoableChangeListener (wlvc);
+                manager.removePropertyChangeListener (wlpc);
+            }
+
+            manager = newManager;
+
+            manager.addVetoableChangeListener(wlvc = WeakListeners.vetoableChange(managerListener, manager));
+            manager.addPropertyChangeListener(wlpc = WeakListeners.propertyChange(managerListener, manager));
+        }
+        
+        synchronizeRootContext();
+        synchronizeSelectedNodes(true);
+        
+        // Sometimes the listener is registered twice and we get the 
+        // selection events twice. Removing the listener before adding it
+        // should be a safe fix.
+        outline.getSelectionModel().removeListSelectionListener(managerListener);
+        outline.getSelectionModel().addListSelectionListener(managerListener);
+    }
+    
+    /** Synchronize the root context from the manager of this Explorer.
+    */
+    final void synchronizeRootContext() {
+        treeModel.setNode(manager.getRootContext());
+    }
+
+    /** Synchronize the selected nodes from the manager of this Explorer.
+     */
+    final void synchronizeSelectedNodes(boolean scroll) {
+        expandSelection();
+        outline.invalidate();
+        invalidate();
+        validate();
+        Node[] arr = manager.getSelectedNodes ();
+        outline.getSelectionModel().clearSelection();
+        int size = outline.getRowCount();
+        int firstSelection = -1;
+        for (int i = 0; i &lt; size; i++) {
+            Node n = getNodeFromRow(i);
+            for (int j = 0; j &lt; arr.length; j++) {
+                if ((n != null) &amp;&amp; (n.equals(arr[j]))) {
+                    outline.getSelectionModel().addSelectionInterval(i, i);
+                    if (firstSelection == -1) {
+                        firstSelection = i;
+                    }
+                }
+            }
+        }
+        if (scroll &amp;&amp; (firstSelection &gt;= 0)) {
+            JViewport v = getViewport();
+            if (v != null) {
+                Rectangle rect = outline.getCellRect(firstSelection, 0, true);
+                if (v.getExtentSize().height &gt; rect.height) {
+                    rect.height = v.getExtentSize().height;
+                }
+                int ho = outline.getSize().height;
+                if (ho &gt; 0) {
+                    if (rect.y + rect.height &gt; ho) {
+                        rect.height = ho - rect.y;
+                        if (rect.height &lt;= 0) {
+                            rect.height = 40;
+                        }
+                    }
+                }
+                v.setViewPosition(new Point()); // strange line - but without
+                                                // it the next one is wrong
+                outline.scrollRectToVisible(rect);
+            }
+        }
+    }
+
+    /**
+     * Tries to expand nodes selected in the explorer manager.
+     */
+    private void expandSelection() {
+        Node[] arr = manager.getSelectedNodes ();
+        for (int i = 0; i &lt; arr.length; i++) {
+            if ( (arr[i].getParentNode() == null) &amp;&amp; (! outline.isRootVisible())) {
+                // don't try to show root if it is invisible
+                continue;
+            }
+            TreeNode tn = Visualizer.findVisualizer(arr[i]);
+            if (tn != null) {
+                ArrayList al = new ArrayList();
+                while (tn != null) {
+                    al.add(tn);
+                    tn = tn.getParent();
+                }
+                Collections.reverse(al);
+                TreePath tp = new TreePath(al.toArray());
+                while ((tp != null) &amp;&amp; (tp.getPathCount() &gt; 0)) {
+                    tp = tp.getParentPath();
+                    if (tp != null) {
+                        outline.expandPath(tp);
+                    }
+                }
+            }
+        }
+    }
+    
+    /**
+     * Deinitializes listeners.
+     */
+    public void removeNotify () {
+        super.removeNotify ();
+        outline.getSelectionModel().removeListSelectionListener(managerListener);
+        manager.removePropertyChangeListener (wlpc);
+        manager.removeVetoableChangeListener (wlvc);
+    }
+
+    /**
+     * Shows popup menu invoked on the table.
+     */
+    void showPopup(int xpos, int ypos, final JPopupMenu popup) {
+        if ((popup != null) &amp;&amp; (popup.getSubElements().length &gt; 0)) {
+            final PopupMenuListener p = new PopupMenuListener() {
+                public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
+                    
+                }
+                public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
+                    popup.removePopupMenuListener(this);
+                    outline.requestFocus();
+                }
+                public void popupMenuCanceled(PopupMenuEvent e) {
+                    
+                }
+            };
+            popup.addPopupMenuListener(p);
+            popup.show(this, xpos, ypos);
+        }
+    }    
+    
+    /**
+     * Find relevant actions and call the factory to create a popup.
+     */
+    private JPopupMenu createPopup(Point p) {
+        int[] selRows = outline.getSelectedRows();
+        ArrayList al = new ArrayList(selRows.length);
+        for (int i = 0; i &lt; selRows.length; i++) {
+            Node n = getNodeFromRow(selRows[i]);
+            if (n != null) {
+                al.add(n);
+            }
+        }
+        Node[] arr = (Node[])al.toArray(new Node[al.size()]);
+        p = SwingUtilities.convertPoint(this, p, outline);
+        int column = outline.columnAtPoint(p);
+        int row = outline.rowAtPoint(p);
+        return popupFactory.createPopupMenu(row, column, arr, outline);
+    }
+    
+    /**
+     * 
+     */
+    private Node getNodeFromRow(int rowIndex) {
+        int row = outline.convertRowIndexToModel(rowIndex);
+        TreePath tp = outline.getLayoutCache().getPathForRow(row);
+        if (tp == null) {
+            return null;
+        }
+        return Visualizer.findNode(tp.getLastPathComponent());
+    }
+    
+    /** Returns the point at which the popup menu is to be shown. May return null.
+     * @return the point or null
+     */    
+    private Point getPositionForPopup () {
+        int i = outline.getSelectionModel().getLeadSelectionIndex();
+        if (i &lt; 0) return null;
+        int j = outline.getColumnModel().getSelectionModel().getLeadSelectionIndex();
+        if (j &lt; 0) {
+            j = 0;
+        }
+
+        Rectangle rect = outline.getCellRect(i, j, true);
+        if (rect == null) return null;
+
+        Point p = new Point(rect.x + rect.width / 3,
+                rect.y + rect.height / 2);
+        
+        // bugfix #36984, convert point by TableView.this
+        p =  SwingUtilities.convertPoint (outline, p, OutlineView.this);
+
+        return p;
+    }
+
+    /**
+     * Action registered in the component's action map.
+     */
+    private class PopupAction extends javax.swing.AbstractAction implements Runnable {
+        public void actionPerformed(ActionEvent evt) {
+            SwingUtilities.invokeLater(this);
+        }
+        public void run() {
+            Point p = getPositionForPopup ();
+            if (p == null) {
+                return ;
+            }
+            if (isPopupAllowed()) {
+                JPopupMenu pop = createPopup(p);
+                showPopup(p.x, p.y, pop);
+            }
+        }
+    };
+    
+    /**
+     * Mouse listener that invokes popup.
+     */
+    private class PopupAdapter extends MouseUtils.PopupMouseAdapter {
+
+	PopupAdapter() {}
+	
+        protected void showPopup (MouseEvent e) {
+            int selRow = outline.rowAtPoint(e.getPoint());
+
+            if (selRow != -1) {
+                if (! outline.getSelectionModel().isSelectedIndex(selRow)) {
+                    outline.getSelectionModel().clearSelection();
+                    outline.getSelectionModel().setSelectionInterval(selRow, selRow);
+                }
+                Point p = SwingUtilities.convertPoint(e.getComponent(), e.getPoint(), OutlineView.this);
+                if (isPopupAllowed()) {
+                    JPopupMenu pop = createPopup(p);
+                    OutlineView.this.showPopup(p.x, p.y, pop);
+                    e.consume();
+                }
+            } 
+        }
+    }
+
+    /**
+     * Called when selection in tree is changed.
+     */
+    final void callSelectionChanged (Node[] nodes) {
+        manager.removePropertyChangeListener (wlpc);
+        manager.removeVetoableChangeListener (wlvc);
+        try {
+            manager.setSelectedNodes(nodes);
+        } catch (PropertyVetoException e) {
+            synchronizeSelectedNodes(false);
+        } finally {
+            // to be sure not to add them twice!
+            manager.removePropertyChangeListener (wlpc);
+            manager.removeVetoableChangeListener (wlvc);
+            manager.addPropertyChangeListener (wlpc);
+            manager.addVetoableChangeListener (wlvc);
+        }
+    }
+    
+    /** 
+     * Check if selection of the nodes could break
+     * the selection mode set in the ListSelectionModel.
+     * @param nodes the nodes for selection
+     * @return true if the selection mode is broken
+     */
+    private boolean isSelectionModeBroken(Node[] nodes) {
+        
+        // if nodes are empty or single then everthing is ok
+        // or if discontiguous selection then everthing ok
+        if (nodes.length &lt;= 1 || outline.getSelectionModel().getSelectionMode() == 
+                ListSelectionModel.MULTIPLE_INTERVAL_SELECTION) {
+            return false;
+        }
+
+        // if many nodes
+        
+        // breaks single selection mode
+        if (outline.getSelectionModel().getSelectionMode() == 
+            ListSelectionModel.SINGLE_SELECTION) {
+            return true;
+        }
+        
+        // check the contiguous selection mode
+
+        // check selection's rows
+        
+        // all is ok
+        return false;
+    }
+    
+    /**
+     * Listener attached to the explorer manager and also to the
+     * changes in the table selection.
+     */
+    private class TableSelectionListener implements VetoableChangeListener, ListSelectionListener, PropertyChangeListener {
+        public void propertyChange(java.beans.PropertyChangeEvent evt) {
+            if (manager == null) return; // the tree view has been removed before the event got delivered
+            if (evt.getPropertyName().equals(ExplorerManager.PROP_ROOT_CONTEXT)) {
+                synchronizeRootContext();
+            }
+            if (evt.getPropertyName().equals(ExplorerManager.PROP_SELECTED_NODES)) {
+                synchronizeSelectedNodes(true);
+            }
+        }
+
+        public void valueChanged(javax.swing.event.ListSelectionEvent listSelectionEvent) {
+            int selectedRows[] = outline.getSelectedRows();
+            ArrayList selectedNodes = new ArrayList(selectedRows.length);
+            for (int i = 0; i &lt; selectedRows.length;i++) {
+                Node n = getNodeFromRow(selectedRows[i]);
+                if (n != null) {
+                    selectedNodes.add(n);
+                }
+            }
+            callSelectionChanged((Node[])selectedNodes.toArray(new Node[selectedNodes.size()]));
+        }
+
+        public void vetoableChange(java.beans.PropertyChangeEvent evt) throws java.beans.PropertyVetoException {
+            if (evt.getPropertyName().equals(ExplorerManager.PROP_SELECTED_NODES)) {
+                // issue 11928 check if selecetion mode will be broken
+                Node[] nodes = (Node[])evt.getNewValue();
+                if (isSelectionModeBroken(nodes)) {
+                    throw new PropertyVetoException(&quot;selection mode &quot; +  &quot; broken by &quot; + Arrays.asList(nodes), evt); // NOI18N
+                }
+            }
+        }
+        public void run() {
+        }
+    }
+
+    /**
+     * Extension of the ETable that allows adding a special comparator
+     * for sorting the rows.
+     */
+    private static class OutlineViewOutline extends Outline {
+        public OutlineViewOutline(OutlineModel mdl) {
+            super(mdl);
+        }
+        
+        public Object transformValue(Object value) {
+            return PropertiesRowModel.getValueFromProperty(value);
+        }
+        
+        public boolean editCellAt(int row, int column, EventObject e) {
+            Object o = getValueAt(row, column);
+            if (o instanceof Node.Property) { // &amp;&amp; (e == null || e instanceof KeyEvent)) {
+                Node.Property p = (Node.Property)o;
+                if (p.getValueType() == Boolean.class || p.getValueType() == Boolean.TYPE) {
+                    PropertiesRowModel.toggleBooleanProperty(p);
+                    Rectangle r = getCellRect(row, column, true);
+                    repaint (r.x, r.y, r.width, r.height);
+                    return false;
+                }
+            }
+            return super.editCellAt(row, column, e);
+        }
+        
+        protected TableColumn createColumn(int modelIndex) {
+            return new OutlineViewOutlineColumn(modelIndex);
+        }
+        /**
+         * Extension of ETableColumn using TableViewRowComparator as
+         * comparator.
+         */
+        private class OutlineViewOutlineColumn extends OutlineColumn {
+            public OutlineViewOutlineColumn(int index) {
+                super(index);
+            }
+            protected Comparator getRowComparator(int column, boolean ascending) {
+                  return new OutlineRowComparator(column, ascending);
+            }
+            public boolean isSortingAllowed() {
+                boolean res = super.isSortingAllowed();
+                TableModel model = getModel();
+                if (model.getRowCount() &lt;= 0) {
+                    return res;
+                }
+                Object sampleValue = model.getValueAt(0, getModelIndex());
+                if (sampleValue instanceof Node.Property) {
+                    Node.Property prop = (Node.Property)sampleValue;
+                    Object sortableColumnProperty = prop.getValue(&quot;SortableColumn&quot;);
+                    if (sortableColumnProperty instanceof Boolean) {
+                        return ((Boolean)sortableColumnProperty).booleanValue();
+                    }
+                }
+                return res;
+            }
+        }
+    }
+    
+    private static class OutlinePopupFactory extends NodePopupFactory {
+        public OutlinePopupFactory() {
+        }
+
+        public JPopupMenu createPopupMenu(int row, int column, Node[] selectedNodes, Component component) {
+            if (component instanceof ETable) {
+                ETable et = (ETable)component;
+                int modelRowIndex = et.convertColumnIndexToModel(column);
+                setShowQuickFilter(modelRowIndex != 0);
+            }
+            return super.createPopupMenu(row, column, selectedNodes, component);
+        }
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/PropertiesRowModel.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/PropertiesRowModel.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/PropertiesRowModel.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,194 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2005 Nokia. All Rights Reserved.
+ */
+package org.netbeans.api.tableview;
+
+import java.beans.PropertyChangeEvent;
+import java.beans.PropertyChangeListener;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.WeakHashMap;
+import javax.swing.event.TableModelEvent;
+import javax.swing.tree.TreeNode;
+import javax.swing.tree.TreePath;
+import org.netbeans.swing.outline.Outline;
+import org.netbeans.swing.outline.RowModel;
+import org.openide.ErrorManager;
+import org.openide.explorer.view.Visualizer;
+import org.openide.nodes.Node;
+import org.openide.util.WeakListeners;
+
+/**
+ *
+ * @author David Strupl
+ */
+class PropertiesRowModel implements RowModel {
+   
+    private Node.Property[] prop = new Node.Property[0];
+    private Outline outline;
+    private WeakHashMap/*&lt;Node, PropertyChangeListener&gt;*/ nodesListenersCache = new WeakHashMap();
+    
+    /** listener on node properties changes, recreates displayed data */
+    private PropertyChangeListener pcl = new PropertyChangeListener() {
+        public void propertyChange(PropertyChangeEvent evt) {
+            //fireTableDataChanged();
+            int row = rowForNode((Node)evt.getSource());
+            if (row == -1) {
+                return;
+            }
+
+            int column = columnForProperty(evt.getPropertyName());
+            if (column == -1) {
+                outline.tableChanged(new TableModelEvent(outline.getModel(), row, row,
+                             TableModelEvent.ALL_COLUMNS, TableModelEvent.UPDATE));
+            } else {
+                outline.tableChanged(new TableModelEvent(outline.getModel(), row, row,
+                             column+1, TableModelEvent.UPDATE));
+            }
+        }
+    };
+    
+    /** Creates a new instance of PropertiesRowModel */
+    public PropertiesRowModel() {
+        
+    }
+    
+    public void setOutline(Outline outline) {
+        this.outline = outline;
+    }
+    
+    private int rowForNode(Node n) {
+        TreeNode tn = Visualizer.findVisualizer(n);
+        if (tn != null) {
+            ArrayList al = new ArrayList();
+            while (tn != null) {
+                al.add(tn);
+                tn = tn.getParent();
+            }
+            Collections.reverse(al);
+            TreePath tp = new TreePath(al.toArray());
+            int row = outline.getLayoutCache().getRowForPath(tp);
+            return row;
+        }
+        return -1;
+    }
+
+    public Class getColumnClass(int column) {
+        return Node.Property.class;
+    }
+
+    public int getColumnCount() {
+        return prop.length;
+    }
+
+    public String getColumnName(int column) {
+        return prop[column].getDisplayName();
+    }
+
+    public Object getValueFor(Object node, int column) {
+        Node n = Visualizer.findNode(node);
+        if (n == null) {
+            throw new IllegalStateException(&quot;TreeNode must be VisualizerNode but was: &quot; + node + &quot; of class &quot; + node.getClass().getName());
+        }
+        PropertyChangeListener cacheEntry = (PropertyChangeListener)nodesListenersCache.get(n);
+        if (cacheEntry == null) {
+            PropertyChangeListener p = WeakListeners.propertyChange(pcl, n);
+            nodesListenersCache.put(n, p);
+            n.addPropertyChangeListener(p);
+        }
+        Node.Property theRealProperty = NodeTableModel.getPropertyFor(n, prop[column]);
+        return theRealProperty;
+    }
+
+    public boolean isCellEditable(Object node, int column) {
+        Node n = Visualizer.findNode(node);
+        if (n == null) {
+            throw new IllegalStateException(&quot;TreeNode must be VisualizerNode but was: &quot; + node + &quot; of class &quot; + node.getClass().getName());
+        }
+        Node.Property theRealProperty = NodeTableModel.getPropertyFor(n, prop[column]);
+        if (theRealProperty != null) {
+            return theRealProperty.canWrite();
+        } else {
+            return false;
+        }
+    }
+
+    public void setValueFor(Object node, int column, Object value) {
+        // Intentionally left empty. The cell editor components are
+        // PropertyPanels that will propagate the change into the target
+        // property object - no need to do anything in this method.
+    }
+    
+    public void setProperties(Node.Property[] newProperties) {
+        prop = newProperties;
+    }
+    
+    /**
+     * Of the parameter is of type Node.Property this methods
+     * calls getValue on the property and returns the value.
+     * If the parameter is something else &lt;code&gt;null&lt;/code&gt;
+     * is returned.
+     */
+    public static Object getValueFromProperty(Object property) {
+        if (property instanceof Node.Property) {
+            Node.Property prop = (Node.Property)property;
+            try {
+                return prop.getValue();
+            } catch (Exception x) {
+                ErrorManager.getDefault().getInstance(
+                    PropertiesRowModel.class.getName()).notify(
+                        ErrorManager.INFORMATIONAL, x);
+            }
+        }
+        return null;
+    }
+    /**
+     * Search the properties for given property name.
+     * The returned value is the index of property: you
+     * have to add 1 to make it the column index because the
+     * column with index 0 is reserved for the tree!
+     */
+    private int columnForProperty(String propName) {
+        for (int i = 0; i &lt; prop.length; i++) {
+            if (prop[i].getName().equals(propName))
+                return i;
+        }
+        return -1;
+    }
+
+    /**
+     * Changes the value of the boolean property.
+     */
+    public static void toggleBooleanProperty(Node.Property p) {
+        if (p.getValueType() == Boolean.class || p.getValueType() == Boolean.TYPE) {
+            if (!p.canWrite()) {
+                return;
+            }
+            try {
+                Boolean val = (Boolean) p.getValue();
+                if (Boolean.FALSE.equals(val)) {
+                    p.setValue(Boolean.TRUE);
+                } else {
+                    //This covers null multi-selections too
+                    p.setValue(Boolean.FALSE);
+                }
+            } catch (Exception e1) {
+                ErrorManager.getDefault().notify(ErrorManager.WARNING, e1);
+            }
+        }
+    }    
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/SheetCell.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/SheetCell.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/SheetCell.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,694 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is NetBeans. The Initial Developer of the Original
+ * Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+ * Microsystems, Inc. All Rights Reserved.
+ */
+
+package org.netbeans.api.tableview;
+
+import java.awt.Color;
+import java.beans.*;
+import java.util.EventObject;
+import java.text.MessageFormat;
+import java.lang.reflect.InvocationTargetException;
+import java.awt.Graphics;
+import java.awt.Component;
+import java.awt.Container;
+import java.awt.KeyboardFocusManager;
+import java.lang.ref.Reference;
+import java.lang.ref.WeakReference;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+import javax.swing.*;
+import javax.swing.table.*;
+import javax.swing.border.*;
+import javax.swing.event.TableModelEvent;
+import javax.swing.event.TableModelListener;
+import javax.accessibility.AccessibleContext;
+import javax.accessibility.AccessibleRole;
+import javax.swing.table.TableModel;
+import javax.swing.tree.TreeNode;
+import javax.swing.tree.TreePath;
+import org.netbeans.modules.openide.explorer.TTVEnvBridge;
+import org.netbeans.swing.etable.ETable;
+import org.netbeans.swing.outline.Outline;
+
+import org.openide.ErrorManager;
+import org.openide.explorer.view.Visualizer;
+import org.openide.util.Mutex;
+import org.openide.util.NbBundle;
+import org.openide.nodes.Node;
+import org.openide.nodes.Node.Property;
+import org.openide.explorer.propertysheet.*;
+
+/**
+ * TableCellEditor/Renderer implementation. Component returned is the PropertyPanel
+ *
+ * @author Jan Rojcek
+ */
+abstract class SheetCell extends AbstractCellEditor implements TableModelListener, PropertyChangeListener, TableCellEditor, TableCellRenderer {
+
+    /* Determines how to paint renderer */
+    private Boolean flat;
+
+    public SheetCell() {
+        setFlat(false);
+    }
+
+    /**
+     * Set how to paint renderer.
+     * @param f &lt;code&gt;true&lt;/code&gt; means flat, &lt;code&gt;false&lt;/code&gt; means with button border
+     */
+    public void setFlat(boolean f) {
+        
+        Color controlDkShadow = Color.lightGray;
+        if (UIManager.getColor (&quot;controlDkShadow&quot;) != null) controlDkShadow = UIManager.getColor (&quot;controlDkShadow&quot;); // NOI18N
+        Color controlLtHighlight = Color.black;
+        if (UIManager.getColor (&quot;controlLtHighlight&quot;) != null) controlLtHighlight = UIManager.getColor (&quot;controlLtHighlight&quot;); // NOI18N
+        Color buttonFocusColor = Color.blue;
+        if (UIManager.getColor (&quot;Button.focus&quot;) != null) buttonFocusColor = UIManager.getColor (&quot;Button.focus&quot;); // NOI18N
+        
+        flat = f ? Boolean.TRUE : Boolean.FALSE;
+    }
+
+    //
+    // Editor
+    //
+    
+    /** Actually edited node (its property) */
+    private Node node;
+    /** Edited property */
+    private Property prop;
+
+    /** Returns &lt;code&gt;null&lt;code&gt;.
+     * @return &lt;code&gt;null&lt;/code&gt;
+     */        
+    public Object getCellEditorValue() {
+        return null;
+    }
+
+    public abstract Node nodeForRow(int row);
+    
+    /** Returns editor of property.
+     * @param table
+     * @param value
+     * @param isSelected
+     * @param r row
+     * @param c column
+     * @return &lt;code&gt;PropertyPanel&lt;/code&gt;
+     */
+    public Component getTableCellEditorComponent(JTable table,
+                                                 Object value,
+                                                 boolean isSelected,
+                                                 int r, int c) {
+        prop = (Property)value;
+        node = nodeForRow(r);
+        node.addPropertyChangeListener(this);
+        // create property panel
+        PropertyPanel propPanel = getEditor(prop, node);
+
+        propPanel.setBackground(table.getSelectionBackground());
+        propPanel.setForeground(table.getSelectionForeground());
+        //Fix for 35534, text shifts when editing.  Maybe better fix possible
+        //in EditablePropertyDisplayer or InplaceEditorFactory.
+        propPanel.setBorder(BorderFactory.createMatteBorder(0,1,0,0, 
+            table.getSelectionBackground()));
+        return propPanel;
+    }
+
+    /** Cell should not be selected
+     * @param ev event
+     * @return &lt;code&gt;false&lt;/code&gt;
+     */
+    public boolean shouldSelectCell(EventObject ev) {
+        return true;
+    }
+
+    /** Return true.
+     * @param e event
+     * @return &lt;code&gt;true&lt;/code&gt;
+     */
+    public boolean isCellEditable(EventObject e) {
+        return true;
+    }
+
+    /**
+     * Detaches listeners.
+     * Calls &lt;code&gt;fireEditingStopped&lt;/code&gt; and returns true.
+     * @return true
+     */
+    public boolean stopCellEditing() {
+        if (prop != null)
+            detachEditor();
+        return super.stopCellEditing();
+    }
+
+    /**
+     * Detaches listeners.
+     * Calls &lt;code&gt;fireEditingCanceled&lt;/code&gt;.
+     */
+    public void  cancelCellEditing() { 
+        if (prop != null)
+            detachEditor();
+        super.cancelCellEditing();
+    }
+
+    /** Table has changed. If underlied property was switched then cancel editing.
+     * @param e event
+     */
+    public void tableChanged(TableModelEvent e) {
+        cancelCellEditing();
+    }
+
+    /** Removes listeners and frees resources.
+     */
+    protected void detachEditor() {
+        node.removePropertyChangeListener(this);
+        node = null;
+        prop = null;
+    }
+
+    //
+    // Renderer
+    //
+
+    /** Default header renderer */
+    private TableCellRenderer headerRenderer = (new JTableHeader()).getDefaultRenderer();
+
+    /** Null panel is used if cell value is null */
+    private NullPanel nullPanel;
+    /** Two-tier cache for property panels 
+     * Map&lt;TreeNode, WeakHashMap&lt;Node.Property, Reference&lt;FocusedPropertyPanel&gt;&gt; */
+    private Map panelCache = new WeakHashMap(); // weak! #31275
+
+    private FocusedPropertyPanel renderer = null;
+    private FocusedPropertyPanel getRenderer (Property p, Node n) {
+        TTVEnvBridge bridge = TTVEnvBridge.getInstance(this);
+        bridge.setCurrentBeans(new Node[] {n});
+        if (renderer == null) {
+            renderer = new FocusedPropertyPanel(p, PropertyPanel.PREF_READ_ONLY | PropertyPanel.PREF_TABLEUI);
+            renderer.putClientProperty(&quot;beanBridgeIdentifier&quot;, 
+                this); //NOI18N
+        }
+        renderer.setProperty(p);
+        renderer.putClientProperty(&quot;flat&quot;,Boolean.TRUE);
+        return renderer;
+    }
+
+    public abstract String getShortDescription(int column);
+    
+    /** Getter for actual cell renderer.
+     * @param table
+     * @param value
+     * @param isSelected
+     * @param hasFocus
+     * @param row
+     * @param column
+     * @return &lt;code&gt;PropertyPanel&lt;/code&gt;
+     */
+    public Component getTableCellRendererComponent(JTable table,
+                                                   Object value,
+                                                   boolean isSelected,
+                                                   boolean hasFocus,
+                                                   int row, int column) {
+
+        // Header renderer
+        if (row == -1) {
+            Component comp = headerRenderer.getTableCellRendererComponent(
+                table, value, isSelected, hasFocus, row, column);
+            if (comp instanceof JComponent) {
+                String tip = column &gt; 0 ? 
+                    getShortDescription(column) :
+                    table.getColumnName( 0 );
+                ((JComponent) comp).setToolTipText(tip);
+            }
+            return comp;
+        }
+
+        Property prop = (Property)value;
+        Node node = nodeForRow(row);
+
+        if (prop != null) {
+            FocusedPropertyPanel propPanel = getRenderer (prop, node);
+            propPanel.setFocused(hasFocus);
+            propPanel.setToolTipText(prop.getShortDescription());
+            propPanel.setOpaque(true);
+            if (isSelected){
+                
+                Component focusOwner = KeyboardFocusManager.
+                    getCurrentKeyboardFocusManager().getFocusOwner();
+
+                boolean tableHasFocus = table == focusOwner ||
+                    table.isAncestorOf(focusOwner) || 
+                    (focusOwner instanceof Container &amp;&amp; 
+                    ((Container) focusOwner).isAncestorOf(table));
+                
+                if (table == focusOwner &amp;&amp; table.isEditing()) {
+                    //XXX really need to check if the editor has focus
+                    tableHasFocus = true;
+                }
+                
+                propPanel.setBackground(tableHasFocus ? 
+                    table.getSelectionBackground() : 
+                    getNoFocusSelectionBackground());
+                
+                propPanel.setForeground(tableHasFocus ?
+                    table.getSelectionForeground() :
+                    getNoFocusSelectionForeground());
+                
+            } else {
+                propPanel.setBackground(table.getBackground());
+                propPanel.setForeground(table.getForeground());
+            }
+            if (table instanceof ETable) {
+                ETable et = (ETable)table;
+                et.setCellBackground(propPanel, isSelected, row, column);
+            }
+            return propPanel;
+        }
+
+        if (nullPanel == null) {
+            nullPanel = new NullPanel(node);
+            nullPanel.setOpaque(true);
+        } else {
+            nullPanel.setNode(node);
+        }
+
+        if (isSelected) {
+            Component focusOwner = KeyboardFocusManager.
+                getCurrentKeyboardFocusManager().getFocusOwner();
+
+            boolean tableHasFocus = hasFocus || table == focusOwner || 
+                table.isAncestorOf(focusOwner) || 
+                (focusOwner instanceof Container &amp;&amp; 
+                ((Container) focusOwner).isAncestorOf(table));
+            
+            nullPanel.setBackground(hasFocus ? 
+                table.getSelectionBackground() :
+                getNoFocusSelectionBackground()
+            );
+            
+            //XXX may want to handle inverse theme here and use brighter if
+            //below a threshold.  Deferred to centralized color management
+            //being implemented.
+            nullPanel.setForeground(table.getSelectionForeground().darker());
+        } else {
+            nullPanel.setBackground(table.getBackground());
+            nullPanel.setForeground(table.getForeground());
+        }
+
+        if (table instanceof ETable) {
+            ETable et = (ETable)table;
+            et.setCellBackground(nullPanel, isSelected, row, column);
+        }
+        nullPanel.setFocused (hasFocus);
+        return nullPanel;
+    }
+
+    private PropertyPanel editor=null;
+    private PropertyPanel getEditor(Property p, Node n) {
+        int prefs = PropertyPanel.PREF_TABLEUI;
+
+        TTVEnvBridge bridge = TTVEnvBridge.getInstance(this);
+        //workaround for issue 38132 - use env bridge to pass the 
+        //node to propertypanel so it can call PropertyEnv.setBeans()
+        //with it.  The sad thing is almost nobody uses PropertyEnv.getBeans(),
+        //but we have to do it for all cases.
+        bridge.setCurrentBeans(new Node[] {n});
+        
+        if (editor == null) {
+            editor = new PropertyPanel(p, prefs);
+            
+            editor.putClientProperty(&quot;flat&quot;, Boolean.TRUE); //NOI18N
+            editor.putClientProperty(&quot;beanBridgeIdentifier&quot;, 
+                this); //NOI18N
+            
+            //Intentionally set the property again so it will look up the
+            //bean bridge
+            editor.setProperty(p);
+            
+            return editor;
+        }
+        
+        editor.setProperty(p);
+        //Okay, the property panel has already grabbed the beans, clear
+        //them so no references are held.
+        
+        return editor;
+    }
+    
+    private PropertyPanel obtainPanel (Node node, Property prop) {
+        return getEditor(prop, node);
+    }
+    
+    private static class NullPanel extends JPanel {
+        private WeakReference weakNode;
+        
+        NullPanel(Node node) {
+            this.weakNode = new WeakReference(node);
+        }
+        
+        void setNode(Node node) {
+            this.weakNode = new WeakReference(node);
+        }
+
+        public AccessibleContext getAccessibleContext() {
+            if (accessibleContext == null) {
+                accessibleContext = new AccessibleNullPanel();
+            }
+            return accessibleContext;
+        }
+        
+        private boolean focused = false;
+        public void setFocused (boolean val) {
+            focused = val;
+        }
+        
+        public void paintComponent (Graphics g) {
+            super.paintComponent(g);
+            if (focused) {
+                Color bdr = UIManager.getColor(&quot;Tree.selectionBorderColor&quot;); //NOI18N
+                if (bdr == null) {
+                    //Button focus color doesn't work on win classic - better to
+                    //get the color from a value we know will work - Tim
+                    if (getForeground().equals(Color.BLACK)) { //typical
+                        bdr = getBackground().darker();
+                    } else {
+                        bdr = getForeground().darker();
+                    }
+                }
+                g.setColor(bdr);
+                g.drawRect(1, 1, getWidth() - 3, getHeight() - 3);
+                g.setColor (bdr);
+            }
+        }
+        
+        public void addComponentListener (java.awt.event.ComponentListener l) {
+            //do nothing
+        }
+        
+        public void addHierarchyListener (java.awt.event.HierarchyListener l) {
+            //do nothing
+        }
+        
+        public void repaint() {
+            //do nothing
+        }
+        
+        public void repaint (int x, int y, int width, int height) {
+            //do nothing
+        }
+        
+        public void invalidate() {
+            //do nothing
+        }
+        
+        public void revalidate() {
+            //do nothing
+        }
+        
+        public void validate() {
+            //do nothing
+        }
+        
+        public void firePropertyChange (String s, Object a, Object b) {
+            //do nothing
+        }        
+
+        private class AccessibleNullPanel extends AccessibleJPanel {
+            AccessibleNullPanel() {}
+            public String getAccessibleName() {
+                String name = super.getAccessibleName();
+
+                if (name == null) {
+                    name = getString(&quot;ACS_NullPanel&quot;);
+                }
+                return name;
+            }
+
+            public String getAccessibleDescription() {
+                String description = super.getAccessibleDescription();
+
+                if (description == null) {
+                    Node node = (Node)weakNode.get();
+                    if (node != null) {
+                        description = MessageFormat.format(
+                            getString(&quot;ACSD_NullPanel&quot;),
+                            new Object[] {
+                                node.getDisplayName()
+                            }
+                        );
+                    }
+                }
+                return description;
+            }
+        }
+    }
+
+    /** Table cell renderer component. Paints focus border on property panel. */
+    private static class FocusedPropertyPanel extends PropertyPanel {
+        //XXX delete this class when new property panel is committed
+        boolean focused;
+        
+        public FocusedPropertyPanel(Property p, int preferences) {
+            super (p, preferences);
+            setDoubleBuffered(true);
+        }
+        
+        public void setFocused(boolean focused) {
+            this.focused = focused;
+        }
+
+        public void addComponentListener (java.awt.event.ComponentListener l) {
+            //do nothing
+        }
+        
+        public void addHierarchyListener (java.awt.event.HierarchyListener l) {
+            //do nothing
+        }
+        
+        public void repaint(long tm, int x, int y, int width, int height) {
+            //do nothing
+        }
+        
+        public void revalidate() {
+            //do nothing
+        }
+
+        public void firePropertyChange (String s, Object a, Object b) {
+            //do nothing
+            if (&quot;flat&quot;.equals (s)) {
+                super.firePropertyChange(s,a,b);
+            }
+        }
+        
+        public boolean isValid() {
+            return true;
+        }
+        
+        public boolean isShowing() {
+            return true;
+        }
+        
+        public void update(Graphics g) {
+            //do nothing
+        }
+        
+        public void paint(Graphics g) {
+            //do this for self-painting editors in Options window - because
+            //we've turned off most property changes, the background won't be
+            //painted correctly otherwise
+            Color c = getBackground();
+            Color old = g.getColor();
+            g.setColor(c);
+            g.fillRect(0,0,getWidth(),getHeight());
+            g.setColor(old);
+            
+            super.paint(g);
+
+            if (focused) {
+                Color bdr = UIManager.getColor(&quot;Tree.selectionBorderColor&quot;); //NOI18N
+                if (bdr == null) {
+                    //Button focus color doesn't work on win classic - better to
+                    //get the color from a value we know will work - Tim
+                    if (getForeground().equals(Color.BLACK)) { //typical
+                        bdr = getBackground().darker();
+                    } else {
+                        bdr = getForeground().darker();
+                    }
+                }
+                g.setColor(bdr);
+                g.drawRect(1, 1, getWidth() - 3, getHeight() - 3);
+            }
+            g.setColor(old);
+        }
+        
+        ////////////////// Accessibility support ///////////////////////////////
+
+        public AccessibleContext getAccessibleContext() {
+            if (accessibleContext == null) {
+                accessibleContext = new AccessibleFocusedPropertyPanel();
+            }
+            return accessibleContext;
+        }
+
+        private class AccessibleFocusedPropertyPanel extends AccessibleJComponent {
+            AccessibleFocusedPropertyPanel() {}
+            public AccessibleRole getAccessibleRole() {
+                return AccessibleRole.PANEL;
+            }
+
+            public String getAccessibleName() {
+                FeatureDescriptor fd = ((ExPropertyModel)getModel()).getFeatureDescriptor();
+                PropertyEditor editor = getPropertyEditor();
+                
+                return MessageFormat.format(
+                    getString(&quot;ACS_PropertyPanelRenderer&quot;),
+                    new Object[] {
+                        fd.getDisplayName(),
+                        (editor == null) ? getString(&quot;CTL_No_value&quot;) : editor.getAsText()
+                    }
+                );
+            }
+
+            public String getAccessibleDescription() {
+                FeatureDescriptor fd = ((ExPropertyModel)getModel()).getFeatureDescriptor();
+                Node node = (Node)((ExPropertyModel)getModel()).getBeans()[0];
+                Class clazz = getModel().getPropertyType();
+                return MessageFormat.format(
+                    getString(&quot;ACSD_PropertyPanelRenderer&quot;),
+                    new Object[] {
+                        fd.getShortDescription(),
+                        clazz == null ? getString(&quot;CTL_No_type&quot;) : clazz.getName(), 
+                        node.getDisplayName()
+                    }
+                );
+            }
+        }
+    }
+    
+    private static String getString(String key) {
+        return NbBundle.getBundle(SheetCell.class).getString(key);
+    }
+    
+    private static Color noFocusSelectionBackground=null;
+    static Color getNoFocusSelectionBackground() {
+        if (noFocusSelectionBackground == null) {
+            //allow theme/ui custom definition
+            noFocusSelectionBackground = 
+                UIManager.getColor(&quot;nb.explorer.noFocusSelectionBackground&quot;); //NOI18N
+            if (noFocusSelectionBackground == null) {
+                //try to get standard shadow color
+                noFocusSelectionBackground = UIManager.getColor(&quot;controlShadow&quot;); //NOI18N
+                if (noFocusSelectionBackground == null) {
+                    //Okay, the look and feel doesn't suport it, punt
+                    noFocusSelectionBackground = Color.lightGray;
+                }
+                //Lighten it a bit because disabled text will use controlShadow/
+                //gray
+                noFocusSelectionBackground = noFocusSelectionBackground.brighter();
+            }
+        }
+        return noFocusSelectionBackground;
+    }
+    
+    private static Color noFocusSelectionForeground=null;
+    static Color getNoFocusSelectionForeground() {
+        if (noFocusSelectionForeground == null) {
+            //allow theme/ui custom definition
+            noFocusSelectionForeground =
+            UIManager.getColor(&quot;nb.explorer.noFocusSelectionForeground&quot;); //NOI18N
+            if (noFocusSelectionForeground == null) {
+                //try to get standard shadow color
+                noFocusSelectionForeground = UIManager.getColor(&quot;textText&quot;); //NOI18N
+                if (noFocusSelectionForeground == null) {
+                    //Okay, the look and feel doesn't suport it, punt
+                    noFocusSelectionForeground = Color.BLACK;
+                }
+            }
+        }
+        return noFocusSelectionForeground;
+    }
+
+    /**
+     *
+     */
+    static class TableSheetCell extends SheetCell {
+        /* Table sheet cell works only with NodeTableModel */
+        private NodeTableModel tableModel;
+        private ETable table;
+        public TableSheetCell(NodeTableModel tableModel, ETable table) {
+            this.tableModel = tableModel;
+            this.table = table;
+        }
+        public Node nodeForRow(int row) {
+            int r = table.convertRowIndexToModel(row);
+            return tableModel.nodeForRow(r);
+        }
+        public String getShortDescription(int column) {
+            return tableModel.propertyForColumn(column).getShortDescription();
+        }
+        public void propertyChange(PropertyChangeEvent evt) {
+    //        stopCellEditing(); //XXX ?
+            tableModel.fireTableDataChanged();
+        }
+        protected void detachEditor() {
+            super.detachEditor();
+            tableModel.removeTableModelListener(this);
+        }
+        public Component getTableCellEditorComponent(JTable table,
+                                                 Object value,
+                                                 boolean isSelected,
+                                                 int r, int c) {
+           tableModel.addTableModelListener(this);
+           return super.getTableCellEditorComponent(table, value, isSelected, r, c);
+        }
+    }
+    
+    public static class OutlineSheetCell extends SheetCell {
+        private Outline outline;
+        public OutlineSheetCell(Outline outline) {
+            this.outline = outline;
+        }
+        public Node nodeForRow(int row) {
+            int r = outline.convertRowIndexToModel(row);
+            TreePath tp = outline.getLayoutCache().getPathForRow(r);
+            return Visualizer.findNode(tp.getLastPathComponent());
+        }
+        public String getShortDescription(int column) {
+            return outline.getOutlineModel().getColumnName(column);
+        }
+        public void propertyChange(PropertyChangeEvent evt) {
+            stopCellEditing();
+            outline.tableChanged(new TableModelEvent(outline.getModel(), 0, outline.getRowCount()));
+        }
+        protected void detachEditor() {
+            super.detachEditor();
+            TableModel tableModel = outline.getModel();
+            tableModel.removeTableModelListener(this);
+        }
+        public Component getTableCellEditorComponent(JTable table,
+                                                 Object value,
+                                                 boolean isSelected,
+                                                 int r, int c) {
+           TableModel tableModel = outline.getModel();
+           tableModel.addTableModelListener(this);
+           return super.getTableCellEditorComponent(table, value, isSelected, r, c);
+        }
+        
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/TableView.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/TableView.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/api/tableview/TableView.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,520 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2005 Nokia. All Rights Reserved.
+ */
+package org.netbeans.api.tableview;
+
+import java.awt.Component;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.MouseEvent;
+import java.beans.PropertyChangeListener;
+import java.beans.PropertyVetoException;
+import java.beans.VetoableChangeListener;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.text.MessageFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.EventObject;
+import java.util.Properties;
+import javax.swing.Action;
+import javax.swing.JMenuItem;
+import javax.swing.JPopupMenu;
+import javax.swing.JScrollPane;
+import javax.swing.JTable;
+import javax.swing.ListSelectionModel;
+import javax.swing.SwingUtilities;
+import javax.swing.event.ListSelectionListener;
+import javax.swing.event.PopupMenuEvent;
+import javax.swing.event.PopupMenuListener;
+import javax.swing.table.TableCellEditor;
+import javax.swing.table.TableCellRenderer;
+import javax.swing.table.TableColumn;
+import javax.swing.table.TableModel;
+import org.netbeans.swing.etable.ETable;
+import org.netbeans.swing.etable.ETableColumn;
+import org.netbeans.swing.etable.QuickFilter;
+import org.openide.ErrorManager;
+import org.openide.awt.MouseUtils;
+import org.openide.explorer.ExplorerManager;
+import org.openide.nodes.Node;
+import org.openide.nodes.NodeOp;
+import org.openide.util.NbBundle;
+import org.openide.util.Utilities;
+import org.openide.util.WeakListeners;
+
+/**
+ * Explorer view displaying nodes in a table.
+ * @author David Strupl
+ */
+public class TableView extends JScrollPane {
+
+    /** The table */
+    private ETable table;
+    /** Explorer manager, valid when this view is showing */
+    private ExplorerManager manager;
+    /** not null if popup menu enabled */
+    transient PopupAdapter popupListener;
+    /** the most important listener (on four types of events */
+    transient TableSelectionListener managerListener = null;
+    /** weak variation of the listener for property change on the explorer manager */
+    transient PropertyChangeListener wlpc;
+    /** weak variation of the listener for vetoable change on the explorer manager */
+    transient VetoableChangeListener wlvc;
+    /** */
+    private NodePopupFactory popupFactory;
+    
+    /** Creates a new instance of TableView */
+    public TableView() {
+        this(new NodeTableModel());
+    }
+    
+    /** Creates a new instance of TableView */
+    public TableView(NodeTableModel ntm) {
+        table = new TableViewETable();
+        table.setModel(ntm);
+        SheetCell tableCell = new SheetCell.TableSheetCell(ntm, table);
+        table.setDefaultRenderer(Node.Property.class, tableCell);
+        table.setDefaultEditor(Node.Property.class, tableCell);
+        setViewportView(table);
+        setPopupAllowed(true);
+        // do not care about focus
+        setRequestFocusEnabled (false);
+        table.setRequestFocusEnabled(true);
+        getActionMap().put(&quot;org.openide.actions.PopupAction&quot;, new PopupAction());
+        popupFactory = new NodePopupFactory();
+        java.awt.Color c = javax.swing.UIManager.getColor(&quot;Table.background1&quot;);
+        if (c == null) {
+            c = javax.swing.UIManager.getColor(&quot;Table.background&quot;);
+        }
+        if (c != null) {
+            getViewport().setBackground(c);
+        }
+
+    }
+    
+    /** Requests focus for the tree component. Overrides superclass method. */
+    public void requestFocus () {
+        table.requestFocus();
+    }
+    
+    /** Requests focus for the tree component. Overrides superclass method. */
+    public boolean requestFocusInWindow () {
+        return table.requestFocusInWindow();
+    }
+    
+    /**
+     * Getter for the embeded table component.
+     */
+    public ETable getTable() {
+        return table;
+    }
+    
+    /** Is it permitted to display a popup menu?
+     * @return &lt;code&gt;true&lt;/code&gt; if so
+     */
+    public boolean isPopupAllowed () {
+        return popupListener != null;
+    }
+
+    /** Enable/disable displaying popup menus on tree view items.
+    * Default is enabled.
+    * @param value &lt;code&gt;true&lt;/code&gt; to enable
+    */
+    public void setPopupAllowed (boolean value) {
+        if (popupListener == null &amp;&amp; value) {
+            // on
+            popupListener = new PopupAdapter ();
+            table.addMouseListener (popupListener);
+            return;
+        }
+        if (popupListener != null &amp;&amp; !value) {
+            // off
+            table.removeMouseListener (popupListener);
+            popupListener = null;
+            return;
+        }
+    }
+    
+    /** Initializes the component and lookup explorer manager.
+     */
+    public void addNotify () {
+        super.addNotify ();
+        lookupExplorerManager ();
+    }
+    
+    /**
+     * Method allowing to read stored values.
+     * The stored values should be only those that the user has customized,
+     * it does not make sense to store the values that were set using 
+     * the initialization code because the initialization code can be run
+     * in the same way after restart.
+     */
+    public void readSettings(Properties p, String propertyPrefix) {
+        table.readSettings(p, propertyPrefix);
+    }
+
+    /**
+     * Method allowing to store customization values.
+     * The stored values should be only those that the user has customized,
+     * it does not make sense to store the values that were set using 
+     * the initialization code because the initialization code can be run
+     * in the same way after restart.
+     */
+    public void writeSettings(Properties p, String propertyPrefix) {
+        table.writeSettings(p, propertyPrefix);
+    }
+
+    /**
+     * Allows customization of the popup menus.
+     */
+    public void setNodePopupFactory(NodePopupFactory newFactory) {
+        popupFactory = newFactory;
+    }
+    
+    /**
+     * Getter for the current popup customizer factory.
+     */
+    public NodePopupFactory getNodePopupFactory() {
+        return popupFactory;
+    }
+    
+    /** Registers in the tree of components.
+     */
+    private void lookupExplorerManager () {
+        // Enter key in the tree
+
+        if (managerListener == null) {
+            managerListener = new TableSelectionListener();
+        }
+        
+        ExplorerManager newManager = ExplorerManager.find(this);
+        if (newManager != manager) {
+            if (manager != null) {
+                manager.removeVetoableChangeListener (wlvc);
+                manager.removePropertyChangeListener (wlpc);
+            }
+
+            manager = newManager;
+
+            manager.addVetoableChangeListener(wlvc = WeakListeners.vetoableChange(managerListener, manager));
+            manager.addPropertyChangeListener(wlpc = WeakListeners.propertyChange(managerListener, manager));
+
+            synchronizeRootContext();
+            synchronizeSelectedNodes ();
+        }
+
+        // Sometimes the listener is registered twice and we get the 
+        // selection events twice. Removing the listener before adding it
+        // should be a safe fix.
+        table.getSelectionModel().removeListSelectionListener(managerListener);
+        table.getSelectionModel().addListSelectionListener(managerListener);
+    }
+    
+    /** Synchronize the root context from the manager of this Explorer.
+    */
+    final void synchronizeRootContext() {
+        NodeTableModel ntm = (NodeTableModel)table.getModel();
+        ntm.setNodes(manager.getRootContext().getChildren().getNodes());
+    }
+
+    /** Synchronize the selected nodes from the manager of this Explorer.
+     */
+    final void synchronizeSelectedNodes() {
+        Node[] arr = manager.getSelectedNodes ();
+        table.getSelectionModel().clearSelection();
+        NodeTableModel ntm = (NodeTableModel)table.getModel();
+        int size = ntm.getRowCount();
+        int firstSelection = -1;
+        for (int i = 0; i &lt; size; i++) {
+            Node n = getNodeFromRow(i);
+            for (int j = 0; j &lt; arr.length; j++) {
+                if (n.equals(arr[j])) {
+                    table.getSelectionModel().addSelectionInterval(i, i);
+                    if (firstSelection == -1) {
+                        firstSelection = i;
+                    }
+                }
+            }
+        }
+        if (firstSelection &gt;= 0) {
+            Rectangle rect = table.getCellRect(firstSelection, 0, true);
+            java.awt.Insets ins = getInsets();
+            rect.height = getHeight() - 30;
+            table.scrollRectToVisible(rect);
+        }
+
+    }
+    
+    /**
+     * Deinitializes listeners.
+     */
+    public void removeNotify () {
+        super.removeNotify ();
+        table.getSelectionModel().removeListSelectionListener(managerListener);
+    }
+
+    /**
+     * Shows popup menu invoked on the table.
+     */
+    private void showPopup(int xpos, int ypos, final JPopupMenu popup) {
+        if ((popup != null) &amp;&amp; (popup.getSubElements().length &gt; 0)) {
+            final PopupMenuListener p = new PopupMenuListener() {
+                public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
+                    
+                }
+                public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
+                    popup.removePopupMenuListener(this);
+                    table.requestFocus();
+                }
+                public void popupMenuCanceled(PopupMenuEvent e) {
+                    
+                }
+            };
+            popup.addPopupMenuListener(p);
+            popup.show(this, xpos, ypos);
+        }
+    }    
+    
+    /**
+     * Find relevant actions and call the factory to create a popup.
+     */
+    private JPopupMenu createPopup(Point p) {
+        int[] selRows = table.getSelectedRows();
+        Node[] arr = new Node[selRows.length];
+        for (int i = 0; i &lt; selRows.length; i++) {
+            arr[i] = getNodeFromRow(selRows[i]);
+        }
+        p = SwingUtilities.convertPoint(this, p, table);
+        int column = table.columnAtPoint(p);
+        int row = table.rowAtPoint(p);
+        return popupFactory.createPopupMenu(row, column, arr, table);
+    }
+    
+    /**
+     * 
+     */
+    private Node getNodeFromRow(int rowIndex) {
+        int row = table.convertRowIndexToModel(rowIndex);
+        TableModel tm = table.getModel();
+        if (tm instanceof NodeTableModel) {
+            NodeTableModel ntm = (NodeTableModel)tm;
+            return ntm.nodeForRow(row);
+        }
+        return null;
+    }
+    
+    /** Returns the point at which the popup menu is to be shown. May return null.
+     * @return the point or null
+     */    
+    private Point getPositionForPopup () {
+        int i = table.getSelectionModel().getLeadSelectionIndex();
+        if (i &lt; 0) return null;
+        int j = table.getColumnModel().getSelectionModel().getLeadSelectionIndex();
+        if (j &lt; 0) {
+            j = 0;
+        }
+
+        Rectangle rect = table.getCellRect(i, j, true);
+        if (rect == null) return null;
+
+        Point p = new Point(rect.x + rect.width / 3,
+                rect.y + rect.height / 2);
+        
+        // bugfix #36984, convert point by TableView.this
+        p =  SwingUtilities.convertPoint (table, p, TableView.this);
+
+        return p;
+    }
+
+    /**
+     * Action registered in the component's action map.
+     */
+    private class PopupAction extends javax.swing.AbstractAction implements Runnable {
+        public void actionPerformed(ActionEvent evt) {
+            SwingUtilities.invokeLater(this);
+        }
+        public void run() {
+            Point p = getPositionForPopup ();
+            if (p == null) {
+                return ;
+            }
+            if (isPopupAllowed()) {
+                JPopupMenu pop = createPopup(p);
+                showPopup(p.x, p.y, pop);
+            }
+        }
+    };
+    
+    /**
+     * Mouse listener that invokes popup.
+     */
+    private class PopupAdapter extends MouseUtils.PopupMouseAdapter {
+
+	PopupAdapter() {}
+	
+        protected void showPopup (MouseEvent e) {
+            int selRow = table.rowAtPoint(e.getPoint());
+
+            if (selRow != -1) {
+                if (! table.getSelectionModel().isSelectedIndex(selRow)) {
+                    table.getSelectionModel().clearSelection();
+                    table.getSelectionModel().setSelectionInterval(selRow, selRow);
+                }
+                Point p = SwingUtilities.convertPoint(e.getComponent(), e.getPoint(), TableView.this);
+                if (isPopupAllowed()) {
+                    JPopupMenu pop = createPopup(p);
+                    TableView.this.showPopup(p.x, p.y, pop);
+                    e.consume();
+                }
+            } 
+        }
+    }
+    
+    /**
+     * Called when selection in tree is changed.
+     */
+    final void callSelectionChanged (Node[] nodes) {
+        manager.removePropertyChangeListener (wlpc);
+        manager.removeVetoableChangeListener (wlvc);
+        try {
+            manager.setSelectedNodes(nodes);
+        } catch (PropertyVetoException e) {
+            synchronizeSelectedNodes ();
+        } finally {
+            manager.addPropertyChangeListener (wlpc);
+            manager.addVetoableChangeListener (wlvc);
+        }
+    }
+    
+    /** 
+     * Check if selection of the nodes could break
+     * the selection mode set in the ListSelectionModel.
+     * @param nodes the nodes for selection
+     * @return true if the selection mode is broken
+     */
+    private boolean isSelectionModeBroken(Node[] nodes) {
+        
+        // if nodes are empty or single then everthing is ok
+        // or if discontiguous selection then everthing ok
+        if (nodes.length &lt;= 1 || table.getSelectionModel().getSelectionMode() == 
+                ListSelectionModel.MULTIPLE_INTERVAL_SELECTION) {
+            return false;
+        }
+
+        // if many nodes
+        
+        // breaks single selection mode
+        if (table.getSelectionModel().getSelectionMode() == 
+            ListSelectionModel.SINGLE_SELECTION) {
+            return true;
+        }
+        
+        // check the contiguous selection mode
+
+        // check selection's rows
+        
+        // all is ok
+        return false;
+    }
+    
+    /**
+     * Listener attached to the explorer manager and also to the
+     * changes in the table selection.
+     */
+    private class TableSelectionListener implements VetoableChangeListener, ListSelectionListener, PropertyChangeListener {
+        public void propertyChange(java.beans.PropertyChangeEvent evt) {
+            if (manager == null) return; // the tree view has been removed before the event got delivered
+            if (evt.getPropertyName().equals(ExplorerManager.PROP_ROOT_CONTEXT)) {
+                synchronizeRootContext();
+            }
+            if (evt.getPropertyName().equals(ExplorerManager.PROP_SELECTED_NODES)) {
+                synchronizeSelectedNodes();
+            }
+        }
+
+        public void valueChanged(javax.swing.event.ListSelectionEvent listSelectionEvent) {
+            int selectedRows[] = table.getSelectedRows();
+            Node []selectedNodes = new Node[selectedRows.length];
+            for (int i = 0; i &lt; selectedNodes.length;i++) {
+                selectedNodes[i] = getNodeFromRow(selectedRows[i]);
+            }
+            callSelectionChanged(selectedNodes);
+        }
+
+        public void vetoableChange(java.beans.PropertyChangeEvent evt) throws java.beans.PropertyVetoException {
+            if (evt.getPropertyName().equals(ExplorerManager.PROP_SELECTED_NODES)) {
+                // issue 11928 check if selecetion mode will be broken
+                Node[] nodes = (Node[])evt.getNewValue();
+                if (isSelectionModeBroken(nodes)) {
+                    throw new PropertyVetoException(&quot;selection mode &quot; +  &quot; broken by &quot; + Arrays.asList(nodes), evt); // NOI18N
+                }
+            }
+        }
+    }
+
+    /**
+     * Extension of the ETable that allows adding a special comparator
+     * for sorting the rows.
+     */
+    private static class TableViewETable extends ETable {
+        public TableViewETable() {
+            super();
+        }
+        protected TableColumn createColumn(int modelIndex) {
+            return new TableViewETableColumn(modelIndex);
+        }
+
+        public Object transformValue(Object value) {
+            return PropertiesRowModel.getValueFromProperty(value);
+        }
+        
+        public boolean editCellAt(int row, int column, EventObject e) {
+            Object o = getValueAt(row, column);
+            if (o instanceof Node.Property) { // &amp;&amp; (e == null || e instanceof KeyEvent)) {
+                //Toggle booleans without instantiating an editor
+                Node.Property p = (Node.Property)o;
+                if (p.getValueType() == Boolean.class || p.getValueType() == Boolean.TYPE) {
+                    PropertiesRowModel.toggleBooleanProperty(p);
+                    Rectangle r = getCellRect(row, column, true);
+                    repaint (r.x, r.y, r.width, r.height);
+                    return false;
+                }
+            }
+            return super.editCellAt(row, column, e);
+        }
+        
+        /**
+         */
+        private class TableViewETableColumn extends ETableColumn {
+            public TableViewETableColumn(int index) {
+                super(index, TableViewETable.this);
+            }
+            public boolean isSortingAllowed() {
+                TableModel model = getModel();
+                if (model instanceof NodeTableModel) {
+                    NodeTableModel ntm = (NodeTableModel)model;
+                    return ntm.isComparableColumn(getModelIndex());
+                }
+                return true;
+            }
+        }
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview/resources/Bundle.properties
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview/resources/Bundle.properties	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview/resources/Bundle.properties	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,23 @@
+# The contents of this file are subject to the terms of the Common Development
+# and Distribution License (the License). You may not use this file except in
+# compliance with the License.
+#
+# You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+# or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+#
+# When distributing Covered Code, include this CDDL Header Notice in each file
+# and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+# If applicable, add the following below the CDDL Header, with the fields
+# enclosed by brackets [] replaced by your own identifying information:
+# &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+#
+# The Original Software is NetBeans. The Initial Developer of the Original
+# Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+# Microsystems, Inc. All Rights Reserved.
+
+# manifest.mf
+OpenIDE-Module-Name=Table View
+OpenIDE-Module-Display-Category=Infrastructure
+OpenIDE-Module-Short-Description=TableView and OutlineView Components
+OpenIDE-Module-Long-Description=TableView and OutlineView are explorer views allowing to visualize nodes in table and tree table
+

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview/resources/layer.xml
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview/resources/layer.xml	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/modules/tableview/resources/layer.xml	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,5 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;!DOCTYPE filesystem PUBLIC &quot;-//NetBeans//DTD Filesystem 1.1//EN&quot; &quot;<A HREF="http://www.netbeans.org/dtds/filesystem-1_1.dtd">http://www.netbeans.org/dtds/filesystem-1_1.dtd</A>&quot;&gt;
+&lt;filesystem&gt;
+&lt;/filesystem&gt;
+

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ColumnSelectionPanel.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ColumnSelectionPanel.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ColumnSelectionPanel.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,157 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2004 Nokia. All Rights Reserved.
+ */
+package org.netbeans.swing.etable;
+
+import java.awt.Color;
+import java.awt.GridBagConstraints;
+import java.awt.GridBagLayout;
+import java.text.Collator;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import javax.swing.JCheckBox;
+import javax.swing.JPanel;
+import javax.swing.border.LineBorder;
+import javax.swing.table.TableColumnModel;
+
+/**
+ * Panel containing checkboxes for selecting visible columns
+ * of a table.
+ * @author David Strupl
+ */
+class ColumnSelectionPanel extends JPanel {
+
+    /**
+     * Map: ETableColumn --&gt; JCheckBox
+     */
+    private Map checkBoxes = new HashMap();
+    
+    /**
+     * Model allowing to show/hide columns.
+     */
+    private ETableColumnModel columnModel;
+    
+    /** Creates a new instance of ColumnSelectionPanel */
+    public ColumnSelectionPanel(TableColumnModel columnModel, ETable table) {
+        setLayout(new GridBagLayout());
+        if (! (columnModel instanceof ETableColumnModel)) {
+            return;
+        }
+        ETableColumnModel etcm = (ETableColumnModel)columnModel;
+        this.columnModel = etcm;
+        List columns = Collections.list(etcm.getColumns());
+        columns.addAll(etcm.hiddenColumns);
+        Collections.sort(columns);
+        int width = columns.size() / 10 + 1;
+        layoutPanel(columns, width, table);
+    }
+    
+    /**
+     * Adds checkbox for each ETableColumn contained in the columns parameter.
+     */
+    private void layoutPanel(List columns, int width, ETable table) {
+        Map displayNameToCheckBox = new HashMap();
+        ArrayList displayNames = new ArrayList();
+        for (Iterator it = columns.iterator(); it.hasNext(); ) {
+            ETableColumn etc = (ETableColumn)it.next();
+            JCheckBox checkBox = new JCheckBox();
+            checkBoxes.put(etc, checkBox);
+            String dName = table.getColumnDisplayName(etc.getHeaderValue().toString());
+            checkBox.setText(dName);
+            checkBox.setSelected(! columnModel.isColumnHidden(etc));
+            checkBox.setEnabled(etc.isHidingAllowed());
+            if (! displayNames.contains(dName)) {
+                // the expected case
+                displayNameToCheckBox.put(dName, checkBox);
+            } else {
+                // the same display name is used for more columns - fuj
+                ArrayList al = null;
+                Object theFirstOne = displayNameToCheckBox.get(dName);
+                if (theFirstOne instanceof JCheckBox) {
+                    JCheckBox firstCheckBox = (JCheckBox)theFirstOne;
+                    al = new ArrayList();
+                    al.add(firstCheckBox);
+                } else {
+                    // already a list there
+                    if (theFirstOne instanceof ArrayList) {
+                        al = (ArrayList)theFirstOne;
+                    } else {
+                        throw new IllegalStateException(&quot;Wrong object theFirstOne is &quot; + theFirstOne);
+                    }
+                }
+                al.add(checkBox);
+                displayNameToCheckBox.put(dName, al);
+            }
+            displayNames.add(dName);
+        }
+        Collections.sort(displayNames, Collator.getInstance());
+        int i = 0;
+        int j = 0;
+        int index = 0;
+        int rows = columns.size() / width;
+        for (Iterator it = displayNames.iterator(); it.hasNext(); i++) {
+            if (i &gt;= rows) {
+                i = 0;
+                j++;
+            }
+            String displayName = (String)it.next();
+            Object obj = displayNameToCheckBox.get(displayName);
+            JCheckBox checkBox = null;
+            if (obj instanceof JCheckBox) {
+                checkBox = (JCheckBox)obj;
+            } else {
+                // in case there are duplicate names we store ArrayLists
+                // of JCheckBoxes
+                if (obj instanceof ArrayList) {
+                    ArrayList al = (ArrayList)obj;
+                    if (index &gt;= al.size()) {
+                        index = 0;
+                    }
+                    checkBox = (JCheckBox)al.get(index++);
+                } else {
+                    throw new IllegalStateException(&quot;Wrong object obj is &quot; + obj);
+                }
+            }
+            GridBagConstraints gridBagConstraints = new GridBagConstraints();
+            gridBagConstraints.gridx = j;
+            gridBagConstraints.gridy = i;
+            gridBagConstraints.insets = new java.awt.Insets(5, 12, 0, 12);
+            gridBagConstraints.anchor = GridBagConstraints.NORTHWEST;
+            gridBagConstraints.weightx = 1;
+            add(checkBox, gridBagConstraints);
+        }
+    }
+    
+    /**
+     * After the user clicks Ok this method will hide/un-hide the
+     * columns according to the selected checkboxes.
+     */
+    public void changeColumnVisibility() {
+        if (columnModel == null) {
+            return;
+        }
+        for (Iterator it = checkBoxes.keySet().iterator(); it.hasNext(); ) {
+            ETableColumn etc = (ETableColumn) it.next();
+            JCheckBox checkBox = (JCheckBox)checkBoxes.get(etc);
+            columnModel.setColumnHidden(etc,! checkBox.isSelected());
+        }
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETable.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETable.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETable.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,2354 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2004 Nokia. All Rights Reserved.
+ */
+package org.netbeans.swing.etable;
+
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Container;
+import java.awt.ContainerOrderFocusTraversalPolicy;
+import java.awt.Event;
+import java.awt.EventQueue;
+import java.awt.KeyboardFocusManager;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.FocusEvent;
+import java.awt.event.FocusListener;
+import java.awt.event.InputEvent;
+import java.awt.event.ItemListener;
+import java.awt.event.KeyAdapter;
+import java.awt.event.KeyEvent;
+import java.awt.event.KeyListener;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import java.text.Collator;
+import java.text.MessageFormat;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Enumeration;
+import java.util.EventObject;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.Vector;
+import javax.swing.AbstractAction;
+import javax.swing.Action;
+import javax.swing.ActionMap;
+import javax.swing.BorderFactory;
+import javax.swing.BoxLayout;
+import javax.swing.ComboBoxModel;
+import javax.swing.DefaultComboBoxModel;
+import javax.swing.Icon;
+import javax.swing.ImageIcon;
+import javax.swing.InputMap;
+import javax.swing.JButton;
+import javax.swing.JCheckBoxMenuItem;
+import javax.swing.JComboBox;
+import javax.swing.JLabel;
+import javax.swing.JMenu;
+import javax.swing.JMenuItem;
+import javax.swing.JOptionPane;
+import javax.swing.JPanel;
+import javax.swing.JPopupMenu;
+import javax.swing.JRootPane;
+import javax.swing.JScrollPane;
+import javax.swing.JTable;
+import javax.swing.JTextField;
+import javax.swing.JViewport;
+import javax.swing.KeyStroke;
+import javax.swing.ListSelectionModel;
+import javax.swing.SwingUtilities;
+import javax.swing.UIManager;
+import javax.swing.border.Border;
+import javax.swing.border.CompoundBorder;
+import javax.swing.event.DocumentEvent;
+import javax.swing.event.DocumentListener;
+import javax.swing.event.TableModelEvent;
+import javax.swing.table.*;
+import javax.swing.table.TableCellRenderer;
+
+/**
+ * &lt;UL&gt;Extended JTable (ETable) adds these features to JTable:
+ *     &lt;LI&gt; The notion of fully editable (non-editable) table. &lt;/LI&gt;
+ *     &lt;LI&gt; &lt;strong&gt;Sorting&lt;/strong&gt; the rows of the table by clicking the header.
+ *          Shift-Click allows to use more columns for the sort. The sort is
+ *          based on the values implementing Comparable interface. &lt;/LI&gt;
+ *     &lt;LI&gt; Automatic &lt;strong&gt;column width&lt;/strong&gt; after init or after
+ *          the model is changed (or triggered by &quot;Ctrl-+&quot; shortcut). 
+ *          Automatic resize the column after double-click
+ *          in the header column divider araa. &lt;/LI&gt;
+ *     &lt;LI&gt; &lt;strong&gt;Persistence&lt;/strong&gt; of the user customized settings via
+ *          methods readSettings and writeSettings.
+ *     &lt;LI&gt; &lt;strong&gt;Quick-Filter&lt;/strong&gt; features allowing to show only
+ *          certain rows from the model (see setQuickFilter()). &lt;/LI&gt;
+ *     &lt;LI&gt; 
+ * &lt;/UL&gt;
+ * @author David Strupl
+ */
+public class ETable extends JTable {
+    
+    /** Action key for up/down focus action */
+    private static final String ACTION_FOCUS_NEXT = &quot;focusNext&quot;; //NOI18N
+
+    /** Possible value for editing property */
+    private final static int FULLY_EDITABLE = 1;
+    /** Possible value for editing property */
+    private final static int FULLY_NONEDITABLE = 2;
+    /** Possible value for editing property */
+    private final static int DEFAULT = 3;
+
+    /** Key for storing the currently searched column's index. */
+    private static final String SEARCH_COLUMN = &quot;SearchColumn&quot;;
+    
+    // icon of column button
+    private static final String DEFAULT_COLUMNS_ICON = &quot;columns.gif&quot;; // NOI18N
+    
+    /**
+     * Property allowing to make the table FULLY_NONEDITABLE and
+     * FULLY_EDITABLE.
+     */
+    private int editing = DEFAULT;
+    
+    /** 
+     * Array with size exactly sama as the number of rows in the data model
+     * or null. If it is not null the row originally at index i will be
+     * displayed on index sortingPermutation[i].
+     */
+    transient int [] sortingPermutation;
+    
+    /** Inverse of the above */
+    transient int [] inverseSortingPermutation;
+    
+    /**
+     *
+     */
+    private transient int filteredRowCount;
+    
+    /**
+     *
+     */
+    private Object quickFilterObject;
+    
+    /**
+     *
+     */
+    private int quickFilterColumn = -1;
+
+    // Search text field related variables:
+    /** */
+    private String maxPrefix;
+    /** */
+    int SEARCH_FIELD_PREFERRED_SIZE = 160;
+    /** */
+    int SEARCH_FIELD_SPACE = 3;
+    /** */
+    final private JTextField searchTextField = new SearchTextField();
+    /** */
+    final private int heightOfTextField = searchTextField.getPreferredSize().height;
+    
+    /** */
+    private JPanel searchPanel = null;
+    
+    /** */
+    private JComboBox searchCombo = null;
+    
+    /** */
+    private ETableColumn searchColumn = null;
+    
+    /**
+     * This text can be customized using setSelectVisibleColumnsLabel(...) method.
+     */
+    private String selectVisibleColumnsLabel = &quot;Select Visible Columns&quot;;
+
+    private boolean inEditRequest = false;
+    private boolean inEditorChangeRequest=false;
+    private boolean inRemoveRequest=false;
+
+    /**
+     * Default formatting strings for the Quick Filter feature.
+     * Can be customized by setQuickFilterFormatStrings(...) method.
+     */
+    private String[] quickFilterFormatStrings = new String [] {
+        &quot;{0} == {1}&quot;, &quot;{0} &lt;&gt; {1}&quot;, &quot;{0} &gt; {1}&quot;, 
+        &quot;{0} &lt; {1}&quot;, &quot;{0} &gt;= {1}&quot;, &quot;{0} &lt;= {1}&quot;,
+        &quot;No Filter&quot;
+    };
+    
+    /**
+     * Listener reacting to the user clicks on the header.
+     */
+    private MouseListener headerMouseListener = new HeaderMouseListener();
+
+    /**
+     * Listener reacting to the user clicks on the table invoking the
+     * column selection dialog.
+     */
+    private MouseListener columnSelectionMouseListener = new ColumnSelectionMouseListener();
+    
+    /**
+     * Constructs a default &lt;code&gt;JTable&lt;/code&gt; that is initialized with a default
+     * data model, a default column model, and a default selection
+     * model.
+     *
+     * @see #createDefaultDataModel
+     * @see #createDefaultColumnModel
+     * @see #createDefaultSelectionModel
+     */
+    public ETable() {
+        updateMouseListener();
+    }
+    
+    /**
+     * Constructs a &lt;code&gt;JTable&lt;/code&gt; that is initialized with
+     * &lt;code&gt;dm&lt;/code&gt; as the data model, a default column model,
+     * and a default selection model.
+     *
+     * @param dm        the data model for the table
+     * @see #createDefaultColumnModel
+     * @see #createDefaultSelectionModel
+     */
+    public ETable(TableModel dm) {
+        super(dm);
+        updateMouseListener();
+    }
+    
+    /**
+     * Constructs a &lt;code&gt;JTable&lt;/code&gt; that is initialized with
+     * &lt;code&gt;dm&lt;/code&gt; as the data model, &lt;code&gt;cm&lt;/code&gt;
+     * as the column model, and a default selection model.
+     *
+     * @param dm        the data model for the table
+     * @param cm        the column model for the table
+     * @see #createDefaultSelectionModel
+     */
+    public ETable(TableModel dm, TableColumnModel cm) {
+        super(dm, cm);
+        updateMouseListener();
+    }
+    
+    /**
+     * Constructs a &lt;code&gt;JTable&lt;/code&gt; that is initialized with
+     * &lt;code&gt;dm&lt;/code&gt; as the data model, &lt;code&gt;cm&lt;/code&gt; as the
+     * column model, and &lt;code&gt;sm&lt;/code&gt; as the selection model.
+     * If any of the parameters are &lt;code&gt;null&lt;/code&gt; this method
+     * will initialize the table with the corresponding default model.
+     * The &lt;code&gt;autoCreateColumnsFromModel&lt;/code&gt; flag is set to false
+     * if &lt;code&gt;cm&lt;/code&gt; is non-null, otherwise it is set to true
+     * and the column model is populated with suitable
+     * &lt;code&gt;TableColumns&lt;/code&gt; for the columns in &lt;code&gt;dm&lt;/code&gt;.
+     *
+     * @param dm        the data model for the table
+     * @param cm        the column model for the table
+     * @param sm        the row selection model for the table
+     * @see #createDefaultDataModel
+     * @see #createDefaultColumnModel
+     * @see #createDefaultSelectionModel
+     */
+    public ETable(TableModel dm, TableColumnModel cm, ListSelectionModel sm) {
+        super(dm, cm, sm);
+        updateMouseListener();
+    }
+    
+    /**
+     * Constructs a &lt;code&gt;JTable&lt;/code&gt; with &lt;code&gt;numRows&lt;/code&gt;
+     * and &lt;code&gt;numColumns&lt;/code&gt; of empty cells using
+     * &lt;code&gt;DefaultTableModel&lt;/code&gt;.  The columns will have
+     * names of the form &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, etc.
+     *
+     * @param numRows           the number of rows the table holds
+     * @param numColumns        the number of columns the table holds
+     * @see javax.swing.table.DefaultTableModel
+     */
+    public ETable(int numRows, int numColumns) {
+        super(numRows, numColumns);
+        updateMouseListener();
+    }
+    
+    /**
+     * Constructs a &lt;code&gt;JTable&lt;/code&gt; to display the values in the
+     * &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Vectors&lt;/code&gt;, &lt;code&gt;rowData&lt;/code&gt;,
+     * with column names, &lt;code&gt;columnNames&lt;/code&gt;.  The
+     * &lt;code&gt;Vectors&lt;/code&gt; contained in &lt;code&gt;rowData&lt;/code&gt;
+     * should contain the values for that row. In other words,
+     * the value of the cell at row 1, column 5 can be obtained
+     * with the following code:
+     * &lt;p&gt;
+     * &lt;pre&gt;((Vector)rowData.elementAt(1)).elementAt(5);&lt;/pre&gt;
+     * &lt;p&gt;
+     * @param rowData           the data for the new table
+     * @param columnNames       names of each column
+     */
+    public ETable(Vector rowData, Vector columnNames) {
+        super(rowData, columnNames);
+        updateMouseListener();
+    }
+    
+    /**
+     * Constructs a &lt;code&gt;JTable&lt;/code&gt; to display the values in the two dimensional array,
+     * &lt;code&gt;rowData&lt;/code&gt;, with column names, &lt;code&gt;columnNames&lt;/code&gt;.
+     * &lt;code&gt;rowData&lt;/code&gt; is an array of rows, so the value of the cell at row 1,
+     * column 5 can be obtained with the following code:
+     * &lt;p&gt;
+     * &lt;pre&gt; rowData[1][5]; &lt;/pre&gt;
+     * &lt;p&gt;
+     * All rows must be of the same length as &lt;code&gt;columnNames&lt;/code&gt;.
+     * &lt;p&gt;
+     * @param rowData           the data for the new table
+     * @param columnNames       names of each column
+     */
+    public ETable(final Object[][] rowData, final Object[] columnNames) {
+        super(rowData, columnNames);
+        updateMouseListener();
+    }
+    
+    /**
+     * Returns true if the cell at &lt;code&gt;row&lt;/code&gt; and &lt;code&gt;column&lt;/code&gt;
+     * is editable.  Otherwise, invoking &lt;code&gt;setValueAt&lt;/code&gt; on the cell
+     * will have no effect.
+     * &lt;p&gt;
+     * Returns true always if the &lt;code&gt;ETable&lt;/code&gt; is fully editable.
+     * &lt;p&gt;
+     * Returns false always if the &lt;code&gt;ETable&lt;/code&gt; is fully non-editable.
+     *
+     * @param   row      the row whose value is to be queried
+     * @param   column   the column whose value is to be queried
+     * @return  true if the cell is editable
+     * @see #setValueAt
+     * @see #setFullyEditable
+     * @see #setFullyNonEditable
+     */
+    public boolean isCellEditable(int row, int column) {
+        if(editing == FULLY_EDITABLE) {
+            return true;
+        }
+        if(editing == FULLY_NONEDITABLE) {
+            return false;
+        }
+        int modelRow = convertRowIndexToModel(row);
+        return super.isCellEditable(modelRow, column);
+    }
+
+    /**
+     * Overriden to call convertRowIndexToModel(...).
+     * @see javax.swing.JTable#getCellRenderer(int, int)
+     */
+    public TableCellRenderer getCellRenderer(int row, int column) {
+        int modelRow = convertRowIndexToModel(row);
+        return super.getCellRenderer(modelRow, column);
+    }
+
+    /**
+     * Overriden to call convertRowIndexToModel(...).
+     * @see javax.swing.JTable#getCellEditor(int, int)
+     */
+    public TableCellEditor getCellEditor(int row, int column) {
+        int modelRow = convertRowIndexToModel(row);
+        return super.getCellEditor(modelRow, column);
+    }
+
+    /**
+     * Sets all the cells in the &lt;code&gt;ETable&lt;/code&gt; to be editable if
+     * &lt;code&gt;fullyEditable&lt;/code&gt; is true.
+     * if &lt;code&gt;fullyEditable&lt;/code&gt; is false, sets the table cells into
+     * their default state as in JTable.
+     *
+     * @param   fullyEditable   true if the table is meant to be fully editable.
+     *                          false if the table is meant to take the defalut
+     *                          state for editing.
+     * @see #getFullyEditable()
+     */
+    public void setFullyEditable(boolean fullyEditable) {
+        if (fullyEditable) {
+            editing = FULLY_EDITABLE;
+            if(!getShowHorizontalLines()) {
+                setShowHorizontalLines(true);
+            }
+            Color colorBorderAllEditable = UIManager.getColor(&quot;Table.borderAllEditable&quot;);
+            Border border = null;
+            if (colorBorderAllEditable != null) {
+                border = BorderFactory.createLineBorder(colorBorderAllEditable);
+            } else {
+                border = BorderFactory.createLineBorder(Color.GRAY);
+            }
+            Border filler = BorderFactory.createLineBorder(getBackground());
+            CompoundBorder compound = new CompoundBorder(border, filler);
+            setBorder(new CompoundBorder(compound, border));
+        } else {
+            editing = DEFAULT;
+            setBorder( null );
+        }
+        Color c = UIManager.getColor(&quot;Table.defaultGrid&quot;);
+        if (c != null) {
+            setGridColor(c);
+        }
+        if (isFullyNonEditable()) {
+            setupSearch();
+        }
+    }
+    
+    /**
+     * Sets all the cells in the &lt;code&gt;ETable&lt;/code&gt; to be non-editable if
+     * &lt;code&gt;fullyNonEditable&lt;/code&gt; is true.
+     * If &lt;code&gt;fullyNonEditable&lt;/code&gt; is false, sets the table cells into
+     * their default state as in &lt;code&gt;JTable&lt;/code&gt;.
+     *
+     * @param   fullyEditable   true if the table is meant to be fully non-editable.
+     *                          false if the table is meant to take the defalut
+     *                          state for editing.
+     * @see #getFullyNonEditable
+     */
+    public void setFullyNonEditable(boolean fullyNonEditable) {
+        if (fullyNonEditable) {
+            editing = FULLY_NONEDITABLE;
+            if(getShowHorizontalLines())
+                setShowHorizontalLines(false);
+            Color lineBorderColor = UIManager.getColor(&quot;Table.border&quot;);
+            if (lineBorderColor == null) {
+                lineBorderColor = Color.GRAY;
+            }
+            setBorder(BorderFactory.createLineBorder(lineBorderColor));
+            Color c = UIManager.getColor(&quot;Table.noneditableGrid&quot;);
+            if (c != null) {
+                setGridColor(c);
+            }
+        } else {
+            editing = DEFAULT;
+            setBorder( null );
+            if(!getShowHorizontalLines())
+                setShowHorizontalLines(true);
+            Color defaultGridColor = UIManager.getColor(&quot;Table.defaultGrid&quot;);
+            if (defaultGridColor != null) {
+                setGridColor(defaultGridColor);
+            }
+        }
+        if (isFullyNonEditable()) {
+            setupSearch();
+        }
+    }
+    
+    /**
+     * Returns true if &lt;code&gt;ETable&lt;/code&gt; is fully editable.
+     *
+     * @return  true if the the table is fully editable.
+     * @see #setFullyEditable
+     */
+    public boolean isFullyEditable() {
+        return editing == FULLY_EDITABLE;
+    }
+    
+    /**
+     * Returns true if &lt;code&gt;ETable&lt;/code&gt; is fully non-editable.
+     *
+     * @return  true if the the table is fully non-editable.
+     * @see #setFullyNonEditable
+     */
+    public boolean isFullyNonEditable() {
+        return editing == FULLY_NONEDITABLE;
+    }
+    
+    /**
+     * Sets the table cell background colors accodring to NET UI guidelines.
+     * &lt;p&gt;
+     * This is needed in case where the user does not use the NET Look and Feel,
+     * but still wants to paint the cell background colors accoring to NET L&amp;F.
+     * &lt;p&gt;
+     * This needs to be called also in case where the user has custom table cell
+     * renderer (that is not a &lt;code&gt;DefaultTableCellRenderer&lt;/code&gt; or a
+     * sub-class of it) for a cell even though NET L&amp;F package is used, if the
+     * cell background colors need to be consistent for the custom renderer.
+     *
+     * @param   renderer   the custom cell renderer to be painted
+     * @param   isSelected true if the custom cell is selected
+     * @param   row        the row, the custom cell corresponds to
+     * @param   column     the column, the custom cell corresponds to
+     */
+    public void setCellBackground(Component renderer, boolean isSelected,
+            int row, int column) {
+        Color c = null;
+        if (row%2 == 0) { //Background 2
+            if(isSelected) {
+                c = UIManager.getColor(&quot;Table.selectionBackground2&quot;);
+            } else {
+                c = UIManager.getColor(&quot;Table.background2&quot;);
+            }
+        } else { // Background 1
+            if(isSelected) {
+                c = UIManager.getColor(&quot;Table.selectionBackground1&quot;);
+            } else {
+                c = UIManager.getColor(&quot;Table.background1&quot;);
+            }
+        }
+        if (c != null) {
+            renderer.setBackground(c);
+        }
+    }
+
+    /**
+     * Overriden to use ETableColumns instead of the original TableColumns.
+     * @see javax.swing.JTable#createDefaultColumnModel()
+     */
+    public void createDefaultColumnsFromModel() {
+        TableModel model = getModel();
+        if (model != null) {
+            int modelColumnCount = model.getColumnCount();
+            TableColumn newColumns[] = new TableColumn[modelColumnCount];
+            for (int i = 0; i &lt; newColumns.length; i++) {
+                newColumns[i] = createColumn(i);
+            }
+            TableColumnModel columnModel = getColumnModel();
+            while (columnModel.getColumnCount() &gt; 0) {
+                columnModel.removeColumn(columnModel.getColumn(0));
+            }
+            if (columnModel instanceof ETableColumnModel) {
+                ETableColumnModel etcm = (ETableColumnModel)columnModel;
+                etcm.hiddenColumns = new ArrayList();
+            }
+            for (int i = 0; i &lt; newColumns.length; i++) {
+                addColumn(newColumns[i]);
+            }
+        }
+    }
+
+    /**
+     * Returns string used to delimit entries when
+     * copying into clipboard. The default implementation
+     * returns new line character (&quot;\n&quot;) if the line
+     * argument is true. If it is false the
+     * tab character (&quot;\t&quot;) is returned.
+     */
+    public String getTransferDelimiter(boolean line) {
+        if (line) {
+            return &quot;\n&quot;;
+        }
+        return &quot;\t&quot;;
+    }
+    
+    /**
+     * Used when copying into clipboard. The value
+     * passed to this method is obtained by calling
+     * getValueAt(...). The resulting string is put
+     * into clipboard. The default implementation returns
+     * an empty string (&quot;&quot;) if the value is &lt;code&gt;null&lt;/code&gt;
+     * and value.toString() otherwise. The method
+     * &lt;code&gt; transformValue(value)&lt;/code&gt; is called prior
+     * to the string conversion.
+     */
+    public String convertValueToString(Object value) {
+        value = transformValue(value);
+        if (value == null) {
+            return &quot;&quot;;
+        }
+        return value.toString();
+    }
+    
+    /**
+     * Allow to plug own TableColumn implementation.
+     * This implementation returns ETableColumn.
+     * Called from createDefaultColumnsFromModel().
+     */
+    protected TableColumn createColumn(int modelIndex) {
+        return new ETableColumn(modelIndex, this);
+    }
+   
+    /**
+     * Overriden to use ETableColumnModel as TableColumnModel.
+     * @see javax.swing.JTable#createDefaultColumnModel()
+     */
+    protected TableColumnModel createDefaultColumnModel() {
+        return new ETableColumnModel();
+    }
+
+    /**
+     * Overriden to call convertRowIndexToModel(...).
+     * @see javax.swing.JTable#getValueAt(int, int)
+     */
+    public Object getValueAt(int row, int column) {
+        int modelRow = convertRowIndexToModel(row);
+        return super.getValueAt(modelRow, column);
+    }
+
+    /**
+     * Overriden to call convertRowIndexToModel(...).
+     * @see javax.swing.JTable#setValueAt(Object, int, int)
+     */
+    public void setValueAt(Object aValue, int row, int column) {
+        int modelRow = convertRowIndexToModel(row);
+        super.setValueAt(aValue, modelRow, column);
+    }
+
+    /**
+     * If the quick-filter is applied the number of rows do not
+     * match the number of rows in the model.
+     */
+    public int getRowCount() {
+        if ((quickFilterColumn != -1) &amp;&amp; (quickFilterObject != null)) {
+            if (filteredRowCount == -1) {
+                computeFilteredRowCount();
+            }
+            return filteredRowCount;
+        }
+        return super.getRowCount();
+    }
+
+    /**
+     * Makes the table disply only the rows that match the given &quot;quick-filter&quot;.
+     * Filtering is done according to values from column with index column and
+     * according to filterObject. There are 2 possibilities for the filterObject
+     * paramterer
+     * &lt;OL&gt; &lt;LI&gt; filterObject implements &lt;strong&gt;QuickFilter&lt;/strong&gt; 
+     *           interface: the method &lt;code&gt;accept(Object)&lt;/code&gt; 
+     *           of the QuickFilter is called to determine whether the 
+     *           row will be shown&lt;/LI&gt;
+     *      &lt;LI&gt; if filterObject does not implement the interface the value
+     *           is compared using method equals(Object) with the filterObject.
+     *           If they are equal the row will be shown.
+     * &lt;/OL&gt;
+     */
+    public void setQuickFilter(int column, Object filterObject) {
+        quickFilterColumn = column;
+        quickFilterObject = filterObject;
+        sortingPermutation = null;
+        inverseSortingPermutation = null;
+        filteredRowCount = -1; // force to recompute the rowCount
+        super.tableChanged(new TableModelEvent(getModel()));
+    }
+    
+    /**
+     * Makes the table show all the rows, resetting the filter state
+     * (to no filter).
+     */
+    public void unsetQuickFilter() {
+        quickFilterObject = null;
+        quickFilterColumn = -1;
+        filteredRowCount = -1;
+        sortingPermutation = null;
+        inverseSortingPermutation = null;
+        super.tableChanged(new TableModelEvent(getModel()));
+    }
+    
+    /**
+     * Overriden to update the header listeners and also to adjust the
+     * preferred width of the collumns.
+     * @see javax.swing.JTable#setModel(TableModel)
+     */
+    public void setModel(TableModel dataModel) {
+        super.setModel(dataModel);
+        
+        // force recomputation
+        filteredRowCount = -1;
+        sortingPermutation = null;
+        inverseSortingPermutation = null;
+        quickFilterColumn = -1;
+        quickFilterObject = null;
+        
+        updateMouseListener();
+        if (defaultRenderersByColumnClass != null) {
+            updatePreferredWidths();
+        }
+    }
+    
+    /**
+     * Overriden to do additional initialization.
+     * @see javax.swing.JTable#initializeLocalVars()
+     */
+    protected void initializeLocalVars() {
+        super.initializeLocalVars();
+        updatePreferredWidths();
+        setSurrendersFocusOnKeystroke(true);
+        setFocusCycleRoot(true);
+        setFocusTraversalPolicy(new STPolicy());
+        putClientProperty(&quot;terminateEditOnFocusLost&quot;, Boolean.TRUE);
+        putClientProperty(&quot;JTable.autoStartsEdit&quot;, Boolean.FALSE);
+
+        setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
+        Collections.EMPTY_SET);
+        setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
+        Collections.EMPTY_SET);
+        //Next two lines do not work using inputmap/actionmap, but do work
+        //using the older API.  We will process ENTER to skip to next row,
+        //not next cell
+        unregisterKeyboardAction(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0));
+        unregisterKeyboardAction(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, Event.SHIFT_MASK));
+
+        InputMap imp = getInputMap(WHEN_FOCUSED);
+        InputMap imp2 = getInputMap(WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
+        ActionMap am = getActionMap();
+        
+        //Issue 37919, reinstate support for up/down cycle focus transfer.
+        //being focus cycle root mangles this in some dialogs
+        imp.put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB,
+            KeyEvent.CTRL_MASK | KeyEvent.SHIFT_MASK, false), ACTION_FOCUS_NEXT);
+        imp.put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB,
+            KeyEvent.CTRL_MASK, false), ACTION_FOCUS_NEXT);
+        
+        Action ctrlTab = new CTRLTabAction();
+        am.put(ACTION_FOCUS_NEXT, ctrlTab);
+        
+        
+        imp.put(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0,
+        false), &quot;beginEdit&quot;);
+        getActionMap().put(&quot;beginEdit&quot;, new EditAction());
+        
+        imp.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0,
+        false), &quot;cancelEdit&quot;);
+        getActionMap().put(&quot;cancelEdit&quot;, new CancelEditAction());
+        
+        imp.put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0,
+        false), &quot;enter&quot;);
+        getActionMap().put(&quot;enter&quot;, new EnterAction());
+        
+        imp.put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB, 0), &quot;next&quot;);
+        
+        imp.put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB,
+            KeyEvent.SHIFT_DOWN_MASK), &quot;previous&quot;);
+        
+        am.put(&quot;next&quot;, new NavigationAction(true));
+        am.put(&quot;previous&quot;, new NavigationAction(false));
+        
+        setTransferHandler(new ETableTransferHandler());
+    }
+    
+    /**
+     * Overriden to implement CTRL-+ for resizing of all columns,
+     * CTRL-- for clearing the quick filter and CTRL-* for invoking the
+     * column selection dialog.
+     * @see javax.swing.JTable#processKeyBinding(KeyStroke, KeyEvent, int, boolean)
+     */
+    protected boolean processKeyBinding(KeyStroke ks, KeyEvent e,
+					int condition, boolean pressed) {
+        // This is here because the standard way using input map and action map
+        // did not work since the event was &quot;eaten&quot; by the code in JTable that
+        // forwards it to the CellEditor (the code resides in the
+        // super.processKeyBinding method).
+        if (pressed) {
+            if (e.getKeyChar() == '+' &amp;&amp; ( (e.getModifiers() &amp; InputEvent.CTRL_MASK) == InputEvent.CTRL_MASK)) {
+                updatePreferredWidths();
+                e.consume();
+                return true;
+            }
+            if (e.getKeyChar() == '-' &amp;&amp; ( (e.getModifiers() &amp; InputEvent.CTRL_MASK) == InputEvent.CTRL_MASK)) {
+                unsetQuickFilter();
+                e.consume();
+                return true;
+            }
+            if (e.getKeyChar() == '*' &amp;&amp; ( (e.getModifiers() &amp; InputEvent.CTRL_MASK) == InputEvent.CTRL_MASK)) {
+                showColumnSelectionDialog();
+                e.consume();
+                return true;
+            }
+        }
+	boolean retValue = super.processKeyBinding(ks, e, condition, pressed);
+        return retValue;
+    }
+    
+    /**
+     * Make the column sorted. Value of columnIndex is in the model coordinates.
+     * &lt;strong&gt;Be carefull&lt;/strong&gt; with the columnIndes parameter: again, it
+     * is in the &lt;strong&gt;model&lt;/strong&gt; coordinates.
+     */
+    public void setColumnSorted(int columnIndex, boolean ascending, int rank) {
+        int ii = convertColumnIndexToView(columnIndex);
+        if (ii &lt; 0) {
+            return;
+        }
+        TableColumnModel tcm = getColumnModel();
+        if (tcm instanceof ETableColumnModel) {
+            ETableColumnModel etcm = (ETableColumnModel)tcm;
+            TableColumn tc = tcm.getColumn(ii);
+            if (tc instanceof ETableColumn) {
+                ETableColumn etc = (ETableColumn)tc;
+                if (! etc.isSortingAllowed()) {
+                    return;
+                }
+                int wasSelectedRows[] = getSelectedRowsInModel();
+                int wasSelectedColumn = getSelectedColumn();
+                etcm.setColumnSorted(etc, ascending, rank);
+                sortingPermutation = null;
+                inverseSortingPermutation = null;
+                ETable.super.tableChanged(new TableModelEvent(getModel(), 0, getRowCount()));
+                if (wasSelectedRows.length &gt; 0) {
+                    changeSelectionInModel(wasSelectedRows, wasSelectedColumn);
+                }
+
+            }
+        }
+    }
+    
+    /**
+     * Overriden to install special button into the upper right hand corner.
+     * @see javax.swing.JTable#configureEnclosingScrollPane()
+     */
+    protected void configureEnclosingScrollPane() {
+        super.configureEnclosingScrollPane();
+        
+        if (isFullyNonEditable()) {
+            setupSearch();
+        }
+        
+        Container p = getParent();
+        if (p instanceof JViewport) {
+            Container gp = p.getParent();
+            if (gp instanceof JScrollPane) {
+                JScrollPane scrollPane = (JScrollPane)gp;
+                // Make certain we are the viewPort's view and not, for
+                // example, the rowHeaderView of the scrollPane -
+                // an implementor of fixed columns might do this.
+                JViewport viewport = scrollPane.getViewport();
+                if (viewport == null || viewport.getView() != this) {
+                    return;
+                }
+                Icon ii = UIManager.getIcon(&quot;Table.columnSelection&quot;);
+                if (ii == null) {
+                    ii = new ImageIcon(ETable.class.getResource(DEFAULT_COLUMNS_ICON));
+                }
+                final JButton b = new JButton(ii);
+                b.setToolTipText(selectVisibleColumnsLabel);
+                b.addActionListener(new ActionListener() {
+                    public void actionPerformed(ActionEvent evt) {
+                        showColumnSelectionPopup(b);
+                    }
+                });
+                b.addMouseListener(new MouseAdapter() {
+                    public void mouseClicked(MouseEvent me) {
+                        if (me.getButton() == MouseEvent.BUTTON3) {
+                            showColumnSelectionDialog();
+                        }
+                    }
+                });
+                b.setFocusable(false);
+                scrollPane.setCorner(JScrollPane.UPPER_RIGHT_CORNER, b);
+            }
+        }
+        updateColumnSelectionMouseListener();
+    }
+    
+    /**
+     * Convert indices of selected rows to model.
+     */
+    private int[] getSelectedRowsInModel() {
+        int inView[] = getSelectedRows();
+        int result[] = new int[inView.length];
+        for (int i = 0; i &lt; inView.length; i++) {
+            result[i] = convertRowIndexToModel(inView[i]);
+        }
+        return result;
+    }
+    
+    /**
+     * Selects given rows (the rows coordinates are the model's space).
+     */
+    private void changeSelectionInModel(int selectedRows[], int selectedColumn) {
+        boolean wasAutoScroll = getAutoscrolls();
+        setAutoscrolls(false);
+        ListSelectionModel rsm = getSelectionModel();
+        rsm.setValueIsAdjusting(true);
+        ListSelectionModel csm = getColumnModel().getSelectionModel();
+        csm.setValueIsAdjusting(true);
+        for (int i = 0; i &lt; selectedRows.length; i++) {
+            if ((selectedRows[i] &lt; 0) || (selectedRows[i] &gt;= getModel().getRowCount())) {
+                continue;
+            }
+            int viewIndex = convertRowIndexToView(selectedRows[i]);
+            if ((viewIndex &gt;= 0) &amp;&amp; (viewIndex &lt; getRowCount())) {
+                changeSelection(viewIndex, selectedColumn, true, false );
+            }
+        }
+        rsm.setValueIsAdjusting(false);
+        csm.setValueIsAdjusting(false);
+        if (wasAutoScroll) {
+            setAutoscrolls(true);
+        }
+    }
+    
+    /**
+     * Shows the popup allowing to show/hide columns.
+     */
+    private void showColumnSelectionPopup(Component c) {
+        JPopupMenu popup = new JPopupMenu();
+        TableColumnModel columnModel = getColumnModel();
+        if (! (columnModel instanceof ETableColumnModel)) {
+            return;
+        }
+        final ETableColumnModel etcm = (ETableColumnModel)columnModel;
+        List columns = Collections.list(etcm.getColumns());
+        columns.addAll(etcm.hiddenColumns);
+        Collections.sort(columns);
+        Map displayNameToCheckBox = new HashMap();
+        ArrayList displayNames = new ArrayList();
+        for (Iterator it = columns.iterator(); it.hasNext(); ) {
+            final ETableColumn etc = (ETableColumn)it.next();
+            final JCheckBoxMenuItem checkBox = new JCheckBoxMenuItem();
+            String dName = getColumnDisplayName(etc.getHeaderValue().toString());
+            checkBox.setText(dName);
+            checkBox.setSelected(! etcm.isColumnHidden(etc));
+            checkBox.setEnabled(etc.isHidingAllowed());
+            checkBox.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent evt) {
+                    etcm.setColumnHidden(etc,! checkBox.isSelected());
+                    updateColumnSelectionMouseListener();
+                }
+            });
+            if (! displayNames.contains(dName)) {
+                // the expected case
+                displayNameToCheckBox.put(dName, checkBox);
+            } else {
+                // the same display name is used for more columns - fuj
+                ArrayList al = null;
+                Object theFirstOne = displayNameToCheckBox.get(dName);
+                if (theFirstOne instanceof JCheckBoxMenuItem) {
+                    JCheckBoxMenuItem firstCheckBox = (JCheckBoxMenuItem)theFirstOne;
+                    al = new ArrayList();
+                    al.add(firstCheckBox);
+                } else {
+                    // already a list there
+                    if (theFirstOne instanceof ArrayList) {
+                        al = (ArrayList)theFirstOne;
+                    } else {
+                        throw new IllegalStateException(&quot;Wrong object theFirstOne is &quot; + theFirstOne);
+                    }
+                }
+                al.add(checkBox);
+                displayNameToCheckBox.put(dName, al);
+            }
+            displayNames.add(dName);
+        }
+        Collections.sort(displayNames, Collator.getInstance());
+        int index = 0;
+        for (Iterator it = displayNames.iterator(); it.hasNext(); ) {
+            String displayName = (String)it.next();
+            Object obj = displayNameToCheckBox.get(displayName);
+            JCheckBoxMenuItem checkBox = null;
+            if (obj instanceof JCheckBoxMenuItem) {
+                checkBox = (JCheckBoxMenuItem)obj;
+            } else {
+                // in case there are duplicate names we store ArrayLists
+                // of JCheckBoxes
+                if (obj instanceof ArrayList) {
+                    ArrayList al = (ArrayList)obj;
+                    if (index &gt;= al.size()) {
+                        index = 0;
+                    }
+                    checkBox = (JCheckBoxMenuItem)al.get(index++);
+                } else {
+                    throw new IllegalStateException(&quot;Wrong object obj is &quot; + obj);
+                }
+            }
+            popup.add(checkBox);
+        }
+        popup.show(c, 8, 8);
+    }
+
+    /**
+     * This method update mouse listener on the scrollPane if it is needed.
+     * It also recomputes the model of searchCombo. Both actions are needed after
+     * the set of visible columns is changed.
+     */
+    private void updateColumnSelectionMouseListener() {
+        Container p = getParent();
+        if (p instanceof JViewport) {
+            Container gp = p.getParent();
+            if (gp instanceof JScrollPane) {
+                JScrollPane scrollPane = (JScrollPane)gp;
+                // Make certain we are the viewPort's view and not, for
+                // example, the rowHeaderView of the scrollPane -
+                // an implementor of fixed columns might do this.
+                JViewport viewport = scrollPane.getViewport();
+                if (viewport == null || viewport.getView() != this) {
+                    return;
+                }
+                scrollPane.removeMouseListener(columnSelectionMouseListener);
+                if (getColumnModel().getColumnCount() == 0) {
+                    scrollPane.addMouseListener(columnSelectionMouseListener);
+                }
+            }
+        }
+        if (searchCombo != null) {
+            searchCombo.setModel(getSearchComboModel());
+        }
+    }
+    
+    /**
+     * If the table data model is changed we reset (and then recompute)
+     * the sorting permutation and the row count. The selection is restored
+     * when needed.
+     */
+    public void tableChanged(TableModelEvent e) {
+        boolean needsTotalRefresh = true;
+        if (e == null || e.getFirstRow() == TableModelEvent.HEADER_ROW) {
+            sortingPermutation = null;
+            inverseSortingPermutation = null;
+            filteredRowCount = -1;
+            super.tableChanged(e);
+            return;
+        }
+
+        if (e.getType() == TableModelEvent.INSERT) {
+            int wasSelectedRows[] = getSelectedRowsInModel();
+            int wasSelectedColumn = getSelectedColumn();
+            clearSelection();
+            sortingPermutation = null;
+            inverseSortingPermutation = null;
+            filteredRowCount = -1;
+            super.tableChanged(e);
+            if (wasSelectedRows.length &gt; 0) {
+                int first = e.getFirstRow();
+                int count = e.getLastRow() - e.getFirstRow() + 1;
+                if (count &gt;= 0) {
+                    for (int i = 0; i &lt; wasSelectedRows.length; i++) {
+                        if (wasSelectedRows[i] &gt;= first) {
+                            wasSelectedRows[i] += count;
+                        }
+                    }
+                }
+                changeSelectionInModel(wasSelectedRows, wasSelectedColumn);
+            }
+            return;
+        }
+
+        if (e.getType() == TableModelEvent.DELETE) {
+            int wasSelectedRows[] = getSelectedRowsInModel();
+            int wasSelectedColumn = getSelectedColumn();
+            clearSelection();
+            sortingPermutation = null;
+            inverseSortingPermutation = null;
+            filteredRowCount = -1;
+            super.tableChanged(e);
+            if (wasSelectedRows.length &gt; 0) {
+                int first = e.getFirstRow();
+                int count = e.getLastRow() - e.getFirstRow() + 1;
+                int last = e.getLastRow();
+                if (count &gt;= 0) {
+                    for (int i = 0; i &lt; wasSelectedRows.length; i++) {
+                        if (wasSelectedRows[i] &gt;= first) {
+                            if (wasSelectedRows[i] &lt;= last) {
+                                wasSelectedRows[i] = -1;
+                            } else {
+                                wasSelectedRows[i] -= count;
+                            }
+                        }
+                    }
+                }
+                changeSelectionInModel(wasSelectedRows, wasSelectedColumn);
+            }
+            return;
+        }
+
+        int modelColumn = e.getColumn();
+        int start = e.getFirstRow();
+        int end = e.getLastRow();
+
+        if (modelColumn != TableModelEvent.ALL_COLUMNS) {
+            Enumeration enumeration = getColumnModel().getColumns();
+            TableColumn aColumn;
+            int index = 0;
+            while (enumeration.hasMoreElements()) {
+                aColumn = (TableColumn)enumeration.nextElement();
+                if (aColumn.getModelIndex() == modelColumn) {
+                    ETableColumn etc = (ETableColumn)aColumn;
+                    if ((! etc.isSorted()) &amp;&amp; (quickFilterColumn != modelColumn)){
+                        needsTotalRefresh = false;
+                    }
+                }
+            }
+        }
+        if (needsTotalRefresh) { // update the whole table
+            int wasSelectedRows[] = getSelectedRowsInModel();
+            int wasSelectedColumn = getSelectedColumn();
+        
+            sortingPermutation = null;
+            inverseSortingPermutation = null;
+            filteredRowCount = -1;
+            super.tableChanged(new TableModelEvent(getModel()));
+            if (wasSelectedRows.length &gt; 0) {
+                changeSelectionInModel(wasSelectedRows, wasSelectedColumn);
+            }
+        } else { // update only one column
+            TableModelEvent tme = new TableModelEvent(
+                (TableModel)e.getSource(), 
+                0, getModel().getRowCount(), modelColumn);
+            super.tableChanged(tme);
+        }
+    }
+
+    /**
+     * When the user clicks the header this method returns either
+     * the column that should be resized or null.
+     */
+    private TableColumn getResizingColumn(Point p) {
+        JTableHeader header = getTableHeader();
+        if (header == null) {
+            return null;
+        }
+        int column = header.columnAtPoint(p);
+        if (column == -1) {
+            return null;
+        }
+        Rectangle r = header.getHeaderRect(column);
+        r.grow(-3, 0);
+        if (r.contains(p)) {
+            return null;
+        }
+        int midPoint = r.x + r.width/2;
+        int columnIndex;
+        if( header.getComponentOrientation().isLeftToRight() ) {
+            columnIndex = (p.x &lt; midPoint) ? column - 1 : column;
+        } else {
+            columnIndex = (p.x &lt; midPoint) ? column : column - 1;
+        }
+        if (columnIndex == -1) {
+            return null;
+        }
+        return header.getColumnModel().getColumn(columnIndex);
+    }
+
+    /**
+     * Adds mouse listener to the header for sorting and auto-sizing
+     * of the columns.
+     */
+    private void updateMouseListener() {
+        JTableHeader jth = getTableHeader();
+        if (jth != null) {
+            jth.removeMouseListener(headerMouseListener); // not to add it twice
+            jth.addMouseListener(headerMouseListener);
+        }
+    }
+    
+    /**
+     * Updates the value of filteredRowCount variable.
+     */
+    private void computeFilteredRowCount() {
+        if ((quickFilterColumn == -1) || (quickFilterObject == null) ) {
+            filteredRowCount = -1;
+            return;
+        }
+        if (sortingPermutation != null) {
+            filteredRowCount = sortingPermutation.length;
+            return;
+        }
+        sortAndFilter();
+        if (sortingPermutation != null) {
+            filteredRowCount = sortingPermutation.length;
+        }
+    }
+    
+    /**
+     * Helper method converting the row index according to the active sorting
+     * columns.
+     */
+    public int convertRowIndexToModel(int row) {
+        if (sortingPermutation == null) {
+            sortAndFilter();
+        }
+        if (sortingPermutation != null) {
+            if ((row &gt;= 0) &amp;&amp; (row &lt; sortingPermutation.length)) {
+                return sortingPermutation[row];
+            }
+            return -1;
+        }
+        return row;
+    }
+    
+    /**
+     * Helper method converting the row index according to the active sorting
+     * columns.
+     */
+    public int convertRowIndexToView(int row) {
+        if (inverseSortingPermutation == null) {
+            sortAndFilter();
+        }
+        if (inverseSortingPermutation != null) {
+            if ((row &gt;= 0) &amp;&amp; (row &lt; inverseSortingPermutation.length)) {
+                return inverseSortingPermutation[row];
+            }
+            return -1;
+        }
+        return row;
+    }
+    
+    /**
+     * Allows customization of the text appearing in the column
+     * customization dialog.
+     */
+    public void setSelectVisibleColumnsLabel(String localizedLabel) {
+        selectVisibleColumnsLabel = localizedLabel;
+    }
+    
+    /**
+     * Replaces the quickFilterFormatStrings by the given array. The
+     * new array must have the same length as the old one.
+     */
+    public void setQuickFilterFormatStrings(String []newFormats) {
+        if ((newFormats == null) || (newFormats.length != quickFilterFormatStrings.length)) {
+            return;
+        }
+        quickFilterFormatStrings = newFormats;
+    }
+
+    /**
+     * Allows subclasses to localize the column headers. This method
+     * is called by the header renderer. The default implementation just
+     * returns passed in columnName.
+     */
+    public String getColumnDisplayName(String columnName) {
+        return columnName;
+    }
+    
+    /**
+     * Allows subclasses to transform the value (usually obtained by calling
+     * getValueAt(...)) to another object that is used for
+     * sorting, comparison via quick filters etc. The default implementation
+     * just returns the original value.
+     */
+    public Object transformValue(Object value) {
+        return value;
+    }
+    
+    /**
+     * Creates a menu item usable in a popup that will trigger
+     * QuickFilter functionality for given column and value of the
+     * cell it was invoked on (returned from 
+     * transformValue(getValueAt(column, row))).&lt;p&gt; &lt;strong&gt;Note:&lt;/strong&gt; do not
+     * forget to call transformValue before passing the value to this method
+     * otherwise the quickfilters will not work.&lt;p&gt;
+     * The label should be localized version of the string the user will
+     * see in the popup menu, e.g. &quot;Filter Column&quot;.
+     */
+    public JMenuItem getQuickFilterPopup(int column, Object value, String label) {
+        JMenu menu = new JMenu(label);
+        String columnDisplayName = getColumnDisplayName(getColumnName(column));
+        JMenuItem equalsItem = getQuickFilterEqualsItem(column, value, 
+                columnDisplayName, quickFilterFormatStrings[0], true);
+        menu.add(equalsItem);
+        JMenuItem notequalsItem = getQuickFilterEqualsItem(column, value, 
+                columnDisplayName, quickFilterFormatStrings[1], false);
+        menu.add(notequalsItem);
+        JMenuItem greaterItem = getQuickFilterCompareItem(column, value, 
+                columnDisplayName, quickFilterFormatStrings[2], true, false);
+        menu.add(greaterItem);
+        JMenuItem lessItem = getQuickFilterCompareItem(column, value, 
+                columnDisplayName, quickFilterFormatStrings[3], false, false);
+        menu.add(lessItem);
+        JMenuItem greaterEqualsItem = getQuickFilterCompareItem(column, value,
+                columnDisplayName, quickFilterFormatStrings[4], true, true);
+        menu.add(greaterEqualsItem);
+        JMenuItem lessEqualsItem = getQuickFilterCompareItem(column, value,
+                columnDisplayName, quickFilterFormatStrings[5], false, true);
+        menu.add(lessEqualsItem);
+        JMenuItem noFilterItem = getQuickFilterNoFilterItem(quickFilterFormatStrings[6]);
+        menu.add(noFilterItem);
+        return menu;
+    }
+
+    /**
+     * Creates the menu item for setting the quick filter that filters
+     * the objects using equality (or non-equality).
+     */
+    public JMenuItem getQuickFilterEqualsItem(final int column, Object value,
+            String columnName, String text, boolean equals) {
+        
+        String s = MessageFormat.format(text, new Object[] { columnName, value});
+        JMenuItem res = new JMenuItem(s);
+        res.addActionListener(new EqualsQuickFilter(column, value, equals));
+        return res;
+    }
+    
+    /**
+     * Private implementation of the equality quick filter.
+     */
+    private class EqualsQuickFilter implements ActionListener, QuickFilter {
+        private int column;
+        private Object value;
+        private boolean equals;
+        public EqualsQuickFilter(int column, Object value, boolean equals) {
+            this.column = column;
+            this.value = value;
+            this.equals = equals;
+        }
+        public boolean accept(Object aValue) {
+            if ((value == null) &amp;&amp; (aValue == null)) {
+                return equals;
+            }
+            if ((value == null) || (aValue == null)) {
+                return ! equals;
+            }
+            if (equals) {
+                return value.equals(aValue);
+            } else {
+                return ! value.equals(aValue);
+            }
+        }
+
+        public void actionPerformed(ActionEvent actionEvent) {
+            setQuickFilter(column, this);
+        }
+    }
+    
+    /**
+     * Creates the menu item for resetting the quick filter (to no filter).
+     */
+    public JMenuItem getQuickFilterNoFilterItem(String label) {
+        JMenuItem res = new JMenuItem(label);
+        res.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent actionEvent) {
+                unsetQuickFilter();
+            }
+        });
+        return res;
+    }
+    
+    /**
+     * Creates the menu item for setting the quick filter that filters
+     * the objects using Comparable interface.
+     */
+    public JMenuItem getQuickFilterCompareItem(
+            final int column, Object value, String columnName, 
+            String text, boolean greater, boolean equalsCounts) {
+        
+        String s = MessageFormat.format(text, new Object[] { columnName, value});
+        JMenuItem res = new JMenuItem(s);
+        res.addActionListener(new CompareQuickFilter(column, value, greater, equalsCounts));
+        return res;
+    }
+    
+    /**
+     * Private quick filter implementation using Comparable interface.
+     */
+    private class CompareQuickFilter implements ActionListener, QuickFilter {
+        private int column;
+        private Object value;
+        private boolean greater;
+        private boolean equalsCounts;
+        public CompareQuickFilter(int column, Object value, boolean greater, boolean equalsCounts) {
+            this.column = column;
+            this.value = value;
+            this.greater = greater;
+            this.equalsCounts = equalsCounts;
+        }
+        public boolean accept(Object aValue) {
+            if (equalsCounts) {
+                if (greater) {
+                    return doCompare(value, aValue) &lt;= 0;
+                } else {
+                    return doCompare(value, aValue) &gt;= 0;
+                }
+            } else {
+                if (greater) {
+                    return doCompare(value, aValue) &lt; 0;
+                } else {
+                    return doCompare(value, aValue) &gt; 0;
+                }
+            }
+        }
+
+        private int doCompare(Object obj1, Object obj2) {
+            if (obj1 == null &amp;&amp; obj2 == null) {
+                return 0;
+            }
+            if (obj1 == null) {
+                return -1;
+            }
+            if (obj2 == null) {
+                return 1;
+            }
+            if ((obj1 instanceof Comparable) &amp;&amp; (obj1.getClass().isAssignableFrom(obj2.getClass()))){
+                Comparable c1 = (Comparable) obj1;
+                return c1.compareTo(obj2);
+            }
+            return obj1.toString().compareTo(obj2.toString());
+        }
+        
+        public void actionPerformed(ActionEvent actionEvent) {
+            setQuickFilter(column, this);
+        }
+    }
+    
+    /**
+     * Sorts the rows of the table.
+     */
+    private void sortAndFilter() {
+        TableColumnModel tcm = getColumnModel();
+        if (tcm instanceof ETableColumnModel) {
+            ETableColumnModel etcm = (ETableColumnModel) tcm;
+            Comparator c = etcm.getComparator();
+            if (c != null) {
+                TableModel model = getModel();
+                int noRows = model.getRowCount();
+                List rows = new ArrayList();
+                for (int i = 0; i &lt; noRows; i++) {
+                    if (acceptByQuickFilter(model, i)) {
+                        rows.add(new RowMapping(i, model));
+                    }
+                }
+                Collections.sort(rows, c);
+                int [] res = new int[rows.size()];
+                int [] invRes = new int[noRows]; // carefull - this one is bigger!
+                for (int i = 0; i &lt; res.length; i++) {
+                    RowMapping rm = (RowMapping) rows.get(i);
+                    int rmi = rm.getModelRowIndex();
+                    res[i] = rmi;
+                    invRes[rmi] = i;
+                }
+                sortingPermutation = res;
+                inverseSortingPermutation = invRes;
+            }
+        }
+    }
+    
+    /**
+     * Determines whether the given row should be displayed or not.
+     */
+    private boolean acceptByQuickFilter(TableModel model, int row) {
+        if ((quickFilterColumn == -1) || (quickFilterObject == null) ) {
+            return true;
+        }
+        Object value = model.getValueAt(row, quickFilterColumn);
+        value = transformValue(value);
+        if (quickFilterObject instanceof QuickFilter) {
+            QuickFilter filter = (QuickFilter) quickFilterObject;
+            return filter.accept(value);
+        }
+        if (value == null) {
+            return false;
+        }
+        // fallback test for equality with the filter object
+        return value.equals(quickFilterObject);
+    }
+    
+    /**
+     * Compute the preferredVidths of all columns.
+     */
+    void updatePreferredWidths() {
+        Enumeration en = getColumnModel().getColumns();
+        while (en.hasMoreElements()) {
+            Object obj = en.nextElement();
+            if (obj instanceof ETableColumn) {
+                ETableColumn etc = (ETableColumn) obj;
+                etc.updatePreferredWidth(this, false);
+            }
+        }
+    }
+  
+    /**
+     * Method allowing to read stored values.
+     * The stored values should be only those that the user has customized,
+     * it does not make sense to store the values that were set using 
+     * the initialization code because the initialization code can be run
+     * in the same way after restart.
+     */
+    public void readSettings(Properties p, String propertyPrefix) {
+        ETableColumnModel etcm = (ETableColumnModel)createDefaultColumnModel();
+        etcm.readSettings(p, propertyPrefix, this);
+        setColumnModel(etcm);
+        
+        String scs = p.getProperty(propertyPrefix + SEARCH_COLUMN);
+        if (scs != null) {
+            try {
+                int index = Integer.parseInt(scs);
+                for (int i = 0; i &lt; etcm.getColumnCount(); i++) {
+                    TableColumn tc = etcm.getColumn(i);
+                    if (tc.getModelIndex() == index) {
+                        searchColumn = (ETableColumn)tc;
+                        break;
+                    }
+                }
+            } catch (NumberFormatException nfe) {
+                nfe.printStackTrace();
+            }
+        }
+        filteredRowCount = -1;
+        sortingPermutation = null;
+        inverseSortingPermutation = null;
+        super.tableChanged(new TableModelEvent(getModel()));
+    }
+
+    /**
+     * Method allowing to store customization values.
+     * The stored values should be only those that the user has customized,
+     * it does not make sense to store the values that were set using 
+     * the initialization code because the initialization code can be run
+     * in the same way after restart.
+     */
+    public void writeSettings(Properties p, String propertyPrefix) {
+        TableColumnModel tcm = getColumnModel();
+        if (tcm instanceof ETableColumnModel) {
+            ETableColumnModel etcm = (ETableColumnModel) tcm;
+            etcm.writeSettings(p, propertyPrefix);
+        }
+        if (searchColumn != null) {
+            p.setProperty(
+                propertyPrefix + SEARCH_COLUMN,
+                Integer.toString(searchColumn.getModelIndex()));
+        }
+    }
+    
+    /** searchTextField manages focus because it handles VK_TAB key */
+    private class SearchTextField extends JTextField {
+        public boolean isManagingFocus() {
+            return true;
+        }
+        
+        public void processKeyEvent(KeyEvent ke) {
+            //override the default handling so that
+            //the parent will never receive the escape key and
+            //close a modal dialog
+            if (ke.getKeyCode() == ke.VK_ESCAPE) {
+                removeSearchField();
+                // bugfix #32909, reqest focus when search field is removed
+                SwingUtilities.invokeLater(new Runnable() {
+                    //additional bugfix - do focus change later or removing
+                    //the component while it's focused will cause focus to
+                    //get transferred to the next component in the
+                    //parent focusTraversalPolicy *after* our request
+                    //focus completes, so focus goes into a black hole - Tim
+                    public void run() {
+                        ETable.this.requestFocus();
+                    }
+                });
+            } else {
+                super.processKeyEvent(ke);
+            }
+        }
+    }
+
+    /**
+     * Searches the rows by comparing the values with the given prefix.
+     */
+    private List doSearch(String prefix) {
+        List results = new ArrayList();
+        
+        int startIndex = 0;
+        int size = getRowCount();
+        if ( (size == 0) || (getColumnCount() == 0)) {
+            // Empty table; cannot match anything.
+            return results;
+        }
+        
+        int column = 0;
+        if (searchColumn != null) {
+            column = convertColumnIndexToView(searchColumn.getModelIndex());
+        }
+        if (column &lt; 0) {
+            // wrong column
+            return results;
+        }
+        while (startIndex &lt; size) {
+            Object val = getValueAt(startIndex, column);
+            String s = null;
+            if (val != null) {
+                s = convertValueToString(val);
+            }   
+            if ((s != null) &amp;&amp; (s.toUpperCase().startsWith(prefix.toUpperCase()))) {
+                results.add(new Integer(startIndex));
+            
+                // initialize prefix
+                if (maxPrefix == null) {
+                    maxPrefix = s;
+                }
+
+                maxPrefix = findMaxPrefix(maxPrefix, s);
+            }
+            
+            startIndex++;
+        }
+        return results;
+    }
+    
+    /**
+     * Finds maximum common prefix of 2 strings.
+     */
+    private static String findMaxPrefix(String str1, String str2) {
+        int i = 0;
+        while (str1.regionMatches(true, 0, str2, 0, i)) {
+            i++;
+        }
+        i--;
+        if (i &gt;= 0) {
+            return str1.substring(0, i);    
+        }
+        return null;
+    }
+
+    /**
+     * Shows the search text field.
+     */
+    private void setupSearch() {
+        // Remove the default key listeners
+        KeyListener keyListeners[] = (KeyListener[]) (getListeners(KeyListener.class));
+        for (int i = 0; i &lt; keyListeners.length; i++) {
+            removeKeyListener(keyListeners[i]);
+        }
+        // Add new key listeners
+        addKeyListener(new KeyAdapter() {
+            private boolean armed = false;
+            public void keyPressed(KeyEvent e) {
+                int modifiers = e.getModifiers();
+                int keyCode = e.getKeyCode();
+                if ((modifiers &gt; 0 &amp;&amp; modifiers != KeyEvent.SHIFT_MASK) || e.isActionKey())
+                    return ;
+                char c = e.getKeyChar();
+                if (!Character.isISOControl(c) &amp;&amp; keyCode != KeyEvent.VK_SHIFT &amp;&amp; keyCode != KeyEvent.VK_ESCAPE) {
+                    armed = true;
+                    e.consume();
+                }
+            }
+            public void keyTyped(KeyEvent e) {
+                if (armed) {
+                    final KeyStroke stroke = KeyStroke.getKeyStrokeForEvent(e);
+                    searchTextField.setText(String.valueOf(stroke.getKeyChar()));
+                    
+                    displaySearchField();
+                    e.consume();
+                    armed = false;
+                }
+            }
+        });
+        // Create a the &quot;multi-event&quot; listener for the text field. Instead of
+        // adding separate instances of each needed listener, we're using a
+        // class which implements them all. This approach is used in order
+        // to avoid the creation of 4 instances which takes some time
+        SearchFieldListener searchFieldListener = new SearchFieldListener();
+        searchTextField.addKeyListener(searchFieldListener);
+        searchTextField.addFocusListener(searchFieldListener);
+        searchTextField.getDocument().addDocumentListener(searchFieldListener);
+    }
+
+    /**
+     * Listener showing and operating the search box.
+     */
+    private class SearchFieldListener extends KeyAdapter
+            implements DocumentListener, FocusListener {
+        
+        /** The last search results */
+        private List results = new ArrayList();
+        /** The last selected index from the search results. */
+        private int currentSelectionIndex;
+        
+        /**
+         * Default constructor.
+         */
+        SearchFieldListener() {
+        }
+        
+        public void changedUpdate(DocumentEvent e) {
+            searchForRow();
+        }
+        
+        public void insertUpdate(DocumentEvent e) {
+            searchForRow();
+        }
+        
+        public void removeUpdate(DocumentEvent e) {
+            searchForRow();
+        }
+        
+        public void keyPressed(KeyEvent e) {
+            int keyCode = e.getKeyCode();
+            if (keyCode == KeyEvent.VK_ESCAPE) {
+                removeSearchField();
+                ETable.this.requestFocus();
+            } else if (keyCode == KeyEvent.VK_UP) {
+                currentSelectionIndex--;
+                displaySearchResult();
+                // Stop processing the event here. Otherwise it's dispatched
+                // to the table too (which scrolls)
+                e.consume();
+            } else if (keyCode == KeyEvent.VK_DOWN) {
+                currentSelectionIndex++;
+                displaySearchResult();
+                // Stop processing the event here. Otherwise it's dispatched
+                // to the table too (which scrolls)
+                e.consume();
+            } else if (keyCode == KeyEvent.VK_TAB) {
+                if (maxPrefix != null) {
+                    searchTextField.setText(maxPrefix);
+                }
+                e.consume();
+            } else if (keyCode == KeyEvent.VK_ENTER) {
+                removeSearchField();
+                
+                // TODO: do something on hitting enter???
+                e.consume();
+                ETable.this.requestFocus();
+            }
+        }
+        
+        /** Searches for a row. */
+        private void searchForRow() {
+            currentSelectionIndex = 0;
+            results.clear();
+            maxPrefix = null;
+            String text = searchTextField.getText().toUpperCase();
+            if (text.length() &gt; 0) {
+                results = doSearch(text);
+                // do search forward the selected index
+                int rows[] = getSelectedRows();
+                int selectedRowIndex = (rows == null || rows.length == 0) ? 0 : rows[0];
+                int r = 0;
+                for (Iterator it = results.iterator(); it.hasNext(); r++) {
+                    int curResult = ((Integer)it.next()).intValue();
+                    if (selectedRowIndex &lt;= curResult) {
+                        currentSelectionIndex = r;
+                        break;
+                    }
+                }
+                displaySearchResult();
+            }
+        }
+        
+        private void displaySearchResult() {
+            int sz = results.size();
+            if (sz &gt; 0) {
+                if (currentSelectionIndex &lt; 0) {
+                    currentSelectionIndex = 0;
+                }
+                if (currentSelectionIndex &gt;= sz) {
+                    currentSelectionIndex = sz - 1;
+                }
+                int selRow = ((Integer)results.get(currentSelectionIndex)).intValue();
+                setRowSelectionInterval(selRow, selRow);
+                Rectangle rect = getCellRect(selRow, 0, true);
+                scrollRectToVisible(rect);
+                displaySearchField();
+            } else {
+                clearSelection();
+            }
+        }
+        
+        public void focusGained(FocusEvent e) {
+            // Do nothing
+        }
+        
+        public void focusLost(FocusEvent e) {
+            Component c = e.getOppositeComponent();
+            if (c != searchCombo) {
+                removeSearchField();
+            }
+        }
+    }
+    
+    /**
+     * Listener showing and operating the search box.
+     */
+    private class SearchComboListener extends KeyAdapter
+            implements FocusListener, ItemListener {
+        
+        /**
+         * Default constructor.
+         */
+        SearchComboListener() {
+        }
+        
+        public void itemStateChanged(java.awt.event.ItemEvent itemEvent) {
+            Object selItem = searchCombo.getSelectedItem();
+            for (Enumeration en = getColumnModel().getColumns(); en.hasMoreElements(); ) {
+                Object column = en.nextElement();
+                if (column instanceof ETableColumn) {
+                    ETableColumn etc = (ETableColumn)column;
+                    Object value = etc.getHeaderValue();
+                    String valueString = &quot;&quot;;
+                    if (value != null) {
+                        valueString = value.toString();
+                    }
+                    valueString = getColumnDisplayName(valueString);
+                    if (valueString.equals(selItem)) {
+                        searchColumn = etc;
+                    }
+                }
+            }
+
+            String text = searchTextField.getText();
+            searchTextField.setText(&quot;&quot;);
+            searchTextField.setText(text);
+            searchTextField.requestFocus();
+        }
+        
+        public void keyPressed(KeyEvent e) {
+            int keyCode = e.getKeyCode();
+            if (keyCode == KeyEvent.VK_ESCAPE) {
+                removeSearchField();
+                ETable.this.requestFocus();
+            }
+        }
+        
+        public void focusGained(FocusEvent e) {
+            // Do nothing
+        }
+        
+        public void focusLost(FocusEvent e) {
+            Component c = e.getOppositeComponent();
+            if (c != searchTextField) {
+                removeSearchField();
+            }
+        }
+    }
+    
+    private void prepareSearchPanel() {
+        if (searchPanel == null) {
+            searchPanel = new JPanel();
+            String s = UIManager.getString(&quot;LBL_QUICKSEARCH&quot;);
+            if (s == null) {
+                s = &quot;Quick search in&quot;;
+            }
+            JLabel lbl = new JLabel(s); //NOI18N
+            searchPanel.setLayout (
+                new BoxLayout(searchPanel, BoxLayout.X_AXIS));
+            searchPanel.add (lbl);
+            searchCombo = new JComboBox(getSearchComboModel());
+            
+            if (searchColumn != null) {
+                Object value = searchColumn.getHeaderValue();
+                String valueString = &quot;&quot;;
+                if (value != null) {
+                    valueString = value.toString();
+                }
+                valueString = getColumnDisplayName(valueString);
+                searchCombo.setSelectedItem(valueString);
+            }
+            SearchComboListener scl = new SearchComboListener();
+            searchCombo.addItemListener(scl);
+            searchCombo.addFocusListener(scl);
+            searchCombo.addKeyListener(scl);
+            searchPanel.add(searchCombo);
+            searchPanel.add (searchTextField);
+            lbl.setLabelFor(searchTextField);
+            searchPanel.setBorder (BorderFactory.createRaisedBevelBorder());
+            lbl.setBorder (BorderFactory.createEmptyBorder (0, 0, 0, 5));
+        }
+    }
+    
+    private ComboBoxModel getSearchComboModel() {
+        DefaultComboBoxModel result = new DefaultComboBoxModel();
+        for (Enumeration en = getColumnModel().getColumns(); en.hasMoreElements(); ) {
+            Object column = en.nextElement();
+            if (column instanceof ETableColumn) {
+                ETableColumn etc = (ETableColumn)column;
+                Object value = etc.getHeaderValue();
+                String valueString = &quot;&quot;;
+                if (value != null) {
+                    valueString = value.toString();
+                }
+                valueString = getColumnDisplayName(valueString);
+                result.addElement(valueString);
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Shows the search field.
+     */
+    private void displaySearchField() {
+        if (!searchTextField.isDisplayable()) {
+            searchTextField.setFont(ETable.this.getFont());
+            prepareSearchPanel();
+            add(searchPanel);
+        }
+        doLayout();
+        invalidate();
+        validate();
+        repaint();
+        searchTextField.requestFocus();
+    }
+
+    /**
+     * Overriden to place the search text field.
+     * @see javax.swing.JTable#doLayout()
+     */
+    public void doLayout() {
+        super.doLayout();
+        Rectangle visibleRect = getVisibleRect();
+        if (searchPanel != null &amp;&amp; searchPanel.isDisplayable()) {
+             int width = Math.min (
+                visibleRect.width - SEARCH_FIELD_SPACE * 2,
+                searchPanel.getPreferredSize().width - searchTextField.getPreferredSize().width + 
+                     SEARCH_FIELD_PREFERRED_SIZE - SEARCH_FIELD_SPACE);
+
+             searchPanel.setBounds(
+                Math.max (SEARCH_FIELD_SPACE, 
+                visibleRect.x + visibleRect.width - width),
+                visibleRect.y + SEARCH_FIELD_SPACE,
+                Math.min (visibleRect.width, width) - SEARCH_FIELD_SPACE,
+                heightOfTextField);
+        }
+    }
+    
+    /**
+     * Removes the search field from the table.
+     */
+    private void removeSearchField() {
+        if (searchPanel.isDisplayable()) {
+            remove(searchPanel);
+            Rectangle r = searchPanel.getBounds();
+            this.repaint(r);
+        }
+    }
+    
+    /**
+     * Item to the collection when doing the sorting of table rows.
+     */
+    public final static class RowMapping {
+        // index (of the row) in the TableModel
+        private int originalIndex;
+        // table model of my table
+        private TableModel model;
+        public RowMapping(int index, TableModel model) {
+            originalIndex = index;
+            this.model = model;
+        }
+        public int getModelRowIndex() {
+            return originalIndex;
+        }
+        public Object getModelObject(int column) {
+            return model.getValueAt(originalIndex, column);
+        }
+    }
+    
+    /** 
+     * Comparator for RowMapping objects that sorts according
+     * to the original indices of the rows in the model.
+     */
+    static class OriginalRowComparator implements Comparator {
+        public OriginalRowComparator() {
+        }
+        public int compare(Object o1, Object o2) {
+            RowMapping rm1 = (RowMapping)o1;
+            RowMapping rm2 = (RowMapping)o2;
+            int i1 = rm1.getModelRowIndex();
+            int i2 = rm2.getModelRowIndex();
+            return (i1 &lt; i2 ? -1 : (i1 == i2 ? 0 : 1));
+        }
+    }
+    
+    /**
+     * Shows dialog allowing to show/hide columns.
+     */
+    private void showColumnSelectionDialog() {
+        // right click will open the column visibility dialog
+        ColumnSelectionPanel panel = new ColumnSelectionPanel(getColumnModel(), this);
+        int res = JOptionPane.showConfirmDialog(null, panel, selectVisibleColumnsLabel, JOptionPane.OK_CANCEL_OPTION);
+        if (res == JOptionPane.OK_OPTION) {
+            panel.changeColumnVisibility();
+            updateColumnSelectionMouseListener();
+        }
+    }
+    
+    /**
+     * Mouse listener attached to the JTableHeader of this table. Single
+     * click on the table header should trigger sorting on that column.
+     * Double click on the column divider automatically resizes the column.
+     */
+    private class ColumnSelectionMouseListener extends MouseAdapter {
+        public void mouseClicked(MouseEvent me) {
+            if (me.getButton() == MouseEvent.BUTTON3) {
+                showColumnSelectionDialog();
+            }
+        }
+    }
+    /**
+     * Mouse listener attached to the JTableHeader of this table. Single
+     * click on the table header should trigger sorting on that column.
+     * Double click on the column divider automatically resizes the column.
+     */
+    private class HeaderMouseListener extends MouseAdapter {
+        public void mouseClicked(MouseEvent me) {
+            if (me.getButton() == MouseEvent.BUTTON3) {
+                showColumnSelectionDialog();
+                return;
+            }
+            TableColumn resColumn = getResizingColumn(me.getPoint());
+            if ((resColumn == null) &amp;&amp; (me.getClickCount() == 1)) {
+                // ok, do the sorting
+                int column = columnAtPoint(me.getPoint());
+                TableColumnModel tcm = getColumnModel();
+                if (tcm instanceof ETableColumnModel) {
+                    ETableColumnModel etcm = (ETableColumnModel)tcm;
+                    TableColumn tc = tcm.getColumn(column);
+                    if (tc instanceof ETableColumn) {
+                        ETableColumn etc = (ETableColumn)tc;
+                        if (! etc.isSortingAllowed()) {
+                            return;
+                        }
+                        int wasSelectedRows[] = getSelectedRowsInModel();
+                        int wasSelectedColumn = getSelectedColumn();
+                        clearSelection();
+                        boolean clear = ((me.getModifiers() &amp; InputEvent.SHIFT_MASK) != InputEvent.SHIFT_MASK);
+                        etcm.toggleSortedColumn(etc, clear);
+                        sortingPermutation = null;
+                        inverseSortingPermutation = null;
+                        ETable.super.tableChanged(new TableModelEvent(getModel(), 0, getRowCount()));
+                        if (wasSelectedRows.length &gt; 0) {
+                            changeSelectionInModel(wasSelectedRows, wasSelectedColumn);
+                        }
+                        getTableHeader().resizeAndRepaint();
+                    }
+                }
+            }
+            if ((resColumn != null) &amp;&amp; (me.getClickCount() == 2)) {
+                // update the column width
+                if (resColumn instanceof ETableColumn) {
+                    ETableColumn etc = (ETableColumn)resColumn;
+                    etc.updatePreferredWidth(ETable.this, true);
+                }
+            }
+        }
+    }
+
+    /**
+     * Overriden to force requesting the focus after the user starts editing.
+     * @see javax.swing.JTable#editCellAt(int, int, EventObject)
+     */
+    public boolean editCellAt(int row, int column, EventObject e) {
+        inEditRequest = true;
+        if (editingRow == row &amp;&amp; editingColumn == column &amp;&amp; isEditing()) {
+            //discard edit requests if we're already editing that cell
+            inEditRequest = false;
+            return false;
+        }
+        
+        if (isEditing()) {
+            inEditorChangeRequest = true;
+            try {
+                removeEditor();
+                changeSelection(row, column, false, false);
+            } finally {
+                inEditorChangeRequest = false;
+            }
+        }
+        
+        try {
+            boolean ret = super.editCellAt(row, column, e);
+            if (ret) {
+                editorComp.requestFocus();
+            }
+
+            return ret;
+        } finally {
+            inEditRequest = false;
+        }
+    }
+
+    /**
+     * Overriden to track whether the remove request is in progress.
+     * @see javax.swing.JTable#removeEditor()
+     */
+    public void removeEditor() {
+        inRemoveRequest = true;
+        try {
+            synchronized (getTreeLock()) {
+                super.removeEditor();
+            }
+        } finally {
+            inRemoveRequest = false;
+        }
+    }    
+    
+    /**
+     * Checks whether the given component is &quot;our&quot;.
+     */
+    private boolean isKnownComponent(Component c) {
+        if (c == null) return false;
+        if (isAncestorOf (c)) {
+            return true;
+        }
+        if (c == editorComp) {
+            return true;
+        }
+        if (editorComp != null &amp;&amp; (editorComp instanceof Container) &amp;&amp;
+            ((Container) editorComp).isAncestorOf(c)) {
+                return true;
+        }
+        return false;
+    }
+    
+    /**
+     * Focus transfer policy that retains focus after closing an editor.
+     * Copied wholesale from org.openide.explorer.view.TreeTable.
+     */
+    private class STPolicy extends ContainerOrderFocusTraversalPolicy {
+        
+        public Component getComponentAfter(Container focusCycleRoot,
+        Component aComponent) {
+            
+            if (inRemoveRequest) {
+                return ETable.this;
+            } else {
+                Component result = super.getComponentAfter(focusCycleRoot, aComponent);
+                return result;
+            }
+        }
+        
+        public Component getComponentBefore(Container focusCycleRoot,
+        Component aComponent) {
+            if (inRemoveRequest) {
+                return ETable.this;
+            } else {
+                return super.getComponentBefore(focusCycleRoot, aComponent);
+            }
+        }
+        
+        public Component getFirstComponent(Container focusCycleRoot) {
+            if (!inRemoveRequest &amp;&amp; isEditing()) {
+                return editorComp;
+            } else {
+                return ETable.this;
+            }
+        }
+        
+        public Component getDefaultComponent(Container focusCycleRoot) {
+            if (inRemoveRequest &amp;&amp; isEditing() &amp;&amp; editorComp.isShowing()) {
+                return editorComp;
+            } else {
+                return ETable.this;
+            }
+        }
+        
+        protected boolean accept(Component aComponent) {
+            //Do not allow focus to go to a child of the editor we're using if
+            //we are in the process of removing the editor
+            if (isEditing() &amp;&amp; inEditRequest) {
+                return isKnownComponent (aComponent);
+            }
+            return super.accept(aComponent) &amp;&amp; aComponent.isShowing();
+        }
+    }
+    
+    /**
+     * Enables tab keys to navigate between rows but also exit the table
+     * to the next focusable component in either direction.
+     */
+    private final class NavigationAction extends AbstractAction {
+        
+        /** true is forward direction */
+        private boolean direction;
+        
+        public NavigationAction(boolean direction) {
+            this.direction = direction;
+        }
+        
+        public void actionPerformed(ActionEvent e) {
+            if (isEditing()) {
+                removeEditor();
+            }
+            int targetRow;
+            int targetColumn;
+            if (direction) {
+                if (getSelectedColumn() == getColumnCount()-1) {
+                    targetColumn=0;
+                    targetRow = getSelectedRow()+1;
+                } else {
+                    targetColumn = getSelectedColumn()+1;
+                    targetRow = getSelectedRow();
+                }
+            } else {
+                if (getSelectedColumn() == 0) {
+                    targetColumn = getColumnCount()-1;
+                    targetRow = getSelectedRow()-1;
+                } else {
+                    targetRow = getSelectedRow();
+                    targetColumn = getSelectedColumn() -1;
+                }
+            }
+            
+            //if we're off the end, try to find a sibling component to pass
+            //focus to
+            if (targetRow &gt;= getRowCount() || targetRow &lt; 0) {
+                //This code is a bit ugly, but works
+                Container ancestor = getFocusCycleRootAncestor();
+                //Find the next component in our parent's focus cycle
+                Component sibling = direction ?
+                ancestor.getFocusTraversalPolicy().getComponentAfter(ancestor,
+                ETable.this.getParent()) :
+                    ancestor.getFocusTraversalPolicy().getComponentBefore(ancestor,
+                    ETable.this);
+                    
+
+                //Often LayoutFocusTranferPolicy will return ourselves if we're
+                //the last.  First try to find a parent focus cycle root that
+                //will be a little more polite
+                if (sibling == ETable.this) {
+                    Container grandcestor = ancestor.getFocusCycleRootAncestor();
+                    if (grandcestor != null) {
+                        sibling = direction ? grandcestor.getFocusTraversalPolicy().getComponentAfter(grandcestor, ancestor) :
+                            grandcestor.getFocusTraversalPolicy().getComponentBefore(grandcestor, ancestor);
+                        ancestor = grandcestor;
+                    }
+                }
+                 
+                //Okay, we still ended up with ourselves, or there is only one focus
+                //cycle root ancestor.  Try to find the first component according to
+                //the policy
+                if (sibling == ETable.this) {
+                    if (ancestor.getFocusTraversalPolicy().getFirstComponent(ancestor) != null) {
+                        sibling = ancestor.getFocusTraversalPolicy().getFirstComponent(ancestor);
+                    }
+                }
+                
+                //If we're *still* getting ourselves, find the default button and punt
+                if (sibling == ETable.this) {
+                    JRootPane rp = getRootPane();
+                    JButton jb = rp.getDefaultButton();
+                    if (jb != null) {
+                        sibling = jb;
+                    }
+                }
+                    
+                //See if it's us, or something we know about, and if so, just
+                //loop around to the top or bottom row - there's noplace
+                //interesting for focus to go to
+                if (sibling != null) {
+                    if (sibling == ETable.this) {
+                        //set the selection if there's nothing else to do
+                        changeSelection(direction ? 0 : getRowCount()-1, 
+                            direction ? 0 : getColumnCount()-1,false,false);
+                    } else {
+                        //Request focus on the sibling
+                        sibling.requestFocus();
+                    }
+                    return;
+                }
+            }
+            changeSelection (targetRow, targetColumn, false, false);
+        }
+    }
+
+    /** Used to explicitly invoke editing from the keyboard */
+    private class EditAction extends AbstractAction {
+        
+        public void actionPerformed(ActionEvent e) {
+            int row = getSelectedRow();
+            int col = getSelectedColumn();
+            editCellAt(row, col, null);
+        }
+        
+        public boolean isEnabled() {
+            return getSelectedRow() != -1 &amp;&amp; getSelectedColumn() != -1 &amp;&amp; !isEditing();
+        }
+    }
+    
+    /**
+     * Either cancels an edit, or closes the enclosing dialog if present.
+     */
+    private class CancelEditAction extends AbstractAction {
+        
+        public void actionPerformed(ActionEvent e) {
+            if (isEditing() || editorComp != null) {
+                removeEditor();
+                return;
+            } else {
+                Component c = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
+                
+                InputMap imp = getRootPane().getInputMap(WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
+                ActionMap am = getRootPane().getActionMap();
+                
+                KeyStroke escape = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0, false);
+                Object key = imp.get(escape);
+                if (key == null) {
+                    //Default for NbDialog
+                    key = &quot;Cancel&quot;;
+                }
+                if (key != null) {
+                    Action a = am.get(key);
+                    if (a != null) {
+                        String commandKey = (String)a.getValue(Action.ACTION_COMMAND_KEY);
+                        if (commandKey == null) {
+                            commandKey = key.toString();
+                        }
+                        a.actionPerformed(new ActionEvent(this,
+                        ActionEvent.ACTION_PERFORMED, commandKey)); //NOI18N
+                    }
+                }
+            }
+        }
+        
+        public boolean isEnabled() {
+            //            return isEditing();
+            return true;
+        }
+    }
+    
+    /**
+     * Action for the keyboard event of hitting the Enter key.
+     */
+    private class EnterAction extends AbstractAction {
+        public void actionPerformed(ActionEvent e) {
+            JRootPane jrp = getRootPane();
+            if (jrp != null) {
+                JButton b = getRootPane().getDefaultButton();
+                if (b != null &amp;&amp; b.isEnabled()) {
+                    b.doClick();
+                }
+            }
+        }
+        
+        public boolean isEnabled() {
+            return !isEditing() &amp;&amp; !inRemoveRequest;
+        }
+    }
+    
+    /**
+     * CTRL-Tab transfers focus up.
+     */
+    private class CTRLTabAction extends AbstractAction {
+        public void actionPerformed(ActionEvent e) {
+            setFocusCycleRoot(false);
+            try {
+                Container con = ETable.this.getFocusCycleRootAncestor();
+                if (con != null) {
+                    Component target = ETable.this;
+                    if (getParent() instanceof JViewport) {
+                        target = getParent().getParent();
+                        if (target == con) {
+                            target = ETable.this;
+                        }
+                    }
+
+                    EventObject eo = EventQueue.getCurrentEvent();
+                    boolean backward = false;
+                    if (eo instanceof KeyEvent) {
+                        backward = 
+                            (((KeyEvent) eo).getModifiers() 
+                            &amp; KeyEvent.SHIFT_MASK) 
+                            != 0 &amp;&amp; (((KeyEvent) eo).getModifiersEx() &amp; 
+                            KeyEvent.SHIFT_DOWN_MASK) != 0;
+                    }
+
+                    Component to = backward ? 
+                        con.getFocusTraversalPolicy().getComponentAfter(
+                        con, ETable.this) 
+                        : con.getFocusTraversalPolicy().getComponentAfter(
+                        con, ETable.this);
+
+                        
+                    if (to == ETable.this) {
+                        to = backward ? 
+                            con.getFocusTraversalPolicy().getFirstComponent(con) : 
+                            con.getFocusTraversalPolicy().getLastComponent(con);
+                    }
+                    to.requestFocus();
+                }
+            } finally {
+                setFocusCycleRoot(true);
+            }
+        }
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETableColumn.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETableColumn.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETableColumn.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,643 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2004 Nokia. All Rights Reserved.
+ */
+package org.netbeans.swing.etable;
+
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Container;
+import java.awt.Dimension;
+import java.awt.Graphics;
+import java.awt.Image;
+import java.awt.Point;
+import java.util.Comparator;
+import java.util.Properties;
+import javax.swing.Icon;
+import javax.swing.ImageIcon;
+import javax.swing.JScrollPane;
+import javax.swing.JTable;
+import javax.swing.JViewport;
+import javax.swing.SwingUtilities;
+import javax.swing.UIManager;
+import javax.swing.plaf.UIResource;
+import javax.swing.table.DefaultTableCellRenderer;
+import javax.swing.table.JTableHeader;
+import javax.swing.table.TableCellEditor;
+import javax.swing.table.TableCellRenderer;
+import javax.swing.table.TableColumn;
+import javax.swing.table.TableModel;
+
+/**
+ * Special type of TableColumn object used by ETable. 
+ * @author David Strupl
+ */
+public class ETableColumn extends TableColumn implements Comparable {
+    
+    /** Used as a key or part of a key by the persistence mechanism. */
+    private static final String PROP_PREFIX = &quot;ETableColumn-&quot;;
+    
+    /** Used as a key or part of a key by the persistence mechanism. */
+    private static final String PROP_WIDTH = &quot;Width&quot;;
+    
+    /** Used as a key or part of a key by the persistence mechanism. */
+    private static final String PROP_PREFERRED_WIDTH = &quot;PreferredWidth&quot;;
+    
+    /** Used as a key or part of a key by the persistence mechanism. */
+    private static final String PROP_SORT_RANK = &quot;SortRank&quot;;
+    
+    /** Used as a key or part of a key by the persistence mechanism. */
+    private static final String PROP_COMPARATOR = &quot;Comparator&quot;;
+    
+    /** Used as a key or part of a key by the persistence mechanism. */
+    private static final String PROP_HEADER_VALUE = &quot;HeaderValue&quot;;
+    
+    /** Used as a key or part of a key by the persistence mechanism. */
+    private static final String PROP_MODEL_INDEX = &quot;ModelIndex&quot;;
+    
+    /** Used as a key or part of a key by the persistence mechanism. */
+    private static final String PROP_ASCENDING = &quot;Ascending&quot;;
+    
+    /** */
+    private int sortRank = 0;
+    /** */
+    private Comparator comparator;
+    /** */
+    private boolean ascending = true;
+    /** */
+    private boolean headerRendererSetExternally = false;
+    /** */
+    private ETable table;
+    /** */
+    private Icon customIcon;
+    
+    /** Header renderer created by createDefaultHeaderRenderer. */
+    private TableCellRenderer headerRenderer;
+    
+    /** Creates a new instance of ETableColumn */
+    public ETableColumn(ETable table) {
+        super();
+        this.table = table;
+    }
+    
+    /** Creates a new instance of ETableColumn */
+    public ETableColumn(int modelIndex, ETable table) {
+        super(modelIndex);
+        this.table = table;
+    }
+    
+    /** Creates a new instance of ETableColumn */
+    public ETableColumn(int modelIndex, int width, ETable table) {
+        super(modelIndex, width);
+        this.table = table;
+    }
+    
+    /** Creates a new instance of ETableColumn */
+    public ETableColumn(int modelIndex, int width, TableCellRenderer cellRenderer, TableCellEditor cellEditor, ETable table) {
+        super(modelIndex, width, cellRenderer, cellEditor);
+        this.table = table;
+    }
+    
+    /**
+     * This method marks this column as sorted. Value 0 of the parameter rank
+     * means that this column is not sorted.
+     * @param int rank value 1 means that this is the most important sorted
+     *        column, number 2 means second etc.
+     * @param comparator operates over ETable.RowMapping objects
+     */
+    void setSorted(int rank, boolean ascending) {
+        if (!isSortingAllowed() &amp;&amp; (rank != 0 || comparator != null)) {
+            throw new IllegalStateException(&quot;Cannot sort an unsortable column.&quot;);
+        }
+        this.ascending = ascending;
+        sortRank = rank;
+        if (rank != 0) {
+            comparator = getRowComparator(getModelIndex(), ascending);
+        } else {
+            comparator = null;
+        }
+    }
+    
+    /**
+     * Returns true if the table is sorted using this column.
+     */
+    public boolean isSorted() {
+        return comparator != null;
+    }
+    
+    /**
+     * Rank value 1 means that this is the most important column
+     * (with respect to the table sort), value 2 means second etc.
+     */
+    void setSortRank(int newRank) {
+        if (!isSortingAllowed() &amp;&amp; newRank != 0) {
+            throw new IllegalStateException(&quot;Cannot sort an unsortable column.&quot;);
+        }
+        sortRank = newRank;
+    }
+    
+    /**
+     * Rank value 1 means that this is the most important column
+     * (with respect to the table sort), value 2 means second etc.
+     * To ask for the value of rank makes sense only when isSorted() returns
+     * true. If isSorted() returns false this method should return 0.
+     */
+    public int getSortRank() {
+        return sortRank;
+    }
+    
+    /**
+     * Returns the comparator used for sorting. The returned comparaotor
+     * operates over ETable.RowMapping objects.
+     */
+    Comparator getComparator() {
+        return comparator;
+    }
+    
+    /**
+     * Checks whether the sort order is ascending (true means ascending,
+     * false means descending).
+     */
+    public boolean isAscending() {
+        return ascending;
+    }
+    
+    /**
+     * Sets the sort order. Please note: the column has to be already
+     * sorted when calling this method otherwise IllegalStateException
+     * is thrown.
+     */
+    void setAscending(boolean ascending) {
+        if (!isSortingAllowed()) {
+            throw new IllegalStateException(&quot;Cannot sort an unsortable column.&quot;);
+        }
+        if (! isSorted()) {
+            return;
+        }
+        if (this.ascending == ascending) {
+            return;
+        }
+        Comparator c = getRowComparator(getModelIndex(), ascending);
+        if (c == null) {
+            throw new IllegalStateException(&quot;getRowComparator returned null for &quot; + this); // NOI18N
+        }
+        this.ascending = ascending;
+        this.comparator = c;
+    }
+    
+    /**
+     * Allows to set the header renderer. If this method is not called
+     * we use our special renderer created by method 
+     * createDefaultHeaderRenderer().
+     */
+    public void setHeaderRenderer(TableCellRenderer tcr) {
+        headerRendererSetExternally = true;
+        super.setHeaderRenderer(tcr);
+    }
+    
+    /**
+     * Use a special renderer (result of calling createDefaultHeaderRenderer)
+     * if it was not set by setHeaderRenderer.
+     */
+    public TableCellRenderer getHeaderRenderer() {
+        if (headerRendererSetExternally) {
+            return super.getHeaderRenderer();
+        }
+	return createDefaultHeaderRenderer();
+    }
+
+    /**
+     * The column can be hidden if this method returns true.
+     */
+    public boolean isHidingAllowed() {
+        return true;
+    }
+    
+    /**
+     * The column can be sorted if this method returns true.
+     */
+    public boolean isSortingAllowed() {
+        return true;
+    }
+    
+    /**
+     * Allows setting a custom icon for this column.
+     */
+    public void setCustomIcon(Icon i) {
+        customIcon = i;
+    }
+    
+    /**
+     * Computes preferred width of the column by checking all the
+     * data in the given column. If the resize parameter is true
+     * it also directly resizes the column to the computed size (besides
+     * setting the preferred size).
+     */
+    void updatePreferredWidth(JTable table, boolean resize) {
+        TableModel dataModel = table.getModel();
+        int rows = dataModel.getRowCount();
+        if (rows == 0) {
+            return;
+        }
+        int sum = 0;
+        int max = 15;
+        for (int i = 0; i &lt; rows; i++) {
+            Object data = dataModel.getValueAt(i, modelIndex);
+            int estimate = estimatedWidth(data, table);
+            sum += estimate;
+            if (estimate &gt; max) {
+                max = estimate;
+            }
+        }
+        max += 5;
+        setPreferredWidth(max);
+        if (resize) {
+            resize(max, table);
+        }
+    }
+
+    /**
+     * Forces the table to resize given column.
+     */
+    private void resize(int newWidth, JTable table) {
+        int oldWidth = getWidth();
+        JTableHeader header = table.getTableHeader();
+        if (header == null) {
+            return;
+        }
+        header.setResizingColumn(this);
+        final int oldMin = getMinWidth();
+        final int oldMax = getMaxWidth();
+        setMinWidth(newWidth);
+        setMaxWidth(newWidth);
+        setWidth(newWidth);
+        // The trick is to restore the original values
+        // after the table has be layouted. During layout this column
+        // has fixed width (by setting min==max==preffered)
+        SwingUtilities.invokeLater(new Runnable() {
+            public void run() {
+                setMinWidth(oldMin);
+                setMaxWidth(oldMax);
+            }
+        });
+        Container container;
+        if ((header.getParent() == null) ||
+                ((container = header.getParent().getParent()) == null) ||
+                !(container instanceof JScrollPane)) {
+            header.setResizingColumn(null);
+            return;
+        }
+        
+        if (!container.getComponentOrientation().isLeftToRight() &amp;&amp;
+                ! header.getComponentOrientation().isLeftToRight()) {
+            if (table != null) {
+                JViewport viewport = ((JScrollPane)container).getViewport();
+                int viewportWidth = viewport.getWidth();
+                int diff = newWidth - oldWidth;
+                int newHeaderWidth = table.getWidth() + diff;
+                
+                /* Resize a table */
+                Dimension tableSize = table.getSize();
+                tableSize.width += diff;
+                table.setSize(tableSize);
+                
+                /* If this table is in AUTO_RESIZE_OFF mode and
+                 * has a horizontal scrollbar, we need to update
+                 * a view's position.
+                 */
+                if ((newHeaderWidth &gt;= viewportWidth) &amp;&amp;
+                        (table.getAutoResizeMode() == JTable.AUTO_RESIZE_OFF)) {
+                    Point p = viewport.getViewPosition();
+                    p.x = Math.max(0, Math.min(newHeaderWidth - viewportWidth, p.x + diff));
+                    viewport.setViewPosition(p);
+                }
+            }
+        }
+        header.setResizingColumn(null);
+    }
+    
+    /**
+     * @returns width in pixels of the graphical representation of the data.
+     */
+    private int estimatedWidth(Object dataObject, JTable table) {
+        TableCellRenderer cr = getCellRenderer();
+        if (cr == null) {
+            Class c = table.getModel().getColumnClass(modelIndex);
+            cr = table.getDefaultRenderer(c);
+        }
+        Component c = cr.getTableCellRendererComponent(table, dataObject, false,
+                false, 0, table.getColumnModel().getColumnIndex(getIdentifier()));
+        return c.getPreferredSize().width;
+    }
+    
+    /**
+     * Method allowing to read stored values.
+     * The stored values should be only those that the user has customized,
+     * it does not make sense to store the values that were set using 
+     * the initialization code because the initialization code can be run
+     * in the same way after restart.
+     */
+    public void readSettings(Properties p, int index, String propertyPrefix) {
+        String myPrefix = propertyPrefix + PROP_PREFIX + Integer.toString(index) + &quot;-&quot;;
+        String s0 = p.getProperty(myPrefix + PROP_MODEL_INDEX);
+        if (s0 != null) {
+            modelIndex = Integer.parseInt(s0);
+        }
+        String s1 = p.getProperty(myPrefix + PROP_WIDTH);
+        if (s1 != null) {
+            width = Integer.parseInt(s1);
+        }
+        String s2 = p.getProperty(myPrefix + PROP_PREFERRED_WIDTH);
+        if (s2 != null) {
+            setPreferredWidth(Integer.parseInt(s2));
+        }
+        ascending = true;
+        String s4 = p.getProperty(myPrefix + PROP_ASCENDING);
+        if (&quot;false&quot;.equals(s4)) {
+            ascending = false;
+        }
+        String s3 = p.getProperty(myPrefix + PROP_SORT_RANK);
+        if (s3 != null) {
+            sortRank = Integer.parseInt(s3);
+            if (sortRank &gt; 0) {
+                comparator = getRowComparator(modelIndex, ascending);
+            }
+        }
+        headerValue = p.getProperty(myPrefix + PROP_HEADER_VALUE);
+    }
+
+    /**
+     * Method allowing to store customization values.
+     * The stored values should be only those that the user has customized,
+     * it does not make sense to store the values that were set using 
+     * the initialization code because the initialization code can be run
+     * in the same way after restart.
+     */
+    public void writeSettings(Properties p, int index, String propertyPrefix) {
+        String myPrefix = propertyPrefix + PROP_PREFIX + Integer.toString(index) + &quot;-&quot;;
+        p.setProperty(myPrefix + PROP_MODEL_INDEX, Integer.toString(modelIndex));
+        p.setProperty(myPrefix + PROP_WIDTH, Integer.toString(width));
+        p.setProperty(myPrefix + PROP_PREFERRED_WIDTH, Integer.toString(getPreferredWidth()));
+        p.setProperty(myPrefix + PROP_SORT_RANK, Integer.toString(sortRank));
+        p.setProperty(myPrefix + PROP_ASCENDING, ascending ? &quot;true&quot; : &quot;false&quot;);
+        if (headerValue != null) {
+            p.setProperty(myPrefix + PROP_HEADER_VALUE, headerValue.toString());
+        }
+    }
+
+    /*
+     * Implementing interface Comparable.
+     */
+    public int compareTo(Object obj) {
+        ETableColumn theOther = (ETableColumn)obj;
+        if (modelIndex &lt; theOther.modelIndex) {
+            return -1;
+        }
+        if (modelIndex &gt; theOther.modelIndex) {
+            return 1;
+        }
+        return 0;
+    }
+
+    /**
+     * Allow subclasses to supply special row comparator object.
+     */
+    protected Comparator getRowComparator(int column, boolean ascending) {
+        if (ascending) {
+            return new RowComparator(column);
+        } else {
+            return new FlippingComparator(new RowComparator(column));
+        }
+    }
+    
+    /**
+     * Overriden to return our special header renderer.
+     * @see javax.swing.table.TableColumn#createDefaultHeaderRenderer()
+     */
+    protected TableCellRenderer createDefaultHeaderRenderer() {
+        if (headerRenderer == null) {
+            headerRenderer = new ETableHeaderRenderer();
+        }
+        return headerRenderer;
+    }
+
+    /**
+     * An icon pointing up. It is used if the LAF does not supply
+     * special icon.
+     */
+    private static class SortUpIcon implements Icon {
+        
+        public SortUpIcon() {
+        }
+        
+        public int getIconWidth() {
+            return 8;
+        }
+        
+        public int getIconHeight() {
+            return 8;
+        }
+        
+        public void paintIcon(Component c, Graphics g, int x, int y) {
+            g.setColor(Color.BLACK);
+            g.drawLine(x    , y + 2, x + 8, y + 2);
+            g.drawLine(x    , y + 2, x + 4, y + 6);
+            g.drawLine(x + 8, y + 2, x + 4, y + 6);
+        }
+    }
+
+    /**
+     * An icon pointing down. It is used if the LAF does not supply
+     * special icon.
+     */
+    private static class SortDownIcon implements Icon {
+        
+        public SortDownIcon() {
+        }
+        
+        public int getIconWidth() {
+            return 8;
+        }
+        
+        public int getIconHeight() {
+            return 8;
+        }
+        
+        public void paintIcon(Component c, Graphics g, int x, int y) {
+            g.setColor(Color.BLACK);
+            g.drawLine(x    , y + 6, x + 8, y + 6);
+            g.drawLine(x    , y + 6, x + 4, y + 2);
+            g.drawLine(x + 8, y + 6, x + 4, y + 2);
+        }
+    }
+    
+    /**
+     * Comparator reversing the order of the sorted objects (with
+     * respect to the original comparator.
+     */
+    static class FlippingComparator implements Comparator {
+        private Comparator origComparator;
+        public FlippingComparator(Comparator orig) {
+            origComparator = orig;
+        }
+
+        public int compare(Object o1, Object o2) {
+            return -origComparator.compare(o1, o2);
+        }
+        
+        public Comparator getOriginalComparator() {
+            return origComparator;
+        }
+    }
+    
+    /**
+     * Special renderer painting sorting icons and also special icon
+     * for the QuickFilter columns.
+     */
+    private class ETableHeaderRenderer extends DefaultTableCellRenderer implements UIResource {
+        public Component getTableCellRendererComponent(JTable table, Object value,
+                boolean isSelected, boolean hasFocus, int row, int column) {
+            if (table != null) {
+                JTableHeader header = table.getTableHeader();
+                if (header != null) {
+                    setForeground(header.getForeground());
+                    setBackground(header.getBackground());
+                    setFont(header.getFont());
+                }
+            }
+            String valueString = &quot;&quot;;
+            if (value != null) {
+                valueString = value.toString();
+            }
+            if (table instanceof ETable) {
+                ETable et = (ETable)table;
+                valueString = et.getColumnDisplayName(valueString);
+            }
+            setBorder(UIManager.getBorder(&quot;TableHeader.cellBorder&quot;));
+            Icon sortIcon = null;
+            if (sortRank != 0) {
+                setText((value == null) ? 
+                    Integer.toString(sortRank) : 
+                    sortRank+&quot; &quot;+valueString);
+                if (ascending) {
+                    sortIcon = UIManager.getIcon(&quot;ETableHeader.ascendingIcon&quot;);
+                    if (sortIcon == null) {
+                        sortIcon = new SortUpIcon();
+                    }
+                } else {
+                    sortIcon = UIManager.getIcon(&quot;ETableHeader.descendingIcon&quot;);
+                    if (sortIcon == null) {
+                        sortIcon = new SortDownIcon();
+                    }
+                }
+            } else { // sortRank == 0
+                setText(valueString);
+            }
+            if (sortIcon == null) {
+                if (customIcon == null) {
+                    Icon dummy = new Icon() {
+                        public void paintIcon(Component c, Graphics g, int x, int y) {
+                        }
+                        public int getIconWidth() {
+                            return 0;
+                        }
+                        public int getIconHeight() {
+                            return 0;
+                        }
+                    };
+                    setIcon(dummy);
+                } else {
+                    setIcon(customIcon);
+                }
+            } else {
+                if (customIcon == null) {
+                    setIcon(sortIcon);
+                } else {
+                    setIcon(mergeIcons(customIcon, sortIcon, 16, 0, this));
+                }
+            }
+            return this;
+        }
+    }
+    
+    /**
+     * Comparator used for sorting the rows according to value in
+     * a given column. Operates on the RowMapping objects.
+     */
+    public class RowComparator implements Comparator {
+        protected int column;
+        public RowComparator(int column) {
+            this.column = column;
+        }
+        public int compare(Object o1, Object o2) {
+            ETable.RowMapping rm1 = (ETable.RowMapping)o1;
+            ETable.RowMapping rm2 = (ETable.RowMapping)o2;
+            Object obj1 = rm1.getModelObject(column);
+            Object obj2 = rm2.getModelObject(column);
+            obj1 = table.transformValue(obj1);
+            obj2 = table.transformValue(obj2);
+            if (obj1 == null &amp;&amp; obj2 == null) {
+                return 0;
+            }
+            if (obj1 == null) {
+                return -1;
+            }
+            if (obj2 == null) {
+                return 1;
+            }
+            if ((obj1 instanceof Comparable) &amp;&amp; (obj1.getClass().isAssignableFrom(obj2.getClass()))){
+                Comparable c1 = (Comparable) obj1;
+                return c1.compareTo(obj2);
+            }
+            return obj1.toString().compareTo(obj2.toString());
+        }
+    }
+    
+    /**
+     * Utility method merging 2 icons.
+     */
+    private static final Icon mergeIcons(Icon icon1, Icon icon2, int x, int y, Component c) {
+        int w = 0, h = 0;
+        if (icon1 != null) {
+            w = icon1.getIconWidth();
+            h = icon1.getIconHeight();
+        }
+        if (icon2 != null) {
+            w = icon2.getIconWidth()  + x &gt; w ? icon2.getIconWidth()   + x : w;
+            h = icon2.getIconHeight() + y &gt; h ? icon2.getIconHeight()  + y : h;
+        }
+        if (w &lt; 1) w = 16;
+        if (h &lt; 1) h = 16;
+        
+        java.awt.image.ColorModel model = java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment ().
+                                          getDefaultScreenDevice ().getDefaultConfiguration ().
+                                          getColorModel (java.awt.Transparency.BITMASK);
+        java.awt.image.BufferedImage buffImage = new java.awt.image.BufferedImage (model,
+             model.createCompatibleWritableRaster (w, h), model.isAlphaPremultiplied (), null);
+        
+        java.awt.Graphics g = buffImage.createGraphics ();
+        if (icon1 != null) {
+            icon1.paintIcon(c, g, 0, 0);
+        }
+        if (icon2 != null) {
+            icon2.paintIcon(c, g, x, y);
+        }
+        g.dispose();
+        
+        return new ImageIcon(buffImage);
+    }
+
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETableColumnModel.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETableColumnModel.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETableColumnModel.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,289 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2004 Nokia. All Rights Reserved.
+ */
+package org.netbeans.swing.etable;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Properties;
+import java.util.Vector;
+import javax.swing.table.DefaultTableColumnModel;
+import javax.swing.table.TableColumn;
+
+/**
+ *
+ * @author David Strupl
+ */
+public class ETableColumnModel extends DefaultTableColumnModel {
+
+    /** Used as a key or part of a key by the persistence mechanism. */
+    private static final String NUMBER_OF_COLUMNS = &quot;ColumnsNumber&quot;;
+
+    /** Used as a key or part of a key by the persistence mechanism. */
+    private static final String NUMBER_OF_HIDDEN_COLUMNS = &quot;HiddenColumnsNumber&quot;;
+    
+    /** Used as a key or part of a key by the persistence mechanism. */
+    private static final String PROP_HIDDEN_PREFIX = &quot;Hidden&quot;;
+    
+    /**
+     * List&lt;ETableColumn&gt;: holds list of sorted columns in this model.
+     * If the list is empty if no sorting is applied.
+     */
+    protected transient List sortedColumns = new ArrayList();
+    
+    /**
+     * List&lt;ETableColumn&gt;: holds list of columns that were hidden by the
+     * user. The columns contained here are not contained in the inherited
+     * tableColumns list.
+     */
+    protected List hiddenColumns = new ArrayList();
+    
+    /** Creates a new instance of ETableColumnModel */
+    public ETableColumnModel() {
+        super();
+    }
+    
+    /**
+     * Method allowing to read stored values.
+     * The stored values should be only those that the user has customized,
+     * it does not make sense to store the values that were set using 
+     * the initialization code because the initialization code can be run
+     * in the same way after restart.
+     */
+    public void readSettings(Properties p, String propertyPrefix, ETable table) {
+        tableColumns = new Vector();
+        sortedColumns = new ArrayList();
+        String s = p.getProperty(propertyPrefix + NUMBER_OF_COLUMNS);
+        int numColumns = Integer.parseInt(s);
+        for (int i = 0; i &lt; numColumns; i++) {
+            ETableColumn etc = (ETableColumn)table.createColumn(i);
+            etc.readSettings(p, i, propertyPrefix);
+            addColumn(etc);
+            if (etc.getComparator() != null) {
+                int j = 0;
+                for ( ; j &lt; sortedColumns.size(); j++) {
+                    ETableColumn setc = (ETableColumn)sortedColumns.get(j);
+                    if (setc.getSortRank() &gt; etc.getSortRank()) {
+                        break;
+                    }
+                }
+                sortedColumns.add(j, etc);
+            }
+        }
+        hiddenColumns = new ArrayList();
+        String sh = p.getProperty(propertyPrefix + NUMBER_OF_HIDDEN_COLUMNS);
+        int numHiddenColumns = Integer.parseInt(sh);
+        for (int i = 0; i &lt; numHiddenColumns; i++) {
+            ETableColumn etc = new ETableColumn(table);
+            etc.readSettings(p, i, propertyPrefix + PROP_HIDDEN_PREFIX);
+            hiddenColumns.add(etc);
+        }
+    }
+
+    /**
+     * Method allowing to store customization values.
+     * The stored values should be only those that the user has customized,
+     * it does not make sense to store the values that were set using 
+     * the initialization code because the initialization code can be run
+     * in the same way after restart.
+     */
+    public void writeSettings(Properties p, String propertyPrefix) {
+        int i = 0;
+        int numColumns = tableColumns.size();
+        p.setProperty(propertyPrefix + NUMBER_OF_COLUMNS, Integer.toString(numColumns));
+        for (Iterator it = tableColumns.iterator(); it.hasNext(); ) {
+            Object obj = it.next();
+            if (obj instanceof ETableColumn) {
+                ETableColumn etc = (ETableColumn) obj;
+                etc.writeSettings(p, i++, propertyPrefix);
+            }
+        }
+        i = 0;
+        int numHiddenColumns = hiddenColumns.size();
+        p.setProperty(propertyPrefix + NUMBER_OF_HIDDEN_COLUMNS, Integer.toString(numHiddenColumns));
+        for (Iterator it = hiddenColumns.iterator(); it.hasNext(); ) {
+            Object obj = it.next();
+            if (obj instanceof ETableColumn) {
+                ETableColumn etc = (ETableColumn) obj;
+                etc.writeSettings(p, i++, propertyPrefix + PROP_HIDDEN_PREFIX);
+            }
+        }
+    }
+
+    /**
+     * @returns a comparator for sorting the rows of the table. The comparator
+     * operates over ETable.RowMappings objects.
+     */
+    Comparator getComparator() {
+        if (sortedColumns.isEmpty()) {
+            return new ETable.OriginalRowComparator();
+        }
+        return new CompoundComparator();
+    }
+    
+    /**
+     *
+     */
+    void setColumnSorted(ETableColumn etc, boolean ascending, int newRank) {
+        if (! etc.isSortingAllowed()) {
+            return;
+        }
+        
+        // TODO: check the implementation!
+        
+         boolean wasSorted = sortedColumns.contains(etc);
+         boolean wasAscending = false;
+         if (wasSorted) {
+             etc.setAscending(ascending);
+             etc.setSortRank(newRank);
+             sortedColumns.remove(etc);
+         } else {
+            etc.setSorted(newRank, ascending);
+         }
+         sortedColumns.add(newRank-1, etc);
+    }
+    
+    /**
+     *
+     */
+    void toggleSortedColumn(ETableColumn etc, boolean cleanAll) {
+        if (! etc.isSortingAllowed()) {
+            return;
+        }
+        boolean wasSorted = sortedColumns.contains(etc);
+        if (cleanAll) {
+            clearSortedColumns(etc);
+        }
+        if (wasSorted) {
+            if (etc.isAscending()) {
+                etc.setAscending(false);
+            } else {
+                sortedColumns.remove(etc);
+                etc.setSorted(0, false);
+            }
+            updateRanks();
+        } else {
+            etc.setSorted(sortedColumns.size()+1, true);
+            sortedColumns.add(etc);
+        }
+    }
+    
+    /** 
+     * Makes the given column hidden or visible according to the parameter
+     * hidden.
+     */
+    public void setColumnHidden(TableColumn column, boolean hidden) {
+        if (hidden) {
+            if (! hiddenColumns.contains(column)) {
+                if (tableColumns.contains(column)) {
+                    removeColumn(column);
+                    hiddenColumns.add(column);
+                }
+            }
+        } else {
+            if (! tableColumns.contains(column)) {
+                if (hiddenColumns.contains(column)) {
+                    hiddenColumns.remove(column);
+                    addColumn(column);
+                }
+            }
+        }
+    }
+    
+    public boolean isColumnHidden(TableColumn tc) {
+        return hiddenColumns.contains(tc);
+    }
+    
+    /**
+     * Makes the whole table unsorted.
+     */
+    public void clearSortedColumns() {
+        for (Iterator it = sortedColumns.iterator(); it.hasNext(); ) {
+            Object o = it.next();
+            if (o instanceof ETableColumn) {
+                ETableColumn etc = (ETableColumn)o;
+                etc.setSorted(0, false);
+            }
+        }
+        sortedColumns = new ArrayList();
+    }
+    
+    /**
+     * Makes the whole table unsorted except for one column.
+     */
+    void clearSortedColumns(TableColumn notThisOne) {
+        boolean wasSorted = sortedColumns.contains(notThisOne);
+        for (Iterator it = sortedColumns.iterator(); it.hasNext(); ) {
+            Object o = it.next();
+            if ((o instanceof ETableColumn) &amp;&amp; (o != notThisOne)) {
+                ETableColumn etc = (ETableColumn)o;
+                etc.setSorted(0, false);
+            }
+        }
+        sortedColumns = new ArrayList();
+        if (wasSorted) {
+            sortedColumns.add(notThisOne);
+        }
+    }
+    
+    /**
+     * Reasigns sorting ranks to ETableColumns contained in sortedColumns list.
+     */
+    private void updateRanks() {
+        int i = 1;
+        for (Iterator it = sortedColumns.iterator(); it.hasNext(); i++) {
+            Object o = it.next();
+            if (o instanceof ETableColumn) {
+                ETableColumn etc = (ETableColumn)o;
+                if (etc.isSorted()) {
+                    etc.setSortRank(i);
+                }
+            }
+        }
+    }
+    
+    /**
+     * Comparator that delegates to individual comparators supplied by
+     * ETableColumns. It uses only the columns contained in the sortedColumns
+     * list.
+     */
+    private class CompoundComparator implements Comparator {
+        private Comparator original;
+        public CompoundComparator() {
+            original = new ETable.OriginalRowComparator();
+        }
+        public int compare(Object o1, Object o2) {
+            for (Iterator it = sortedColumns.iterator(); it.hasNext(); ) {
+                Object o = it.next();
+                if (o instanceof ETableColumn) {
+                    ETableColumn etc = (ETableColumn)o;
+                    Comparator c = etc.getComparator();
+                    if (c != null) {
+                        int res = c.compare(o1, o2);
+                        if (res != 0) {
+                            return res;
+                        }
+                    }
+                }
+            }
+            return original.compare(o1, o2);
+        }
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETableTransferHandler.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETableTransferHandler.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETableTransferHandler.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,91 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2004 Nokia. All Rights Reserved.
+ */
+package org.netbeans.swing.etable;
+
+import java.awt.datatransfer.Transferable;
+import javax.swing.JComponent;
+import javax.swing.TransferHandler;
+
+/**
+ * Used for creating a proper clipboard representation.
+ * @author David Strupl
+ */
+public class ETableTransferHandler extends TransferHandler {
+
+    protected Transferable createTransferable(JComponent c) {
+        if (c instanceof ETable) {
+            ETable table = (ETable) c;
+            int[] rows;
+            int[] cols;
+
+            if (!table.getRowSelectionAllowed() &amp;&amp; !table.getColumnSelectionAllowed()){
+                return null;
+            }
+            
+            if (!table.getRowSelectionAllowed()) {
+                int rowCount = table.getRowCount();
+                
+                rows = new int[rowCount];
+                for (int counter = 0; counter &lt; rowCount; counter++) {
+                    rows[counter] = counter;
+                }
+            } else {
+                rows = table.getSelectedRows();
+            }
+            
+            if (!table.getColumnSelectionAllowed()) {
+                int colCount = table.getColumnCount();
+                
+                cols = new int[colCount];
+                for (int counter = 0; counter &lt; colCount; counter++) {
+                    cols[counter] = counter;
+                }
+            } else {
+                cols = table.getSelectedColumns();
+            }
+            
+            if (rows == null || cols == null || rows.length == 0 || cols.length == 0) {
+                return null;
+            }
+            
+            StringBuffer plainBuf = new StringBuffer();
+            String itemDelim = table.getTransferDelimiter(false);
+            String lineDelim = table.getTransferDelimiter(true);
+            
+            for (int row = 0; row &lt; rows.length; row++) {
+                for (int col = 0; col &lt; cols.length; col++) {
+                    Object obj = table.getValueAt(rows[row], cols[col]);
+                    String val = table.convertValueToString(obj);
+                    plainBuf.append(val + itemDelim);
+                }
+                // we want a newline at the end of each line and not a tab
+                plainBuf.delete(plainBuf.length() - itemDelim.length(), plainBuf.length()-1);
+                plainBuf.append(lineDelim);
+            }
+            // remove the last newline
+            plainBuf.deleteCharAt(plainBuf.length() - 1);
+            return new ETableTransferable(plainBuf.toString());
+        }
+        
+        return null;
+    }
+    
+    public int getSourceActions(JComponent c) {
+        return COPY;
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETableTransferable.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETableTransferable.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/ETableTransferable.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,188 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2004 Nokia. All Rights Reserved.
+ */
+package org.netbeans.swing.etable;
+
+import java.awt.datatransfer.DataFlavor;
+import java.awt.datatransfer.Transferable;
+import java.awt.datatransfer.UnsupportedFlavorException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.Reader;
+import java.io.StringBufferInputStream;
+import java.io.StringReader;
+
+/**
+ * Transferable for use with the ETable. This class is partial copy (with
+ * ommision of the HTML transfers)
+ * of javax.swing.plaf.basic.BasicTransferable which is unfortunatelly not
+ * public.
+ *
+ * @author David Strupl
+ */
+public class ETableTransferable implements Transferable {
+    
+    protected String plainData;
+    
+    private static DataFlavor[] stringFlavors;
+    private static DataFlavor[] plainFlavors;
+    
+    static {
+        try {
+            plainFlavors = new DataFlavor[3];
+            plainFlavors[0] = new DataFlavor(&quot;text/plain;class=java.lang.String&quot;);
+            plainFlavors[1] = new DataFlavor(&quot;text/plain;class=java.io.Reader&quot;);
+            plainFlavors[2] = new DataFlavor(&quot;text/plain;charset=unicode;class=java.io.InputStream&quot;);
+            
+            stringFlavors = new DataFlavor[2];
+            stringFlavors[0] = new DataFlavor(DataFlavor.javaJVMLocalObjectMimeType+&quot;;class=java.lang.String&quot;);
+            stringFlavors[1] = DataFlavor.stringFlavor;
+            
+        } catch (ClassNotFoundException cle) {
+            System.err.println(&quot;error initializing SheetTasbleTransferable&quot;);
+        }
+    }
+    
+    public ETableTransferable(String plainData) {
+        this.plainData = plainData;
+    }
+    
+    
+    /**
+     * Returns an array of DataFlavor objects indicating the flavors the data
+     * can be provided in.  The array should be ordered according to preference
+     * for providing the data (from most richly descriptive to least descriptive).
+     * @return an array of data flavors in which this data can be transferred
+     */
+    public DataFlavor[] getTransferDataFlavors() {
+        int nPlain = (isPlainSupported()) ? plainFlavors.length: 0;
+        int nString = (isPlainSupported()) ? stringFlavors.length : 0;
+        int nFlavors = nPlain + nString;
+        DataFlavor[] flavors = new DataFlavor[nFlavors];
+        
+        // fill in the array
+        int nDone = 0;
+        if (nPlain &gt; 0) {
+            System.arraycopy(plainFlavors, 0, flavors, nDone, nPlain);
+            nDone += nPlain;
+        }
+        if (nString &gt; 0) {
+            System.arraycopy(stringFlavors, 0, flavors, nDone, nString);
+            nDone += nString;
+        }
+        return flavors;
+    }
+    
+    /**
+     * Returns whether or not the specified data flavor is supported for
+     * this object.
+     * @param flavor the requested flavor for the data
+     * @return boolean indicating whether or not the data flavor is supported
+     */
+    public boolean isDataFlavorSupported(DataFlavor flavor) {
+        DataFlavor[] flavors = getTransferDataFlavors();
+        for (int i = 0; i &lt; flavors.length; i++) {
+            if (flavors[i].equals(flavor)) {
+                return true;
+            }
+        }
+        return false;
+    }
+    
+    /**
+     * Returns an object which represents the data to be transferred.  The class
+     * of the object returned is defined by the representation class of the flavor.
+     *
+     * @param flavor the requested flavor for the data
+     * @see DataFlavor#getRepresentationClass
+     * @exception IOException                if the data is no longer available
+     *              in the requested flavor.
+     * @exception UnsupportedFlavorException if the requested data flavor is
+     *              not supported.
+     */
+    public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException {
+        if (isPlainFlavor(flavor)) {
+            String data = getPlainData();
+            data = (data == null) ? &quot;&quot; : data;
+            if (String.class.equals(flavor.getRepresentationClass())) {
+                return data;
+            } else if (Reader.class.equals(flavor.getRepresentationClass())) {
+                return new StringReader(data);
+            } else if (InputStream.class.equals(flavor.getRepresentationClass())) {
+                return new StringBufferInputStream(data);
+            }
+            // fall through to unsupported
+            
+        } else if (isStringFlavor(flavor)) {
+            String data = getPlainData();
+            data = (data == null) ? &quot;&quot; : data;
+            return data;
+        }
+        throw new UnsupportedFlavorException(flavor);
+    }
+    
+    // --- plain text flavors ----------------------------------------------------
+    
+    /**
+     * Returns whether or not the specified data flavor is an plain flavor that
+     * is supported.
+     * @param flavor the requested flavor for the data
+     * @return boolean indicating whether or not the data flavor is supported
+     */
+    protected boolean isPlainFlavor(DataFlavor flavor) {
+        DataFlavor[] flavors = plainFlavors;
+        for (int i = 0; i &lt; flavors.length; i++) {
+            if (flavors[i].equals(flavor)) {
+                return true;
+            }
+        }
+        return false;
+    }
+    
+    /**
+     * Should the plain text flavors be offered?  If so, the method
+     * getPlainData should be implemented to provide something reasonable.
+     */
+    protected boolean isPlainSupported() {
+        return plainData != null;
+    }
+    
+    /**
+     * Fetch the data in a text/plain format.
+     */
+    protected String getPlainData() {
+        return plainData;
+    }
+    
+    // --- string flavorss --------------------------------------------------------
+    
+    /**
+     * Returns whether or not the specified data flavor is a String flavor that
+     * is supported.
+     * @param flavor the requested flavor for the data
+     * @return boolean indicating whether or not the data flavor is supported
+     */
+    protected boolean isStringFlavor(DataFlavor flavor) {
+        DataFlavor[] flavors = stringFlavors;
+        for (int i = 0; i &lt; flavors.length; i++) {
+            if (flavors[i].equals(flavor)) {
+                return true;
+            }
+        }
+        return false;
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/QuickFilter.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/QuickFilter.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/QuickFilter.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,31 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2004 Nokia. All Rights Reserved.
+ */
+package org.netbeans.swing.etable;
+
+/**
+ * Interface for displaying only rows that have particular value
+ * in given column.
+ * @author David Strupl
+ */
+public interface QuickFilter {
+
+    /**
+     * If the object is accepted its row is displayed by the table.
+     */
+    public boolean accept(Object aValue);
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/TestJFrame.form
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/TestJFrame.form	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/TestJFrame.form	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,194 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
+
+&lt;Form version=&quot;1.0&quot; type=&quot;org.netbeans.modules.form.forminfo.JFrameFormInfo&quot;&gt;
+  &lt;Properties&gt;
+    &lt;Property name=&quot;defaultCloseOperation&quot; type=&quot;int&quot; value=&quot;3&quot;/&gt;
+  &lt;/Properties&gt;
+  &lt;SyntheticProperties&gt;
+    &lt;SyntheticProperty name=&quot;formSizePolicy&quot; type=&quot;int&quot; value=&quot;1&quot;/&gt;
+  &lt;/SyntheticProperties&gt;
+
+  &lt;Layout class=&quot;org.netbeans.modules.form.compat2.layouts.DesignBorderLayout&quot;/&gt;
+  &lt;SubComponents&gt;
+    &lt;Container class=&quot;javax.swing.JScrollPane&quot; name=&quot;jScrollPane1&quot;&gt;
+      &lt;Constraints&gt;
+        &lt;Constraint layoutClass=&quot;org.netbeans.modules.form.compat2.layouts.DesignBorderLayout&quot; value=&quot;org.netbeans.modules.form.compat2.layouts.DesignBorderLayout$BorderConstraintsDescription&quot;&gt;
+          &lt;BorderConstraints direction=&quot;Center&quot;/&gt;
+        &lt;/Constraint&gt;
+      &lt;/Constraints&gt;
+
+      &lt;Layout class=&quot;org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout&quot;/&gt;
+      &lt;SubComponents&gt;
+        &lt;Component class=&quot;org.netbeans.swing.etable.ETable&quot; name=&quot;eTable1&quot;&gt;
+          &lt;Properties&gt;
+            &lt;Property name=&quot;model&quot; type=&quot;javax.swing.table.TableModel&quot; editor=&quot;org.netbeans.modules.form.editors2.TableModelEditor&quot;&gt;
+              &lt;Table columnCount=&quot;5&quot; rowCount=&quot;20&quot;&gt;
+                &lt;Column editable=&quot;false&quot; title=&quot;Title 1&quot; type=&quot;java.lang.Object&quot;&gt;
+                  &lt;Data value=&quot;a&quot;/&gt;
+                  &lt;Data value=&quot;a2&quot;/&gt;
+                  &lt;Data value=&quot;b&quot;/&gt;
+                  &lt;Data value=&quot;b3&quot;/&gt;
+                  &lt;Data value=&quot;c&quot;/&gt;
+                  &lt;Data value=&quot;c2&quot;/&gt;
+                  &lt;Data value=&quot;d&quot;/&gt;
+                  &lt;Data value=&quot;d3&quot;/&gt;
+                  &lt;Data value=&quot;e&quot;/&gt;
+                  &lt;Data value=&quot;e2&quot;/&gt;
+                  &lt;Data value=&quot;f&quot;/&gt;
+                  &lt;Data value=&quot;f2&quot;/&gt;
+                  &lt;Data value=&quot;g&quot;/&gt;
+                  &lt;Data value=&quot;g2&quot;/&gt;
+                  &lt;Data value=&quot;h&quot;/&gt;
+                  &lt;Data value=&quot;h2&quot;/&gt;
+                  &lt;Data value=&quot;i&quot;/&gt;
+                  &lt;Data value=&quot;i2&quot;/&gt;
+                  &lt;Data value=&quot;j&quot;/&gt;
+                  &lt;Data value=&quot;j2&quot;/&gt;
+                &lt;/Column&gt;
+                &lt;Column editable=&quot;false&quot; title=&quot;Title 2&quot; type=&quot;java.lang.Object&quot;&gt;
+                  &lt;Data value=&quot;x&quot;/&gt;
+                  &lt;Data value=&quot;y&quot;/&gt;
+                  &lt;Data value=&quot;z&quot;/&gt;
+                  &lt;Data value=&quot;w&quot;/&gt;
+                  &lt;Data value=&quot;m&quot;/&gt;
+                  &lt;Data value=&quot;n&quot;/&gt;
+                  &lt;Data value=&quot;df&quot;/&gt;
+                  &lt;Data value=&quot;f&quot;/&gt;
+                  &lt;Data value=&quot;mm&quot;/&gt;
+                  &lt;Data value=&quot;mg&quot;/&gt;
+                  &lt;Data value=&quot;q&quot;/&gt;
+                  &lt;Data value=&quot;dfg&quot;/&gt;
+                  &lt;Data value=&quot;dfg&quot;/&gt;
+                  &lt;Data value=&quot;fg&quot;/&gt;
+                  &lt;Data value=&quot;xb&quot;/&gt;
+                  &lt;Data value=&quot;sdf&quot;/&gt;
+                  &lt;Data value=&quot;g&quot;/&gt;
+                  &lt;Data value=&quot;mn&quot;/&gt;
+                  &lt;Data value=&quot;we&quot;/&gt;
+                  &lt;Data value=&quot;kl&quot;/&gt;
+                &lt;/Column&gt;
+                &lt;Column editable=&quot;false&quot; title=&quot;Title 3&quot; type=&quot;java.lang.Object&quot;&gt;
+                  &lt;Data value=&quot;tttttttt&quot;/&gt;
+                  &lt;Data value=&quot;ggggggggg&quot;/&gt;
+                  &lt;Data value=&quot;nnnnnnnn&quot;/&gt;
+                  &lt;Data value=&quot;mmmmmm&quot;/&gt;
+                  &lt;Data value=&quot;kkkkkkkkkk&quot;/&gt;
+                  &lt;Data value=&quot;kkkkk&quot;/&gt;
+                  &lt;Data value=&quot;wwwwwwww&quot;/&gt;
+                  &lt;Data value=&quot;ggggggggggggg&quot;/&gt;
+                  &lt;Data value=&quot;hhhhhhhhhhhh&quot;/&gt;
+                  &lt;Data value=&quot;qqqqqqqqqqq&quot;/&gt;
+                  &lt;Data value=&quot;ffffffffffffff&quot;/&gt;
+                  &lt;Data value=&quot;nnnnnnnnnnnn&quot;/&gt;
+                  &lt;Data value=&quot;mmmmmmmmmmm&quot;/&gt;
+                  &lt;Data value=&quot;qqqqqqqqq&quot;/&gt;
+                  &lt;Data value=&quot;nnnnnnnnnnn&quot;/&gt;
+                  &lt;Data value=&quot;asdfasdf&quot;/&gt;
+                  &lt;Data value=&quot;fads&quot;/&gt;
+                  &lt;Data value=&quot;asdf&quot;/&gt;
+                  &lt;Data value=&quot;asdfdsafafsdfsd&quot;/&gt;
+                  &lt;Data value=&quot;asdfasdfafsdasdfasd&quot;/&gt;
+                &lt;/Column&gt;
+                &lt;Column editable=&quot;false&quot; title=&quot;Title 4&quot; type=&quot;java.lang.Integer&quot;&gt;
+                  &lt;Data value=&quot;5&quot;/&gt;
+                  &lt;Data value=&quot;10&quot;/&gt;
+                  &lt;Data value=&quot;7&quot;/&gt;
+                  &lt;Data value=&quot;1&quot;/&gt;
+                  &lt;Data value=&quot;10000&quot;/&gt;
+                  &lt;Data value=&quot;4&quot;/&gt;
+                  &lt;Data value=&quot;17&quot;/&gt;
+                  &lt;Data value=&quot;13&quot;/&gt;
+                  &lt;Data value=&quot;2&quot;/&gt;
+                  &lt;Data value=&quot;8&quot;/&gt;
+                  &lt;Data value=&quot;23&quot;/&gt;
+                  &lt;Data value=&quot;100&quot;/&gt;
+                  &lt;Data value=&quot;57&quot;/&gt;
+                  &lt;Data value=&quot;3&quot;/&gt;
+                  &lt;Data value=&quot;123&quot;/&gt;
+                  &lt;Data value=&quot;321&quot;/&gt;
+                  &lt;Data value=&quot;42&quot;/&gt;
+                  &lt;Data value=&quot;72&quot;/&gt;
+                  &lt;Data value=&quot;88&quot;/&gt;
+                  &lt;Data value=&quot;99&quot;/&gt;
+                &lt;/Column&gt;
+                &lt;Column editable=&quot;false&quot; title=&quot;Title 5&quot; type=&quot;java.lang.Object&quot;&gt;
+                  &lt;Data value=&quot;aaaaab&quot;/&gt;
+                  &lt;Data value=&quot;aaaaaa&quot;/&gt;
+                  &lt;Data value=&quot;aaaaaa&quot;/&gt;
+                  &lt;Data value=&quot;aaaaab&quot;/&gt;
+                  &lt;Data value=&quot;aaaaab&quot;/&gt;
+                  &lt;Data value=&quot;aaaaab&quot;/&gt;
+                  &lt;Data value=&quot;aaaaaccc&quot;/&gt;
+                  &lt;Data value=&quot;aaaaac&quot;/&gt;
+                  &lt;Data value=&quot;aaaaac&quot;/&gt;
+                  &lt;Data value=&quot;aaaaad&quot;/&gt;
+                  &lt;Data value=&quot;aaaaa&quot;/&gt;
+                  &lt;Data value=&quot;aaaaa&quot;/&gt;
+                  &lt;Data value=&quot;aaaaa&quot;/&gt;
+                  &lt;Data value=&quot;aaaaa&quot;/&gt;
+                  &lt;Data value=&quot;aaaaa&quot;/&gt;
+                  &lt;Data value=&quot;aaaaa&quot;/&gt;
+                  &lt;Data value=&quot;aaaaarrrr&quot;/&gt;
+                  &lt;Data value=&quot;aaaaa&quot;/&gt;
+                  &lt;Data value=&quot;aaaaaaaaa&quot;/&gt;
+                  &lt;Data value=&quot;aaaaa&quot;/&gt;
+                &lt;/Column&gt;
+              &lt;/Table&gt;
+            &lt;/Property&gt;
+          &lt;/Properties&gt;
+        &lt;/Component&gt;
+      &lt;/SubComponents&gt;
+    &lt;/Container&gt;
+    &lt;Container class=&quot;javax.swing.JPanel&quot; name=&quot;jPanel1&quot;&gt;
+      &lt;Constraints&gt;
+        &lt;Constraint layoutClass=&quot;org.netbeans.modules.form.compat2.layouts.DesignBorderLayout&quot; value=&quot;org.netbeans.modules.form.compat2.layouts.DesignBorderLayout$BorderConstraintsDescription&quot;&gt;
+          &lt;BorderConstraints direction=&quot;South&quot;/&gt;
+        &lt;/Constraint&gt;
+      &lt;/Constraints&gt;
+
+      &lt;Layout class=&quot;org.netbeans.modules.form.compat2.layouts.DesignGridLayout&quot;&gt;
+        &lt;Property name=&quot;columns&quot; type=&quot;int&quot; value=&quot;0&quot;/&gt;
+        &lt;Property name=&quot;rows&quot; type=&quot;int&quot; value=&quot;1&quot;/&gt;
+      &lt;/Layout&gt;
+      &lt;SubComponents&gt;
+        &lt;Component class=&quot;javax.swing.JTextField&quot; name=&quot;jTextField1&quot;&gt;
+        &lt;/Component&gt;
+        &lt;Component class=&quot;javax.swing.JCheckBox&quot; name=&quot;jCheckBox1&quot;&gt;
+          &lt;Properties&gt;
+            &lt;Property name=&quot;text&quot; type=&quot;java.lang.String&quot; value=&quot;Apply filter&quot;/&gt;
+          &lt;/Properties&gt;
+          &lt;Events&gt;
+            &lt;EventHandler event=&quot;stateChanged&quot; listener=&quot;javax.swing.event.ChangeListener&quot; parameters=&quot;javax.swing.event.ChangeEvent&quot; handler=&quot;jCheckBox1StateChanged&quot;/&gt;
+          &lt;/Events&gt;
+        &lt;/Component&gt;
+      &lt;/SubComponents&gt;
+    &lt;/Container&gt;
+    &lt;Container class=&quot;javax.swing.JPanel&quot; name=&quot;jPanel2&quot;&gt;
+      &lt;Constraints&gt;
+        &lt;Constraint layoutClass=&quot;org.netbeans.modules.form.compat2.layouts.DesignBorderLayout&quot; value=&quot;org.netbeans.modules.form.compat2.layouts.DesignBorderLayout$BorderConstraintsDescription&quot;&gt;
+          &lt;BorderConstraints direction=&quot;North&quot;/&gt;
+        &lt;/Constraint&gt;
+      &lt;/Constraints&gt;
+
+      &lt;Layout class=&quot;org.netbeans.modules.form.compat2.layouts.DesignFlowLayout&quot;/&gt;
+      &lt;SubComponents&gt;
+        &lt;Component class=&quot;javax.swing.JButton&quot; name=&quot;jButton1&quot;&gt;
+          &lt;Properties&gt;
+            &lt;Property name=&quot;text&quot; type=&quot;java.lang.String&quot; value=&quot;Save&quot;/&gt;
+          &lt;/Properties&gt;
+          &lt;Events&gt;
+            &lt;EventHandler event=&quot;actionPerformed&quot; listener=&quot;java.awt.event.ActionListener&quot; parameters=&quot;java.awt.event.ActionEvent&quot; handler=&quot;jButton1ActionPerformed&quot;/&gt;
+          &lt;/Events&gt;
+        &lt;/Component&gt;
+        &lt;Component class=&quot;javax.swing.JButton&quot; name=&quot;jButton2&quot;&gt;
+          &lt;Properties&gt;
+            &lt;Property name=&quot;text&quot; type=&quot;java.lang.String&quot; value=&quot;Load&quot;/&gt;
+          &lt;/Properties&gt;
+          &lt;Events&gt;
+            &lt;EventHandler event=&quot;actionPerformed&quot; listener=&quot;java.awt.event.ActionListener&quot; parameters=&quot;java.awt.event.ActionEvent&quot; handler=&quot;jButton2ActionPerformed&quot;/&gt;
+          &lt;/Events&gt;
+        &lt;/Component&gt;
+      &lt;/SubComponents&gt;
+    &lt;/Container&gt;
+  &lt;/SubComponents&gt;
+&lt;/Form&gt;

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/TestJFrame.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/TestJFrame.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/TestJFrame.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,189 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2004 Nokia. All Rights Reserved.
+ */
+package org.netbeans.swing.etable;
+
+import java.util.Enumeration;
+import java.util.Properties;
+
+/**
+ * This class is for testing purposes only. It is public in order to be
+ * run using java command. It definitelly does not belong here but it confused
+ * the build system when put under test.
+ *
+ * This class should be deleted or moved before this package becomes part
+ * of any API or something.
+ *
+ * @author  David Strupl
+ */
+public class TestJFrame extends javax.swing.JFrame {
+
+    private Properties savedState = new Properties();
+
+    /** Creates new form TestJFrame */
+    public TestJFrame() {
+        initComponents();
+//        eTable1.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
+//        eTable1.setFullyNonEditable(true);
+    }
+    
+    /** This method is called from within the constructor to
+     * initialize the form.
+     * WARNING: Do NOT modify this code. The content of this method is
+     * always regenerated by the Form Editor.
+     */
+    private void initComponents() {//GEN-BEGIN:initComponents
+        jScrollPane1 = new javax.swing.JScrollPane();
+        eTable1 = new org.netbeans.swing.etable.ETable();
+        jPanel1 = new javax.swing.JPanel();
+        jTextField1 = new javax.swing.JTextField();
+        jCheckBox1 = new javax.swing.JCheckBox();
+        jPanel2 = new javax.swing.JPanel();
+        jButton1 = new javax.swing.JButton();
+        jButton2 = new javax.swing.JButton();
+
+        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
+        eTable1.setModel(new javax.swing.table.DefaultTableModel(
+            new Object [][] {
+                {&quot;a&quot;, &quot;x&quot;, &quot;tttttttt&quot;, new Integer(5), &quot;aaaaab&quot;},
+                {&quot;a2&quot;, &quot;y&quot;, &quot;ggggggggg&quot;, new Integer(10), &quot;aaaaaa&quot;},
+                {&quot;b&quot;, &quot;z&quot;, &quot;nnnnnnnn&quot;, new Integer(7), &quot;aaaaaa&quot;},
+                {&quot;b3&quot;, &quot;w&quot;, &quot;mmmmmm&quot;, new Integer(1), &quot;aaaaab&quot;},
+                {&quot;c&quot;, &quot;m&quot;, &quot;kkkkkkkkkk&quot;, new Integer(10000), &quot;aaaaab&quot;},
+                {&quot;c2&quot;, &quot;n&quot;, &quot;kkkkk&quot;, new Integer(4), &quot;aaaaab&quot;},
+                {&quot;d&quot;, &quot;df&quot;, &quot;wwwwwwww&quot;, new Integer(17), &quot;aaaaaccc&quot;},
+                {&quot;d3&quot;, &quot;f&quot;, &quot;ggggggggggggg&quot;, new Integer(13), &quot;aaaaac&quot;},
+                {&quot;e&quot;, &quot;mm&quot;, &quot;hhhhhhhhhhhh&quot;, new Integer(2), &quot;aaaaac&quot;},
+                {&quot;e2&quot;, &quot;mg&quot;, &quot;qqqqqqqqqqq&quot;, new Integer(8), &quot;aaaaad&quot;},
+                {&quot;f&quot;, &quot;q&quot;, &quot;ffffffffffffff&quot;, new Integer(23), &quot;aaaaa&quot;},
+                {&quot;f2&quot;, &quot;dfg&quot;, &quot;nnnnnnnnnnnn&quot;, new Integer(100), &quot;aaaaa&quot;},
+                {&quot;g&quot;, &quot;dfg&quot;, &quot;mmmmmmmmmmm&quot;, new Integer(57), &quot;aaaaa&quot;},
+                {&quot;g2&quot;, &quot;fg&quot;, &quot;qqqqqqqqq&quot;, new Integer(3), &quot;aaaaa&quot;},
+                {&quot;h&quot;, &quot;xb&quot;, &quot;nnnnnnnnnnn&quot;, new Integer(123), &quot;aaaaa&quot;},
+                {&quot;h2&quot;, &quot;sdf&quot;, &quot;asdfasdf&quot;, new Integer(321), &quot;aaaaa&quot;},
+                {&quot;i&quot;, &quot;g&quot;, &quot;fads&quot;, new Integer(42), &quot;aaaaarrrr&quot;},
+                {&quot;i2&quot;, &quot;mn&quot;, &quot;asdf&quot;, new Integer(72), &quot;aaaaa&quot;},
+                {&quot;j&quot;, &quot;we&quot;, &quot;asdfdsafafsdfsd&quot;, new Integer(88), &quot;aaaaaaaaa&quot;},
+                {&quot;j2&quot;, &quot;kl&quot;, &quot;asdfasdfafsdasdfasd&quot;, new Integer(99), &quot;aaaaa&quot;}
+            },
+            new String [] {
+                &quot;Title 1&quot;, &quot;Title 2&quot;, &quot;Title 3&quot;, &quot;Title 4&quot;, &quot;Title 5&quot;
+            }
+        ) {
+            Class[] types = new Class [] {
+                java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Integer.class, java.lang.Object.class
+            };
+            boolean[] canEdit = new boolean [] {
+                false, false, false, false, false
+            };
+
+            public Class getColumnClass(int columnIndex) {
+                return types [columnIndex];
+            }
+
+            public boolean isCellEditable(int rowIndex, int columnIndex) {
+                return canEdit [columnIndex];
+            }
+        });
+        jScrollPane1.setViewportView(eTable1);
+
+        getContentPane().add(jScrollPane1, java.awt.BorderLayout.CENTER);
+
+        jPanel1.setLayout(new java.awt.GridLayout(1, 0));
+
+        jPanel1.add(jTextField1);
+
+        jCheckBox1.setText(&quot;Apply filter&quot;);
+        jCheckBox1.addChangeListener(new javax.swing.event.ChangeListener() {
+            public void stateChanged(javax.swing.event.ChangeEvent evt) {
+                jCheckBox1StateChanged(evt);
+            }
+        });
+
+        jPanel1.add(jCheckBox1);
+
+        getContentPane().add(jPanel1, java.awt.BorderLayout.SOUTH);
+
+        jButton1.setText(&quot;Save&quot;);
+        jButton1.addActionListener(new java.awt.event.ActionListener() {
+            public void actionPerformed(java.awt.event.ActionEvent evt) {
+                jButton1ActionPerformed(evt);
+            }
+        });
+
+        jPanel2.add(jButton1);
+
+        jButton2.setText(&quot;Load&quot;);
+        jButton2.addActionListener(new java.awt.event.ActionListener() {
+            public void actionPerformed(java.awt.event.ActionEvent evt) {
+                jButton2ActionPerformed(evt);
+            }
+        });
+
+        jPanel2.add(jButton2);
+
+        getContentPane().add(jPanel2, java.awt.BorderLayout.NORTH);
+
+        pack();
+    }//GEN-END:initComponents
+
+    private void jCheckBox1StateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_jCheckBox1StateChanged
+        if (jCheckBox1.isSelected()) {
+            eTable1.setQuickFilter(0, jTextField1.getText());
+        } else {
+            eTable1.unsetQuickFilter();
+        }
+    }//GEN-LAST:event_jCheckBox1StateChanged
+
+    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
+        if (! savedState.isEmpty()) {
+            eTable1.readSettings(savedState, &quot;test:&quot;);
+        }
+    }//GEN-LAST:event_jButton2ActionPerformed
+
+    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
+        savedState = new Properties();
+        eTable1.writeSettings(savedState, &quot;test:&quot;);
+        for (Enumeration en = savedState.keys(); en.hasMoreElements(); ) {
+            Object key = en.nextElement();
+            System.out.println(key + &quot; : &quot; + savedState.get(key));
+        }
+    }//GEN-LAST:event_jButton1ActionPerformed
+    
+    /**
+     * @param args the command line arguments
+     */
+    public static void main(String args[]) {
+        java.awt.EventQueue.invokeLater(new Runnable() {
+            public void run() {
+                new TestJFrame().setVisible(true);
+            }
+        });
+    }
+    
+    // Variables declaration - do not modify//GEN-BEGIN:variables
+    private org.netbeans.swing.etable.ETable eTable1;
+    private javax.swing.JButton jButton1;
+    private javax.swing.JButton jButton2;
+    private javax.swing.JCheckBox jCheckBox1;
+    private javax.swing.JPanel jPanel1;
+    private javax.swing.JPanel jPanel2;
+    private javax.swing.JScrollPane jScrollPane1;
+    private javax.swing.JTextField jTextField1;
+    // End of variables declaration//GEN-END:variables
+    
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/columns.gif
===================================================================
(Binary files differ)


Property changes on: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/etable/columns.gif
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/DefaultOutlineCellRenderer.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/DefaultOutlineCellRenderer.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/DefaultOutlineCellRenderer.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,244 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is NetBeans. The Initial Developer of the Original
+ * Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+ * Microsystems, Inc. All Rights Reserved.
+ */
+package org.netbeans.swing.outline;
+
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Insets;
+import javax.swing.BorderFactory;
+import javax.swing.Icon;
+import javax.swing.JTable;
+import javax.swing.UIManager;
+import javax.swing.border.Border;
+import javax.swing.table.DefaultTableCellRenderer;
+import javax.swing.tree.AbstractLayoutCache;
+import javax.swing.tree.TreePath;
+
+/** An outline-aware TableCellRenderer which knows how to paint expansion
+ * handles and indent child nodes an appropriate amount.
+ *
+ * @author  Tim Boudreau
+ */
+public class DefaultOutlineCellRenderer extends DefaultTableCellRenderer {
+    private boolean expanded = false;
+    private boolean leaf = true;
+    private boolean showHandle = true;
+    private int nestingDepth = 0;
+    private static final Border expansionBorder = new ExpansionHandleBorder();
+    
+    /** Creates a new instance of DefaultOutlineTreeCellRenderer */
+    public DefaultOutlineCellRenderer() {
+    }
+    
+    /** Overridden to combine the expansion border (whose insets determine how
+     * much a child tree node is shifted to the right relative to the ancestor
+     * root node) with whatever border is set, as a CompoundBorder.  The expansion
+     * border is also responsible for drawing the expansion icon.  */
+    public final void setBorder (Border b) {
+        if (b == expansionBorder) {
+            super.setBorder(b);
+        } else {
+            super.setBorder(BorderFactory.createCompoundBorder (b, expansionBorder));
+        }
+    }
+    
+    private static Icon getDefaultOpenIcon() {
+	return UIManager.getIcon(&quot;Tree.openIcon&quot;); //NOI18N
+    }
+
+    private static Icon getDefaultClosedIcon() {
+	return UIManager.getIcon(&quot;Tree.closedIcon&quot;); //NOI18N
+    }
+
+    private static Icon getDefaultLeafIcon() {
+	return UIManager.getIcon(&quot;Tree.leafIcon&quot;); //NOI18N
+    }
+    
+    private static Icon getExpandedIcon() {
+        return UIManager.getIcon (&quot;Tree.collapsedIcon&quot;); //NOI18N
+    }
+    
+    private static Icon getCollapsedIcon() {
+        return UIManager.getIcon (&quot;Tree.expandedIcon&quot;); //NOI18N
+    }
+    
+    static int getNestingWidth() {
+        return getExpansionHandleWidth();
+    }
+    
+    static int getExpansionHandleWidth() {
+        return getExpandedIcon().getIconWidth();
+    }
+    
+    static int getExpansionHandleHeight() {
+        return getExpandedIcon().getIconHeight();
+    }
+    
+    private void setNestingDepth (int i) {
+        nestingDepth = i;
+    }
+    
+    private void setExpanded (boolean val) {
+        expanded = val;
+    }
+    
+    private void setLeaf (boolean val) {
+        leaf = val;
+    }
+    
+    private void setShowHandle (boolean val) {
+        showHandle = val;
+    }
+    
+    private boolean isLeaf () {
+        return leaf;
+    }
+    
+    private boolean isExpanded () {
+        return expanded;
+    }
+    
+    private boolean isShowHandle() {
+        return showHandle;
+    }
+    
+    /** Set the nesting depth - the number of path elements below the root.
+     * This is set in getTableCellEditorComponent(), and retrieved by the
+     * expansion border to determine how far to the right to indent the current
+     * node. */
+    private int getNestingDepth() {
+        return nestingDepth;
+    }
+    
+    /** Get a component that can render cells in an Outline.  If 
+     * &lt;code&gt;((Outline) table).isTreeColumnIndex(column)&lt;/code&gt; is true,
+     * it will paint as indented and with an expansion handle if the 
+     * Outline's model returns false from &lt;code&gt;isLeaf&lt;/code&gt; for the
+     * passed value. 
+     * &lt;p&gt;
+     * If the column is not the tree column, its behavior is the same as
+     * DefaultTableCellRenderer.
+     */
+    public Component getTableCellRendererComponent(JTable table, Object value,
+                          boolean isSelected, boolean hasFocus, int row, 
+                          int column) {
+    
+        Component c = (DefaultOutlineCellRenderer) super.getTableCellRendererComponent(
+              table, value, isSelected, hasFocus, row, column);
+        Outline tbl = (Outline) table;
+        if (tbl.isTreeColumnIndex(column)) {
+            AbstractLayoutCache layout = tbl.getLayoutCache();
+            row = tbl.convertRowIndexToModel(row);
+            boolean leaf = tbl.getOutlineModel().isLeaf(value);
+            setLeaf(leaf);
+            setShowHandle(true);
+            TreePath path = layout.getPathForRow(row);
+            boolean expanded = !layout.isExpanded(path);
+            setExpanded (expanded);
+            int nd = path.getPathCount() - (tbl.isRootVisible() ? 1 : 2);
+            if (nd &lt; 0) {
+                nd = 0;
+            }
+            setNestingDepth (nd );
+            RenderDataProvider rendata = tbl.getRenderDataProvider();
+            Icon icon = null;
+            if (rendata != null) {
+                String displayName = rendata.getDisplayName(value);
+                if (displayName != null) {
+                    setText (displayName);
+                }
+                setToolTipText (rendata.getTooltipText(value));
+                Color bg = rendata.getBackground(value);
+                Color fg = rendata.getForeground(value);
+                if (bg != null &amp;&amp; !isSelected) {
+                    setBackground (bg);
+                } else {
+                    setBackground (isSelected ? 
+                        tbl.getSelectionBackground() : tbl.getBackground());
+                }
+                if (fg != null &amp;&amp; !isSelected) {
+                    setForeground (fg);
+                } else {
+                    setForeground (isSelected ? 
+                        tbl.getSelectionForeground() : tbl.getForeground());
+                }
+                icon = rendata.getIcon(value);
+            } 
+            if (icon == null) {
+                if (!leaf) {
+                    if (expanded) {
+                        setIcon (getDefaultClosedIcon());
+                    } else { // ! expanded
+                        setIcon (getDefaultOpenIcon());
+                    }
+                } else { // leaf
+                    setIcon (getDefaultLeafIcon());
+                }
+            } else { // icon != null
+                setIcon(icon);
+            }
+        
+        } else { // ! tbl.isTreeColumnIndex(column)
+            setIcon(null);
+            setShowHandle(false);
+        }
+        return this;
+    }
+    
+    private static class ExpansionHandleBorder implements Border {
+        private Insets insets = new Insets(0,0,0,0);
+        public Insets getBorderInsets(Component c) {
+            DefaultOutlineCellRenderer ren = (DefaultOutlineCellRenderer) c;
+            if (ren.isShowHandle()) {
+                insets.left = getExpansionHandleWidth() + (ren.getNestingDepth() *
+                    getNestingWidth());
+                //Defensively adjust all the insets fields
+                insets.top = 1;
+                insets.right = 1;
+                insets.bottom = 1;
+            } else {
+                //Defensively adjust all the insets fields
+                insets.left = 1;
+                insets.top = 1;
+                insets.right = 1;
+                insets.bottom = 1;
+            }
+            return insets;
+        }
+        
+        public boolean isBorderOpaque() {
+            return false;
+        }
+        
+        public void paintBorder(Component c, java.awt.Graphics g, int x, int y, int width, int height) {
+            DefaultOutlineCellRenderer ren = (DefaultOutlineCellRenderer) c;
+            if (ren.isShowHandle() &amp;&amp; !ren.isLeaf()) {
+                Icon icon = ren.isExpanded() ? getExpandedIcon() : getCollapsedIcon();
+                int iconY;
+                int iconX = ren.getNestingDepth() * getNestingWidth();
+                if (icon.getIconHeight() &lt; height) {
+                    iconY = (height / 2) - (icon.getIconHeight() / 2);
+                } else {
+                    iconY = 0;
+                }
+                icon.paintIcon(c, g, iconX, iconY);
+            }
+        }
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/DefaultOutlineModel.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/DefaultOutlineModel.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/DefaultOutlineModel.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,291 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is NetBeans. The Initial Developer of the Original
+ * Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+ * Microsystems, Inc. All Rights Reserved.
+ */
+package org.netbeans.swing.outline;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Enumeration;
+import java.util.List;
+import javax.swing.event.TableModelEvent;
+import javax.swing.event.TableModelListener;
+import javax.swing.event.TreeExpansionEvent;
+import javax.swing.event.TreeExpansionListener;
+import javax.swing.event.TreeModelEvent;
+import javax.swing.event.TreeModelListener;
+import javax.swing.event.TreeWillExpandListener;
+import javax.swing.table.TableModel;
+import javax.swing.tree.AbstractLayoutCache;
+import javax.swing.tree.ExpandVetoException;
+import javax.swing.tree.FixedHeightLayoutCache;
+import javax.swing.tree.TreeModel;
+import javax.swing.tree.TreePath;
+import javax.swing.tree.VariableHeightLayoutCache;
+
+/** Proxies a standard TreeModel and TableModel, translating events between
+ * the two.  Note that the constructor is not public;  the TableModel that is
+ * proxied is the OutlineModel's own.  To make use of this class, implement
+ * RowModel - that is a mini-table model in which the TreeModel is responsible
+ * for defining the set of rows; it is passed an object from the tree, which
+ * it may use to generate values for the other columns.  Pass that and the
+ * TreeModel you want to use to &lt;code&gt;createOutlineModel&lt;/code&gt;.
+ * &lt;p&gt;
+ * A note on TableModelEvents produced by this model:  There is a slight 
+ * impedance mismatch between TableModelEvent and TreeModelEvent.  When the
+ * tree changes, it is necessary to fire TableModelEvents to update the display.
+ * However, TreeModelEvents support changes to discontiguous segments of the
+ * model (i.e. &quot;child nodes 3, 4 and 9 were deleted&quot;).  TableModelEvents
+ * have no such concept - they operate on contiguous ranges of rows.  Therefore,
+ * one incoming TreeModelEvent may result in more than one TableModelEvent being
+ * fired.  Discontiguous TreeModelEvents will be broken into their contiguous
+ * segments, which will be fired sequentially (in the case of removals, in
+ * reverse order).  So, the example above would generate two TableModelEvents,
+ * the first indicating that row 9 was removed, and the second indicating that
+ * rows 3 and 4 were removed.
+ * &lt;p&gt;
+ * Clients which need to know whether the TableModelEvent they have just 
+ * received is one of a group (perhaps they update some data structure, and
+ * should not do so until the table's state is fully synchronized with that
+ * of the tree model) may call &lt;code&gt;areMoreEventsPending()&lt;/code&gt;.
+ * &lt;p&gt;
+ * In the case of TreeModelEvents which add items to an unexpanded tree node,
+ * a simple value change TableModelEvent will be fired for the row in question
+ * on the tree column index.
+ * &lt;p&gt;
+ * Note also that if the model is large-model, removal events may only indicate
+ * those indices which were visible at the time of removal, because less data
+ * is retained about the position of nodes which are not displayed.  In this
+ * case, the only issue is the accuracy of the scrollbar in the model; in
+ * practice this is a non-issue, since it is based on the Outline's row count,
+ * which will be accurate.
+ * &lt;p&gt;
+ * A note to subclassers, if we even leave this class non-final:  If you do
+ * not use ProxyTableModel and RowMapper (which probably means you are doing
+ * something wrong), &lt;strong&gt;do not fire structural changes from the TableModel&lt;/strong&gt;.
+ * This class is designed such that the TreeModel is entirely in control of the
+ * count and contents of the rows of the table.  It and only it may fire 
+ * structural changes.
+ * &lt;p&gt;
+ * Note that this class enforces access only on the event dispatch thread
+ * with assertions.  All events fired by the underlying table and tree model
+ * must be fired on the event dispatch thread.
+ *
+ * @author  Tim Boudreau
+ */
+public class DefaultOutlineModel implements OutlineModel {
+    private TreeModel treeModel;
+    private TableModel tableModel;
+    private AbstractLayoutCache layout;
+    private TreePathSupport treePathSupport;
+    private EventBroadcaster broadcaster;
+    private String nodesColumnLabel = &quot;Nodes&quot;;
+    //Some constants we use to have a single method handle all translated
+    //event firing
+    private static final int NODES_CHANGED = 0;
+    private static final int NODES_INSERTED = 1;
+    private static final int NODES_REMOVED = 2;
+    private static final int STRUCTURE_CHANGED = 3;
+    
+    //XXX deleteme - string version of the avoid constants debug output:
+    private static final String[] types = new String[] {
+        &quot;nodesChanged&quot;, &quot;nodesInserted&quot;, &quot;nodesRemoved&quot;, &quot;structureChanged&quot;
+    };
+    
+    /** Create a small model OutlineModel using the supplied tree model and row model 
+     * @param treeModel The tree model that is the data model for the expandable
+     *  tree column of an Outline
+     * @param rowModel The row model which will supply values for each row based
+     *  on the tree node in that row in the tree model
+     */
+    public static OutlineModel createOutlineModel(TreeModel treeModel, RowModel rowModel) {
+        return createOutlineModel (treeModel, rowModel, false, null);
+    }
+
+    /** Create an OutlineModel using the supplied tree model and row model,
+     * specifying if it is a large-model tree */
+    public static OutlineModel createOutlineModel(TreeModel treeModel, RowModel rowModel, boolean isLargeModel) {
+        return createOutlineModel (treeModel, rowModel, false, null);
+    }
+    /** Create an OutlineModel using the supplied tree model and row model,
+     * specifying if it is a large-model tree */
+    public static OutlineModel createOutlineModel(TreeModel treeModel, RowModel rowModel, boolean isLargeModel, String nodesColumnLabel) {
+        TableModel tableModel = new ProxyTableModel(rowModel);
+        return new DefaultOutlineModel (treeModel, tableModel, isLargeModel, nodesColumnLabel);
+    }
+    
+    /** Creates a new instance of DefaultOutlineModel.  &lt;strong&gt;&lt;b&gt;Note&lt;/b&gt; 
+     * Do not fire table structure changes from the wrapped TableModel (value
+     * changes are okay).  Changes that affect the number of rows must come
+     * from the TreeModel.   */
+    protected DefaultOutlineModel(TreeModel treeModel, TableModel tableModel, boolean largeModel, String nodesColumnLabel) {
+        this.treeModel = treeModel;
+        this.tableModel = tableModel;
+        if (nodesColumnLabel != null) {
+            this.nodesColumnLabel = nodesColumnLabel;
+        }
+        
+        layout = largeModel ? (AbstractLayoutCache) new FixedHeightLayoutCache() 
+            : (AbstractLayoutCache) new VariableHeightLayoutCache();
+            
+        broadcaster = new EventBroadcaster (this);
+        
+        layout.setRootVisible(true);
+        layout.setModel(this);
+        treePathSupport = new TreePathSupport(this, layout);
+        treePathSupport.addTreeExpansionListener(broadcaster);
+        treePathSupport.addTreeWillExpandListener(broadcaster);
+        treeModel.addTreeModelListener(broadcaster);
+        tableModel.addTableModelListener(broadcaster);
+        if (tableModel instanceof ProxyTableModel) {
+            ((ProxyTableModel) tableModel).setOutlineModel(this);
+        }
+    }
+    
+    public final TreePathSupport getTreePathSupport() {
+        return treePathSupport;
+    }    
+    
+    public final AbstractLayoutCache getLayout() {
+        return layout;
+    }
+    
+    public boolean areMoreEventsPending() {
+        return broadcaster.areMoreEventsPending();
+    }
+    
+    /** Accessor for EventBroadcaster */
+    TreeModel getTreeModel() {
+        return treeModel;
+    }
+    
+    /** Accessor for EventBroadcaster */
+    TableModel getTableModel() {
+        return tableModel;
+    }
+    
+    public final Object getChild(Object parent, int index) {
+        return treeModel.getChild (parent, index);
+    }
+    
+    public final int getChildCount(Object parent) {
+        return treeModel.getChildCount (parent);
+    }
+    
+    /** Delegates to the RowMapper for &gt; 0 columns; column 0 always
+     * returns Object.class */
+    public final Class getColumnClass(int columnIndex) {
+        if (columnIndex == 0) {
+            return Object.class;
+        } else {
+            return tableModel.getColumnClass(columnIndex-1);
+        }
+    }
+    
+    public final int getColumnCount() {
+        return tableModel.getColumnCount()+1;
+    }
+    
+    public String getColumnName(int columnIndex) {
+        if (columnIndex == 0) {
+            return nodesColumnLabel;
+        } else {
+            return tableModel.getColumnName(columnIndex-1);
+        }
+    }
+    
+    public final int getIndexOfChild(Object parent, Object child) {
+        return treeModel.getIndexOfChild(parent, child);
+    }
+    
+    public final Object getRoot() {
+        return treeModel.getRoot();
+    }
+    
+    public final int getRowCount() {
+        return layout.getRowCount();
+    }
+    
+    public final Object getValueAt(int rowIndex, int columnIndex) {
+        Object result;
+        if (columnIndex == 0) { //XXX need a column ID - columnIndex = 0 depends on the column model
+            TreePath path = getLayout().getPathForRow(rowIndex);
+            if (path != null) {
+                result = path.getLastPathComponent();
+            } else {
+                result = null;
+            }
+        } else {
+            result = (tableModel.getValueAt(rowIndex, columnIndex -1));
+        }
+        return result;
+    }
+    
+    public boolean isCellEditable(int rowIndex, int columnIndex) {
+        if (columnIndex == 0) {
+            return false; //XXX support editing of node names
+        } else {
+            return tableModel.isCellEditable(rowIndex, columnIndex-1);
+        }
+    }
+    
+    public final boolean isLeaf(Object node) {
+        return treeModel.isLeaf(node);
+    }
+
+    /** Delegates to the EventBroadcaster for this model */
+    public final synchronized void addTableModelListener(TableModelListener l) {
+        broadcaster.addTableModelListener (l);
+    }
+    
+    /** Delegates to the EventBroadcaster for this model */
+    public final synchronized void addTreeModelListener(TreeModelListener l) {
+        broadcaster.addTreeModelListener (l);
+    }    
+    
+    /** Delegates to the EventBroadcaster for this model */
+    public final synchronized void removeTableModelListener(TableModelListener l) {
+        broadcaster.removeTableModelListener(l);
+    }
+    
+    /** Delegates to the EventBroadcaster for this model */
+    public final synchronized void removeTreeModelListener(TreeModelListener l) {
+        broadcaster.removeTreeModelListener(l);
+    }
+    
+    /** Delegates to the RowModel (or TableModel) for non-0 columns */
+    public final void setValueAt(Object aValue, int rowIndex, int columnIndex) {
+        if (columnIndex != 0) {
+            tableModel.setValueAt (aValue, rowIndex, columnIndex-1);
+        } else {
+            //XXX do something
+        }
+    }
+    
+    public final void valueForPathChanged(javax.swing.tree.TreePath path, Object newValue) {
+        //if the model is correctly implemented, this will trigger a change
+        //event
+        treeModel.valueForPathChanged(path, newValue);
+    }
+
+    public boolean isLargeModel() {
+        return layout instanceof FixedHeightLayoutCache;
+    }
+    
+
+    
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/EventBroadcaster.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/EventBroadcaster.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/EventBroadcaster.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,1052 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is NetBeans. The Initial Developer of the Original
+ * Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+ * Microsystems, Inc. All Rights Reserved.
+ */
+package org.netbeans.swing.outline;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import javax.swing.SwingUtilities;
+import javax.swing.event.TableModelEvent;
+import javax.swing.event.TableModelListener;
+import javax.swing.event.TreeExpansionEvent;
+import javax.swing.event.TreeExpansionListener;
+import javax.swing.event.TreeModelEvent;
+import javax.swing.event.TreeModelListener;
+import javax.swing.table.TableModel;
+import javax.swing.tree.AbstractLayoutCache;
+import javax.swing.tree.ExpandVetoException;
+import javax.swing.tree.TreeModel;
+import javax.swing.tree.TreePath;
+
+/** Responsible for handling tree model events from the user-supplied treemodel
+ * portion of a DefaultOutlineModel, translating them into appropriate 
+ * TableModelEvents and refiring these events to listeners on the table model.
+ * &lt;p&gt;
+ * This class could be (and originally was) incorporated directly into 
+ * DefaultOutlineModel, but is separated for better readability and separation
+ * of concerns.
+ *
+ * @author  Tim Boudreau
+ */
+final class EventBroadcaster implements TableModelListener, TreeModelListener, ExtTreeWillExpandListener, TreeExpansionListener {
+    
+    /** Debugging constant for whether logging should be enabled */
+    static boolean log = false;
+    
+    /** Debugging message counter to differentiate log entries */
+    private int logcount = 0;
+    
+    /** The model we will proxy */
+    private DefaultOutlineModel model;
+    
+    /** The last event sent to treeWillExpand/Collapse, used to compare against the
+     * next value sent to treeExpanded/Collapse */
+    private TreeExpansionEvent inProgressEvent = null;
+    
+    /** A TableModelEvent generated in treeWillExpand/Collapse (so, generated when
+     * data about the rows/columns in the tree model is still in sync with the
+     * TableModel), which will be fired from treeExpanded/Collapsed if the
+     * expansion event is not vetoed */
+    private TableModelEvent pendingExpansionEvent = null;
+
+    /** Are we in the middle of firing multiple TableModelEvents for a single
+     * TreeModelEvent. */
+    private boolean inMultiEvent = false;
+    
+    //Some constants we use to have a single method handle all translated
+    //event firing
+    private static final int NODES_CHANGED = 0;
+    private static final int NODES_INSERTED = 1;
+    private static final int NODES_REMOVED = 2;
+    private static final int STRUCTURE_CHANGED = 3;
+    
+    //XXX deleteme - string version of the avoid constants debug output:
+    private static final String[] types = new String[] {
+        &quot;nodesChanged&quot;, &quot;nodesInserted&quot;, &quot;nodesRemoved&quot;, &quot;structureChanged&quot;
+    }; //NOI18N
+
+    /** List of table model listeners */
+    private List tableListeners = new ArrayList();
+    
+    /** List of tree model listeners */
+    private List treeListeners = new ArrayList();
+    
+    
+    /** Creates a new instance of EventBroadcaster which will
+     * produce events for the passed DefaultOutlineModel model.  */
+    public EventBroadcaster(DefaultOutlineModel model) {
+        setModel (model);
+    }
+    
+    /** Debug logging */
+    private void log (String method, Object o) {
+        if (log) {
+            if (o instanceof TableModelEvent) {
+                //TableModelEvents just give their hash code in toString()
+                o = tableModelEventToString ((TableModelEvent) o);
+            }
+            System.err.println(&quot;EB-&quot; + (logcount++) + &quot; &quot; + method + &quot;:&quot; + 
+                (o instanceof String ? 
+                (String) o : o.toString()));
+        }
+    }
+    
+    
+//***************** Bean properties/convenience getters &amp; setters ************    
+    /** Flag which is set to true while multiple TableModelEvents generated
+     * from a single TreeModelEvent are being fired, so clients can avoid
+     * any model queries until all pending changes have been fired.  The
+     * main thing to avoid is any mid-process repaints, which can only happen
+     * if the response to an event will be to call paintImmediately(). 
+     * &lt;p&gt;
+     * This value is guaranteed to be true for the first of a group of
+     * related events, and false if tested in response to the final event.
+     */
+    public boolean areMoreEventsPending() {
+        return inMultiEvent;
+    }
+    
+    /** Get the outline model for which this broadcaster will proxy events*/
+    private DefaultOutlineModel getModel() {
+        return model;
+    }
+    
+    /** Set the outline model this broadcaster will proxy events for */
+    private void setModel(DefaultOutlineModel model) {
+        this.model = model;
+    }
+    
+    /** Convenience getter for the proxied model's layout cache */
+    private AbstractLayoutCache getLayout() {
+        return getModel().getLayout();
+    }
+    
+    /** Convenience getter for the proxied model's TreePathSupport */
+    private TreePathSupport getTreePathSupport() {
+        return getModel().getTreePathSupport();
+    }
+    
+    /** Convenience getter for the proxied model's user-supplied TreeModel */
+    private TreeModel getTreeModel() {
+        return getModel().getTreeModel();
+    }
+    
+    /** Convenience getter for the proxied model's user-supplied TableModel (in
+     * practice, an instance of ProxyTableModel driven by the tree model and a
+     * RowModel) */
+    private TableModel getTableModel() {
+        return getModel().getTableModel();
+    }
+   
+    
+    
+//******************* Event source implementation **************************
+    
+    /** Add a table model listener.  All events fired by this EventBroadcaster
+     * will have the OutlineModel as the event source */
+    public synchronized void addTableModelListener(TableModelListener l) {
+        tableListeners.add (l);
+    }
+    
+    /** Add a tree model listener.  All events fired by this EventBroadcaster
+     * will have the OutlineModel as the event source */
+    public synchronized void addTreeModelListener(TreeModelListener l) {
+        treeListeners.add (l);
+    }    
+    
+    /** Remove a table model listener.  */
+    public synchronized void removeTableModelListener(TableModelListener l) {
+        tableListeners.remove(l);
+    }
+    
+    /** Remove a tree model listener.  */
+    public synchronized void removeTreeModelListener(TreeModelListener l) {
+        treeListeners.remove(l);
+    }
+    
+    /** Fire a table change to the list of listeners supplied. The event should
+     * already have its source set to be the OutlineModel we're proxying for. */
+    private void fireTableChange (TableModelEvent e, TableModelListener[] listeners) {
+        //Event may be null for offscreen info, etc.
+        if (e == null) {
+            return;
+        }
+        
+        assert (e.getSource() == getModel());
+        
+        log (&quot;fireTableChange&quot;, e);
+        
+        for (int i=0; i &lt; listeners.length; i++) {
+            listeners[i].tableChanged(e);
+        }
+    }
+    
+    /** Convenience method to fire a single table change to all listeners */
+    private void fireTableChange (TableModelEvent e) {
+        //Event may be null for offscreen info, etc.
+        if (e == null) {
+            return;
+        }
+        inMultiEvent = false;
+        TableModelListener[] listeners = getTableModelListeners();
+        fireTableChange(e, getTableModelListeners());
+    }
+    
+    /** Fires multiple table model events, setting the inMultiEvent flag
+     * as appropriate. */
+    private void fireTableChange (TableModelEvent[] e) {
+        //Event may be null for offscreen info, etc.
+        if (e == null || e.length==0) {
+            return;
+        }
+        
+        TableModelListener[] listeners = getTableModelListeners();
+        inMultiEvent = e.length &gt; 1;
+        try {
+            for (int i=0; i &lt; e.length; i++) {
+                fireTableChange (e[i], listeners);
+                if (i == e.length-1) {
+                    inMultiEvent = false;
+                }
+            }
+        } finally {
+            inMultiEvent = false;
+        }
+    }
+    
+    /** Fetch an array of the currently registered table model listeners */
+    private TableModelListener[] getTableModelListeners() {
+        TableModelListener[] listeners = null;
+        synchronized (this) {
+            listeners = new TableModelListener[
+                tableListeners.size()];
+            
+            listeners = (TableModelListener[]) 
+                tableListeners.toArray(listeners);
+        }
+        return listeners;
+    }
+    
+    /** Fire the passed TreeModelEvent of the specified type to all
+     * registered TreeModelListeners.  The passed event should already have
+     * its source set to be the model. */
+    private synchronized void fireTreeChange (TreeModelEvent e, int type) {
+        //Event may be null for offscreen info, etc.
+        if (e == null) {
+            return;
+        }
+        assert (e.getSource() == getModel());
+        
+        TreeModelListener[] listeners = null;
+        synchronized (this) {
+            listeners = new TreeModelListener[treeListeners.size()];
+            listeners = (TreeModelListener[]) treeListeners.toArray(listeners);
+        }
+        
+        log (&quot;fireTreeChange-&quot; + types[type], e);
+        
+        //Now refire it to any listeners
+        for (int i=0; i &lt; listeners.length; i++) {
+            switch (type) {
+                case NODES_CHANGED :
+                    listeners[i].treeNodesChanged(e);
+                    break;
+                case NODES_INSERTED :
+                    listeners[i].treeNodesInserted(e);
+                    break;
+                case NODES_REMOVED :
+                    listeners[i].treeNodesRemoved(e);
+                    break;
+                case STRUCTURE_CHANGED :
+                    listeners[i].treeStructureChanged(e);
+                    break;
+                default :
+                    assert false;
+            }
+        }
+    }    
+    
+//******************* Event listener implementations ************************    
+    
+    /** Process a change event from the user-supplied tree model.  This
+     * method will throw an assertion failure if it receives any event type
+     * other than TableModelEvent.UPDATE - the ProxyTableModel should never,
+     * ever fire structural changes - only the tree model is allowed to do
+     * that. */
+    public void tableChanged(TableModelEvent e) {
+        assert SwingUtilities.isEventDispatchThread();
+        //The *ONLY* time we should see events here is due to user
+        //data entry.  The ProxyTableModel should never change out
+        //from under us - all structural changes happen through the
+        //table model.
+        assert (e.getType() == e.UPDATE) : &quot;Table model should only fire &quot; +
+            &quot;updates, never structural changes&quot;;
+        
+        fireTableChange (translateEvent(e));
+    }
+    
+    /** Process a change event from the user-supplied tree model.
+     * Order of operations: 
+     * &lt;ol&gt;&lt;li&gt;Refire the same tree event with the OutlineModel we're
+     *   proxying as the source&lt;/li&gt;
+     * &lt;li&gt;Create one or more table model events (more than one if the
+     * incoming event affects discontiguous rows) reflecting the effect
+     * of the tree change&lt;/li&gt;
+     * &lt;li&gt;Call the method with the same signature as this one on the
+     * layout cache, so it will update its state appropriately&lt;/li&gt;
+     * &lt;li&gt;Fire the generated TableModelEvent(s)&lt;/li&gt;&lt;/ol&gt;
+     */
+    public void treeNodesChanged(TreeModelEvent e) {
+        assert SwingUtilities.isEventDispatchThread();
+        
+        fireTreeChange (translateEvent(e), NODES_CHANGED);
+        
+        TableModelEvent[] events = translateEvent(e, NODES_CHANGED);
+        getLayout().treeNodesChanged(e);
+        fireTableChange(events);
+    }
+    
+    /** Process a node insertion event from the user-supplied tree model 
+     * Order of operations: 
+     * &lt;ol&gt;&lt;li&gt;Refire the same tree event with the OutlineModel we're
+     *   proxying as the source&lt;/li&gt;
+     * &lt;li&gt;Create one or more table model events (more than one if the
+     * incoming event affects discontiguous rows) reflecting the effect
+     * of the tree change&lt;/li&gt;
+     * &lt;li&gt;Call the method with the same signature as this one on the
+     * layout cache, so it will update its state appropriately&lt;/li&gt;
+     * &lt;li&gt;Fire the generated TableModelEvent(s)&lt;/li&gt;&lt;/ol&gt;
+     */
+    public void treeNodesInserted(TreeModelEvent e) {
+        assert SwingUtilities.isEventDispatchThread();
+        
+        fireTreeChange (translateEvent(e), NODES_INSERTED);
+        
+        TableModelEvent[] events = translateEvent(e, NODES_INSERTED);
+        getLayout().treeNodesInserted(e);
+        fireTableChange(events);
+    }
+    
+    /** Process a node removal event from the user-supplied tree model 
+     * Order of operations: 
+     * &lt;ol&gt;&lt;li&gt;Refire the same tree event with the OutlineModel we're
+     *   proxying as the source&lt;/li&gt;
+     * &lt;li&gt;Create one or more table model events (more than one if the
+     * incoming event affects discontiguous rows) reflecting the effect
+     * of the tree change&lt;/li&gt;
+     * &lt;li&gt;Call the method with the same signature as this one on the
+     * layout cache, so it will update its state appropriately&lt;/li&gt;
+     * &lt;li&gt;Fire the generated TableModelEvent(s)&lt;/li&gt;&lt;/ol&gt;
+     */
+    public void treeNodesRemoved(TreeModelEvent e) {
+        assert SwingUtilities.isEventDispatchThread();
+        
+        fireTreeChange (translateEvent(e), NODES_REMOVED);
+        
+        TableModelEvent[] events = translateEvent(e, NODES_REMOVED);
+        getLayout().treeNodesRemoved(e);
+        fireTableChange(events);
+    }
+    
+    /** Process a structural change event from the user-supplied tree model.
+     * This will result in a generic &quot;something changed&quot; 
+     * TableModelEvent being fired.  */
+    public void treeStructureChanged(TreeModelEvent e) {
+        assert SwingUtilities.isEventDispatchThread();
+        
+        getLayout().treeStructureChanged(e);
+        fireTreeChange (translateEvent(e), STRUCTURE_CHANGED);
+        
+        //If it's a structural change, we need to dump all our info about the
+        //existing tree structure - it can be bogus now.  Similar to JTree,
+        //this will have the effect of collapsing all expanded paths.  The
+        //TreePathSupport takes care of dumping the layout cache's copy of
+        //such data
+        getTreePathSupport().clear();
+        
+        //We will just fire a &quot;Something happened. Go figure out what.&quot; event.
+        fireTableChange (new TableModelEvent (getModel()));
+    }
+    
+    /** Receives a TreeWillCollapse event and constructs a TableModelEvent
+     * based on the pending changes while the model still reflects the unchanged
+     * state */
+    public void treeWillCollapse(TreeExpansionEvent event) throws ExpandVetoException {
+        assert SwingUtilities.isEventDispatchThread();
+        
+        log (&quot;treeWillCollapse&quot;, event);
+        
+        //Construct the TableModelEvent here, before data structures have
+        //changed.  We will fire it from TreeCollapsed if the change is 
+        //not vetoed.
+        pendingExpansionEvent = translateEvent (event, false);
+        log (&quot;treeWillCollapse generated &quot;, pendingExpansionEvent);
+        inProgressEvent = event;
+    }
+    
+    /** Receives a TreeWillExpand event and constructs a TableModelEvent
+     * based on the pending changes while the model still reflects the unchanged
+     * state */
+    public void treeWillExpand(TreeExpansionEvent event) throws ExpandVetoException {
+        assert SwingUtilities.isEventDispatchThread();
+
+        log (&quot;treeWillExpand&quot;, event);
+        
+        //Construct the TableModelEvent here, before data structures have
+        //changed.  We will fire it from TreeExpanded if the change is not
+        //vetoed
+        pendingExpansionEvent = translateEvent (event, true);
+        
+        log (&quot;treeWillExpand generated&quot;, pendingExpansionEvent);
+        inProgressEvent = event;
+    }
+
+    public void treeCollapsed(TreeExpansionEvent event) {
+        assert SwingUtilities.isEventDispatchThread();
+
+        log (&quot;treeExpanded&quot;, event);
+        
+        //FixedHeightLayoutCache tests if the event is null.
+        //Don't know how it could be, but there's probably a reason...
+        if(event != null) {
+            TreePath path = event.getPath();
+
+            //Tell the layout about the change
+            if(path != null &amp;&amp; getTreePathSupport().isVisible(path)) {
+                getLayout().setExpandedState(path, false);
+            }
+        }
+
+        
+        log (&quot;about to fire&quot;, pendingExpansionEvent);
+        
+        //Now fire a change on the owning row so its display is updated (it
+        //may have just become an expandable node)
+        TreePath path = event.getPath();
+        int row = getLayout().getRowForPath(path);
+        TableModelEvent evt = new TableModelEvent (getModel(), row, row, 0,
+            TableModelEvent.UPDATE);
+        fireTableChange(new TableModelEvent[] {evt, pendingExpansionEvent});
+        
+        pendingExpansionEvent = null;
+        inProgressEvent = null;
+    }
+    
+    /** Updates the layout to mark the descendants of the events path as also
+     * expanded if they were the last it was expanded, then fires a table change. */
+    public void treeExpanded(TreeExpansionEvent event) {
+        assert SwingUtilities.isEventDispatchThread();
+        
+        log (&quot;treeExpanded&quot;, event);
+        
+        //Mysterious how the event could be null, but JTree tests it
+        //so we will too.
+        if(event != null) {
+            updateExpandedDescendants(event.getPath());
+        }
+
+        log (&quot;about to fire&quot;, pendingExpansionEvent);
+        
+        //Now fire a change on the owning row so its display is updated (it
+        //may have just become an expandable node)
+        TreePath path = event.getPath();
+        int row = getLayout().getRowForPath(path);
+        TableModelEvent evt = new TableModelEvent (getModel(), row, row, 0,
+            TableModelEvent.UPDATE);
+        if (row == -1) {
+            evt = new TableModelEvent(getModel());
+        }
+        fireTableChange(new TableModelEvent[] {evt, pendingExpansionEvent});
+        
+        pendingExpansionEvent = null;
+        inProgressEvent = null;
+    }
+    
+    /** Messaged if the tree expansion event (for which we will have already
+     * constructed a TableModelEvent) was vetoed;  disposes of the constructed
+     * TableModelEvent in that circumstance. */
+    public void treeExpansionVetoed(TreeExpansionEvent event, ExpandVetoException exception) {
+        assert SwingUtilities.isEventDispatchThread();
+        
+        log (&quot;treeExpansionVetoed&quot;, exception);
+        
+        //Make sure the event that was vetoed is the one we're interested in
+        if (event == inProgressEvent) {
+            //If so, delete the expansion event we thought we were going
+            //to use in treeExpanded/treeCollapsed, so that it doesn't
+            //stick around forever holding references to objects from the
+            //model
+            pendingExpansionEvent = null;
+            inProgressEvent = null;
+        }
+    }
+    
+//******************* Support routines for handling events ******************
+    //do I date myself by using the word &quot;routines&quot;? :-)
+
+    /** Re&euml;expand descendants of a newly expanded path which were
+     * expanded the last time their parent was expanded */
+    private void updateExpandedDescendants(TreePath path) {
+        getLayout().setExpandedState(path, true);
+
+        TreePath[] descendants = 
+            getTreePathSupport().getExpandedDescendants(path);
+
+        if(descendants.length &gt; 0) {
+            for (int i=0; i &lt; descendants.length; i++) {
+                getLayout().setExpandedState(descendants[i], true);
+            }
+        }
+    }    
+
+    
+//******************* Event translation routines ****************************
+    
+    /** Creates a TableModelEvent identical to the original except that the
+     * column index has been shifted by +1.  This is used to refire events
+     * from the ProxyTableModel (generated by RowModel.setValueFor()) as 
+     * change events on the OutlineModel. */
+    private TableModelEvent translateEvent (TableModelEvent e) {
+        TableModelEvent nue = new TableModelEvent (getModel(),
+            e.getFirstRow(), e.getLastRow(), e.getColumn()+1, e.getType());
+        return nue;
+    }
+    
+    /** Creates an identical TreeModelEvent with the model we are proxying
+     * as the event source */
+    private TreeModelEvent translateEvent (TreeModelEvent e) {
+        //Create a new TreeModelEvent with us as the source
+        TreeModelEvent nue = new TreeModelEvent (getModel(), e.getPath(), 
+            e.getChildIndices(), e.getChildren());
+        return nue;
+    }
+    
+    /** Tranlates a TreeModelEvent into one or more contiguous TableModelEvents 
+     */
+    private TableModelEvent[] translateEvent (TreeModelEvent e, int type) {
+
+        TreePath path = e.getTreePath();
+        int row = getLayout().getRowForPath(path);
+        
+        //If the node is not expanded, we simply fire a change
+        //event for the parent
+        boolean inClosedNode = !getLayout().isExpanded(path);
+        if (inClosedNode) {
+            //If the node is closed, no expensive checks are needed - just
+            //fire a change on the parent node in case it needs to update
+            //its display
+            if (row != -1) {
+                switch (type) {
+                    case NODES_CHANGED :
+                    case NODES_INSERTED :
+                    case NODES_REMOVED :
+                        return new TableModelEvent[] {
+                            new TableModelEvent (getModel(), row, row,
+                              0, TableModelEvent.UPDATE)
+                        };
+                    default: 
+                        assert false : &quot;Unknown event type &quot; + type;
+                }
+            }
+            //In a closed node that is not visible, no event needed
+            return new TableModelEvent[0];
+        }
+        
+        boolean discontiguous = isDiscontiguous(e);
+        
+        Object[] blocks;
+        if (discontiguous) {
+            blocks = getContiguousIndexBlocks(e, type == NODES_REMOVED);
+            log (&quot;discontiguous &quot; + types[type] + &quot; event&quot;, blocks.length + &quot; blocks&quot;);
+        } else {
+            blocks = new Object[] {e.getChildIndices()};
+        }
+        
+        
+        TableModelEvent[] result = new TableModelEvent[blocks.length];
+        for (int i=0; i &lt; blocks.length; i++) {
+            
+            int[] currBlock = (int[]) blocks[i];
+            switch (type) {
+                case NODES_CHANGED :
+                    result[i] = createTableChangeEvent (e, currBlock);
+                    break;
+                case NODES_INSERTED :
+                    result[i] = createTableInsertionEvent (e, currBlock);
+                    break;
+                case NODES_REMOVED :
+                    result[i] = createTableDeletionEvent (e, currBlock);
+                    break;
+                default :
+                    assert false : &quot;Unknown event type: &quot; + type;
+            }            
+        }
+        log (&quot;translateEvent&quot;, e);
+        log (&quot;generated table events&quot;, new Integer(result.length));
+        if (log) {
+            for (int i=0; i &lt; result.length; i++) {
+                log (&quot;  Event &quot; + i, result[i]);
+            }
+        }
+        return result;
+    }
+    
+    /** Translates tree expansion event into an appropriate TableModelEvent
+     * indicating the number of rows added/removed at the appropriate index */
+    private TableModelEvent translateEvent (TreeExpansionEvent e, boolean expand) {
+        //PENDING:  This code should be profiled - the descendent paths search
+        //is not cheap, and it might be less expensive (at least if the table
+        //does not have expensive painting logic) to simply fire a generic
+        //&quot;something changed&quot; table model event and be done with it.
+        
+        TreePath path = e.getPath();
+        
+        //Add one because it is a child of the row.
+        int firstRow = getLayout().getRowForPath(path) + 1;
+        if (firstRow == -1) {
+            //This does not mean nothing happened, it may just be that we are
+            //a large model tree, and the FixedHeightLayoutCache says the
+            //change happened in a row that is not showing.
+            
+            //TODO:  Just to make the table scrollbar adjust itself appropriately,
+            //we may want to look up the number of children in the model and
+            //fire an event that says that that many rows were added.  Waiting
+            //to see if anybody actually will use this (i.e. fires changes in
+            //offscreen nodes as a normal part of usage
+            return null;
+        }
+        
+        //Get all the expanded descendants of the path that was expanded/collapsed
+        TreePath[] paths = getTreePathSupport().getExpandedDescendants(path);
+        
+        //Start with the number of children of whatever was expanded/collapsed
+        int count = getTreeModel().getChildCount(path.getLastPathComponent());
+        
+        //Iterate any of the expanded children, adding in their child counts
+        for (int i=0; i &lt; paths.length; i++) {
+            count += getTreeModel().getChildCount(paths[i].getLastPathComponent());
+        }
+        
+        //Now we can calculate the last row affected for real
+        int lastRow = firstRow + count -1;
+        
+        //Construct a table model event reflecting this data
+        TableModelEvent result = new TableModelEvent (getModel(), firstRow, lastRow, 
+            TableModelEvent.ALL_COLUMNS, expand ? TableModelEvent.INSERT : 
+            TableModelEvent.DELETE);
+            
+        return result;
+    }
+
+    /** Create a change TableModelEvent for the passed TreeModelEvent and the 
+     * contiguous subrange of the TreeModelEvent's getChildIndices() value */
+    private TableModelEvent createTableChangeEvent (TreeModelEvent e, int[] indices) {
+        TableModelEvent result = null;
+        TreePath path = e.getTreePath();
+        int row = getLayout().getRowForPath(path);
+        
+        int first = indices[0];
+        int last = indices[indices.length-1];
+        
+        //TODO - does not need to be ALL_COLUMNS, but we need a way to determine
+        //which column index is the tree
+        result = new TableModelEvent (getModel(), first, last, 
+            TableModelEvent.ALL_COLUMNS, TableModelEvent.UPDATE);
+        
+        return result;
+    }
+    
+    /** Create an insertion TableModelEvent for the passed TreeModelEvent and the 
+     * contiguous subrange of the TreeModelEvent's getChildIndices() value */
+    private TableModelEvent createTableInsertionEvent (TreeModelEvent e, int[] indices) {
+        TableModelEvent result = null;
+
+        log (&quot;createTableInsertionEvent&quot;, e);
+        
+        TreePath path = e.getTreePath();
+        int row = getLayout().getRowForPath(path);
+        
+        boolean realInsert = getLayout().isExpanded(path);
+
+        if (realInsert) {
+            if (indices.length == 1) {
+                //Only one index to change, fire a simple event.  It
+                //will be the first index in the array + the row +
+                //1 because the 0th child of a node is 1 greater than
+                //its row index
+                int affectedRow = row + indices[0] + 1;
+                result = new TableModelEvent (getModel(), affectedRow, affectedRow, 
+                    TableModelEvent.ALL_COLUMNS, TableModelEvent.INSERT);
+
+            } else {
+                //Find the first and last indices.  Add one since it is at 
+                //minimum the first index after the affected row, since it
+                //is a child of it.
+                int lowest = indices[0] + 1;
+                int highest = indices[indices.length-1] + 1;
+                result = new TableModelEvent (getModel(), row + lowest, row + highest,
+                    TableModelEvent.ALL_COLUMNS, TableModelEvent.INSERT);
+
+            }
+        } else {
+            //Nodes were inserted in an unexpanded parent.  Just fire
+            //a change for that row and column so that it gets repainted
+            //in case the node there changed from leaf to non-leaf
+            result = new TableModelEvent (getModel(), row, row, 
+                TableModelEvent.ALL_COLUMNS); //TODO - specify only the tree column
+        }        
+        return result;
+    }
+    
+    
+    /** Create a deletion TableModelEvent for the passed TreeModelEvent and the 
+     * contiguous subrange of the TreeModelEvent's getChildIndices() value */
+    private TableModelEvent createTableDeletionEvent (TreeModelEvent e, int[] indices) {
+        TableModelEvent result = null;
+        
+        log (&quot;createTableDeletionEvent &quot; + Arrays.asList(toArrayOfInteger(indices)), e);
+        
+        TreePath path = e.getTreePath();
+        int row = getLayout().getRowForPath(path);
+        if (row == -1) {
+            //XXX could calculate based on last visible row?
+            return null;
+        }
+        
+        int countRemoved = indices.length;
+        
+        //Get the subset of the children in the event that correspond
+        //to the passed indices
+        Object[] children = getChildrenForIndices(e, indices);
+        
+        for (int i=0; i &lt; children.length; i++) {
+            TreePath childPath = path.pathByAddingChild(children[i]);
+            if (getTreePathSupport().isExpanded(childPath)) {
+                
+                int visibleChildren = 
+                    getLayout().getVisibleChildCount(childPath);
+                
+                if (log) {
+                    log (childPath + &quot; has &quot;, new Integer(visibleChildren));
+                }
+                
+                countRemoved += visibleChildren;
+            }
+            getTreePathSupport().removePath(path);
+        }
+
+        //Add in the first index, and add one to it since the 0th
+        //will have the row index of its parent + 1
+        int firstRow = row + indices[0] + 1;
+        
+        log (&quot;firstRow&quot;, new Integer(firstRow));
+        /*
+        if (countRemoved == 1) {
+            System.err.println(&quot;Only one removed: &quot; + (row + indices[0] + 1));
+            result = new TableModelEvent (getModel(), firstRow, firstRow, 
+                TableModelEvent.ALL_COLUMNS, 
+                TableModelEvent.DELETE);
+        } else {
+         */
+            System.err.println(&quot;Count removed is &quot; + countRemoved);
+
+            int lastRow = firstRow + (countRemoved - 1);
+
+            System.err.println(&quot;TableModelEvent: fromRow: &quot; + firstRow + &quot; toRow: &quot; + lastRow);
+
+            result = new TableModelEvent (getModel(), firstRow, lastRow,
+                TableModelEvent.ALL_COLUMNS, TableModelEvent.DELETE);        
+        //}
+        
+        /* //old code
+        
+            //Okay, one or more nodes was removed.  The event's tree path
+            //will be the parent.  Now we need to find out about any children
+            //that were also removed so we can create a TreeModelEvent with
+            //the right number of removed rows.
+            
+            //Note there is a slight impedance mismatch between TreeModel and
+            //TableModel here - if we're using a large model layout cache,
+            //we don't actually know what was offscreen - the data is already
+            //gone from the model, so even if we know it was expanded, we
+            //can't find out how many children it had.
+            
+            //The only thing this really affects is the scrollbar, and in
+            //fact, the standard JTable UIs will update it correctly, since
+            //the scrollbar will read getRowCount() to calculate its position.
+            //In theory, this could break on a hyper-efficient TableUI that
+            //attempted to manage scrollbar position *only* based on the
+            //content of table model events.  That's pretty unlikely; but if
+            //it happens, the solution is for Outline.getPreferredSize() to
+            //proxy the preferred size from the layout cache
+            
+            TreePath path = e.getTreePath();
+            boolean lastRemoveWasExpanded = getTreePathSupport().isExpanded(path);
+            int countRemoved = 1;
+            
+            //See if it's expanded - if it wasn't we're just going to blow
+            //away one row anyway
+            if (lastRemoveWasExpanded) {
+                Object[] kids = e.getChildren();
+                
+                //TranslateEvent uses countRemoved to set the TableModelEvent
+                countRemoved = kids.length;
+                
+                //Iterate the removed children
+                for (int i=0; i &lt; kids.length; i++) {
+                    //Get the child's path
+                    TreePath childPath = path.pathByAddingChild(kids[i]);
+                    
+                    //If it's not expanded, we don't care
+                    if (getTreePathSupport().isExpanded(childPath)) {
+                        //Find the number of *visible* children.  This may not
+                        //be all the children, but it's the best information we have.
+                        int visibleChildren = 
+                            getLayout().getVisibleChildCount(childPath);
+
+                        //add in the number of visible children
+                        countRemoved += visibleChildren;
+                    }
+                    //Kill any references to the dead path to avoid memory leaks
+                    getTreePathSupport().removePath(childPath);
+                }
+            }
+            
+            //Tell the layout what happened, now that we've mined it for data
+            //about the visible children of the removed paths
+            getLayout().treeNodesRemoved(e);        
+            
+                boolean realRemove = lastRemoveWasExpanded;//getLayout().isExpanded(path);
+                if (realRemove) {
+                    System.err.println(&quot;Nodes removed from open countainer&quot;);
+                    int[] indices = e.getChildIndices();
+                    
+                    //Comments in FixedHeightLayoutCache suggest we cannot
+                    //assume array is sorted, though it should be
+                    Arrays.sort(indices);
+                    if (indices.length == 0) {
+                        //well, that's a little weird
+                        return null;
+                    } else if (countRemoved == 1) {
+                        System.err.println(&quot;Only one removed: &quot; + (row + indices[0] + 1));
+                        return new TableModelEvent (this, row + indices[0] + 1,
+                            row + indices[0] + 1, TableModelEvent.ALL_COLUMNS, 
+                            TableModelEvent.DELETE);
+                    }
+                    System.err.println(&quot;Count removed is &quot; + countRemoved);
+                    
+                    //Add in the first index, and add one to it since the 0th
+                    //will have the row index of its parent + 1
+                    int firstRow = row + indices[0] + 1;
+                    int lastRow = firstRow + (countRemoved - 1);
+                    
+                    System.err.println(&quot;TableModelEvent: fromRow: &quot; + firstRow + &quot; toRow: &quot; + lastRow);
+                     
+                    return new TableModelEvent (this, firstRow, lastRow,
+                        TableModelEvent.ALL_COLUMNS, TableModelEvent.DELETE);
+                } else {
+                    System.err.println(&quot;Nodes removed from a closed container. Change for row &quot; + row);
+                    //Nodes were removed in an unexpanded parent.  Just fire
+                    //a change for that row and column so that it gets repainted
+                    //in case the node there changed from leaf to non-leaf
+                    TableModelEvent evt = new TableModelEvent (this, row, row, 0); //XXX 0 may not be tree column
+                    System.err.println(&quot; Returning &quot; + evt);
+                    return evt;
+                }        
+         */
+        
+        return result;
+    }
+
+
+//**************** Static utility routines *****************************    
+
+    /** Determine if the indices referred to by a TreeModelEvent are
+     * contiguous.  If they are not, we will need to generate multiple
+     * TableModelEvents for each contiguous block */
+    private static boolean isDiscontiguous (TreeModelEvent e) {
+        int[] indices = e.getChildIndices();
+        if (indices.length == 1) {
+            return false;
+        }
+        Arrays.sort(indices);
+        int lastVal = indices[0];
+        for (int i=1; i &lt; indices.length; i++) {
+            if (indices[i] != lastVal + 1) {
+                return true;
+            } else {
+                lastVal++;
+            }
+        }
+        return false;
+    }
+    
+    /** Returns an array of int[]s each one representing a contiguous set of 
+     * indices in the tree model events child indices - each of which can be
+     * fired as a single TableModelEvent.  The length of the return value is
+     * the number of TableModelEvents required to represent this TreeModelEvent.
+     * If reverseOrder is true (needed for remove events, where the last indices
+     * must be removed first or the indices of later removals will be changed),
+     * the returned int[]s will be sorted in reverse order, and the order in
+     * which they are returned will also be from highest to lowest. */
+    private static Object[] getContiguousIndexBlocks (TreeModelEvent e, boolean reverseOrder) {
+        int[] indices = e.getChildIndices();
+        
+        //Quick check if there's only one index
+        if (indices.length == 1) {
+            return new Object[] {indices};
+        }
+        
+        //The array of int[]s we'll return
+        ArrayList al = new ArrayList();
+        
+        //Sort the indices as requested
+        if (reverseOrder) {
+            inverseSort (indices);
+        } else {
+            Arrays.sort (indices);
+        }
+
+
+        //The starting block
+        ArrayList currBlock = new ArrayList(indices.length / 2);
+        al.add(currBlock);
+        
+        //The value we'll check against the previous one to detect the
+        //end of contiguous segment
+        int lastVal = -1;
+        
+        //Iterate the indices
+        for (int i=0; i &lt; indices.length; i++) {
+            if (i != 0) {
+                //See if we've hit a discontinuity
+                boolean newBlock = reverseOrder ? indices[i] != lastVal - 1 :
+                    indices[i] != lastVal + 1;
+                    
+                if (newBlock) {
+                    currBlock = new ArrayList(indices.length - 1);
+                    al.add(currBlock);
+                }
+            }
+            currBlock.add (new Integer(indices[i]));
+            lastVal = indices[i];
+        }
+        
+        for (int i=0; i &lt; al.size(); i++) {
+            ArrayList curr = (ArrayList) al.get(i);
+            Integer[] ints = (Integer[]) curr.toArray(new Integer[0]);
+            
+            al.set(i, toArrayOfInt(ints));
+        }
+        
+        return al.toArray();
+    }
+    
+    /** Get the children from a TreeModelEvent associated with the set of
+     * indices passed. */
+    private Object[] getChildrenForIndices (TreeModelEvent e, int[] indices) {
+        //XXX performance - better way to do this may be to have
+        //getContinguousIndexBlocks instead construct sub-treemodelevents - 
+        //that would save having to do these iterations later to extract the
+        //children.
+        
+        //At the same time, discontiguous child removals are relatively rare
+        //events - optimizing them heavily may not be a good use of time.
+        Object[] children = e.getChildren();
+        int[] allIndices = e.getChildIndices();
+        
+        ArrayList al = new ArrayList();
+        
+        for (int i=0; i &lt; indices.length; i++) {
+            int pos = Arrays.binarySearch (allIndices, indices[i]);
+            if (pos &gt; -1) {
+                al.add (children[pos]);
+            }
+            if (al.size() == indices.length) {
+                break;
+            }
+        }
+        return al.toArray();
+    }
+    
+    
+    /** Converts an Integer[] to an int[] */
+    private static int[] toArrayOfInt (Integer[] ints) {
+        int[] result = new int[ints.length];
+        for (int i=0; i &lt; ints.length; i++) {
+            result[i] = ints[i].intValue();
+        }
+        return result;
+    }
+    
+    /** Converts an Integer[] to an int[] */
+    //XXX deleteme - used for debug logging only
+    private static Integer[] toArrayOfInteger (int[] ints) {
+        Integer[] result = new Integer[ints.length];
+        for (int i=0; i &lt; ints.length; i++) {
+            result[i] = new Integer(ints[i]);
+        }
+        return result;
+    }
+    
+    
+    /** Sort an array of ints from highest to lowest */
+    private static void inverseSort (int[] array) {
+        //XXX replace with a proper sort algorithm at some point -
+        //this is brute force
+        for (int i=0; i &lt; array.length; i++) {
+            array[i] *= -1;
+        }
+        Arrays.sort(array);
+        for (int i=0; i &lt; array.length; i++) {
+            array[i] *= -1;
+        }
+    }
+    
+    private static String tableModelEventToString (TableModelEvent e) {
+        StringBuffer sb = new StringBuffer();
+        sb.append (&quot;TableModelEvent &quot;);
+        switch (e.getType()) {
+            case TableModelEvent.INSERT : sb.append (&quot;insert &quot;);
+                 break;
+            case TableModelEvent.DELETE : sb.append (&quot;delete &quot;);
+                 break;
+            case TableModelEvent.UPDATE : sb.append (&quot;update &quot;);
+                 break;
+            default : sb.append (&quot;Unknown type &quot; + e.getType());
+        }
+        sb.append (&quot;from &quot;);
+        switch (e.getFirstRow()) {
+            case TableModelEvent.HEADER_ROW : sb.append (&quot;header row &quot;);
+                break;
+            default : sb.append (e.getFirstRow());
+                      sb.append (' ');
+        }
+        sb.append (&quot;to &quot;);
+        sb.append (e.getLastRow());
+        sb.append (&quot; column &quot;);
+        switch (e.getColumn()) {
+            case TableModelEvent.ALL_COLUMNS :
+                sb.append (&quot;ALL_COLUMNS&quot;);
+                break;
+            default : sb.append (e.getColumn());
+        }
+        return sb.toString();
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/ExtTreeWillExpandListener.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/ExtTreeWillExpandListener.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/ExtTreeWillExpandListener.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,44 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is NetBeans. The Initial Developer of the Original
+ * Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+ * Microsystems, Inc. All Rights Reserved.
+ */
+package org.netbeans.swing.outline;
+
+import javax.swing.event.TreeExpansionEvent;
+import javax.swing.event.TreeWillExpandListener;
+import javax.swing.tree.ExpandVetoException;
+
+/** A trivial extension to TreeWillExpandListener, to allow listeners to be
+ * notified if another TreeWillExpandListener vetos a pending expansion.
+ * If a TreeExpansionListener added to an instance of TreePathSupport implements
+ * this interface, it will be notified by the TreePathSupport if some other
+ * listener vetos expanding a node.
+ * &lt;p&gt;
+ * This interface is primarily used to avoid memory leaks if a TreeWillExpandListener
+ * constructs some data structure (like a TableModelEvent that is a translation
+ * of a TreeExpansionEvent) for use when the expansion actually occurs, to notify
+ * it that the pending TableModelEvent will never be fired.  It is not of much
+ * interest to the rest of the world.
+ *
+ * @author  Tim Boudreau
+ */
+public interface ExtTreeWillExpandListener extends TreeWillExpandListener {
+    
+    public void treeExpansionVetoed (TreeExpansionEvent event, 
+        ExpandVetoException exception);
+    
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/Outline.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/Outline.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/Outline.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,628 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is NetBeans. The Initial Developer of the Original
+ * Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+ * Microsystems, Inc. All Rights Reserved.
+ */
+package org.netbeans.swing.outline;
+
+import java.awt.Font;
+import java.awt.FontMetrics;
+import java.awt.Graphics;
+import java.awt.Insets;
+import java.awt.Rectangle;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.ComponentAdapter;
+import java.awt.event.ComponentEvent;
+import java.awt.event.ComponentListener;
+import java.awt.event.MouseEvent;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.EventObject;
+import java.util.List;
+import javax.swing.JScrollBar;
+import javax.swing.JScrollPane;
+import javax.swing.JTable;
+import javax.swing.JTree;
+import javax.swing.JViewport;
+import javax.swing.ListSelectionModel;
+import javax.swing.Timer;
+import javax.swing.UIManager;
+import javax.swing.event.TableModelEvent;
+import javax.swing.event.TreeModelEvent;
+import javax.swing.table.TableCellRenderer;
+import javax.swing.table.TableColumn;
+import javax.swing.table.TableModel;
+import javax.swing.tree.AbstractLayoutCache;
+import javax.swing.tree.TreePath;
+import org.netbeans.swing.etable.ETable;
+import org.netbeans.swing.etable.ETableColumn;
+
+/** An Outline, or tree-table component.  Takes an instance of OutlineModel,
+ * an interface which merges TreeModel and TableModel.
+ * &lt;p&gt;
+ * Simplest usage:  
+ * &lt;ol&gt;
+ * &lt;li&gt;Create a standard tree model for the tree node portion of the outline.&lt;/li&gt;
+ * &lt;li&gt;Implement RowModel.  RowModel is a subset of TableModel - it is passed
+ * the value in column 0 of the Outline and a column index, and returns the 
+ * value in the column in question.&lt;/li&gt;
+ * &lt;li&gt;Pass the TreeModel and the RowModel to &lt;code&gt;DefaultOutlineModel.createModel()&lt;/code&gt;
+ * &lt;/ol&gt;
+ * This will generate an instance of DefaultOutlineModel which will use the
+ * TreeModel for the rows/tree column content, and use the RowModel to provide
+ * the additional table columns.
+ * &lt;p&gt;
+ * It is also useful to provide an implementation of &lt;code&gt;RenderDataProvider&lt;/code&gt;
+ * to supply icons and affect text display of cells - this covers most of the 
+ * needs for which it is necessary to write a custom cell renderer in JTable/JTree.
+ * &lt;p&gt;
+ * &lt;b&gt;Example usage:&lt;/b&gt;&lt;br&gt;
+ * Assume FileTreeModel is a model which, given a root directory, will 
+ * expose the files and folders underneath it.  We will implement a 
+ * RowModel to expose the file size and date, and a RenderDataProvider which
+ * will use a gray color for uneditable files and expose the full file path as
+ * a tooltip.  Assume the class this is implemented in is a 
+ * JPanel subclass or other Swing container.
+ * &lt;br&gt;
+ * XXX todo: clean up formatting &amp; edit for style
+ * &lt;pre&gt;
+ * public void initComponents() {
+ *   setLayout (new BorderLayout());
+ *   TreeModel treeMdl = new FileTreeModel (someDirectory);
+ *
+ *   OutlineModel mdl = DefaultOutlineModel.createOutlineModel(treeMdl, 
+ *       new FileRowModel(), true);
+ *   outline = new Outline();
+ *   outline.setRenderDataProvider(new FileDataProvider()); 
+ *   outline.setRootVisible (true);
+ *   outline.setModel (mdl);
+ *   add (outline, BorderLayout.CENTER);
+ * }
+ *  private class FileRowModel implements RowModel {
+ *     public Class getColumnClass(int column) {
+ *          switch (column) {
+ *              case 0 : return Date.class;
+ *              case 1 : return Long.class;
+ *              default : assert false;
+ *          }
+ *          return null;
+ *      }
+ *      
+ *      public int getColumnCount() {
+ *          return 2;
+ *      }
+ *      
+ *      public String getColumnName(int column) {
+ *          return column == 0 ? &quot;Date&quot; : &quot;Size&quot;;
+ *      }
+ *      
+ *      public Object getValueFor(Object node, int column) {
+ *          File f = (File) node;
+ *          switch (column) {
+ *              case 0 : return new Date (f.lastModified());
+ *              case 1 : return new Long (f.length());
+ *              default : assert false;
+ *          }
+ *          return null;
+ *      }
+ *      
+ *      public boolean isCellEditable(Object node, int column) {
+ *          return false;
+ *      }
+ *      
+ *      public void setValueFor(Object node, int column, Object value) {
+ *          //do nothing, nothing is editable
+ *      }
+ *  }
+ *  
+ *  private class FileDataProvider implements RenderDataProvider {
+ *      public java.awt.Color getBackground(Object o) {
+ *          return null;
+ *      }
+ *      
+ *      public String getDisplayName(Object o) {
+ *          return ((File) o).getName();
+ *      }
+ *      
+ *      public java.awt.Color getForeground(Object o) {
+ *          File f = (File) o;
+ *          if (!f.isDirectory() &amp;&amp; !f.canWrite()) {
+ *              return UIManager.getColor (&quot;controlShadow&quot;);
+ *          }
+ *          return null;
+ *      }
+ *      
+ *      public javax.swing.Icon getIcon(Object o) {
+ *          return null;
+ *      }
+ *      
+ *      public String getTooltipText(Object o) {
+ *          return ((File) o).getAbsolutePath();
+ *      }
+ *      
+ *      public boolean isHtmlDisplayName(Object o) {
+ *          return false;
+ *      }
+ *   }
+ * &lt;/pre&gt;
+ *
+ * @author  Tim Boudreau
+ */
+public class Outline extends ETable {
+    //XXX plenty of methods missing here - add/remove tree expansion listeners,
+    //better path info/queries, etc.
+    
+    private boolean initialized = false;
+    private Boolean cachedRootVisible = null;
+    private RenderDataProvider renderDataProvider = null;
+    private ComponentListener componentListener = null;
+    /** Creates a new instance of Outline */
+    public Outline() {
+        init();
+    }
+    
+    public Outline(OutlineModel mdl) {
+        super (mdl);
+        init();
+    }
+    
+    private void init() {
+        initialized = true;
+        setDefaultRenderer(Object.class, new DefaultOutlineCellRenderer());
+    }
+    
+    /** Always returns the default renderer for Object.class for the tree column */
+    public TableCellRenderer getCellRenderer(int row, int column) {
+        int c = convertColumnIndexToModel(column);
+        TableCellRenderer result;
+        if (c == 0) {
+            result = getDefaultRenderer(Object.class);
+        } else {
+            result = super.getCellRenderer(row, column);
+        }
+        return result;
+    }
+    
+    /** Get the RenderDataProvider which is providing text, icons and tooltips
+     * for items in the tree column.  The default property for this value is
+     * null, in which case standard JTable/JTree object -&gt; icon/string 
+     * conventions are used */
+    public RenderDataProvider getRenderDataProvider() {
+        return renderDataProvider;
+    }
+    
+    /** Set the RenderDataProvider which will provide text, icons and tooltips
+     * for items in the tree column.  The default is null.  If null, 
+     * the data displayed will be generated in the standard JTable/JTree way - 
+     * calling &lt;code&gt;toString()&lt;/code&gt; on objects in the tree model and 
+     * using the look and feel's default tree folder and tree leaf icons.  */
+    public void setRenderDataProvider (RenderDataProvider provider) {
+        if (provider != renderDataProvider) {
+            RenderDataProvider old = renderDataProvider;
+            renderDataProvider = provider;
+            firePropertyChange (&quot;renderDataProvider&quot;, old, provider); //NOI18N
+        }
+    }
+    
+    /** Get the TreePathSupport object which manages path expansion for this
+     * Outline. */
+    TreePathSupport getTreePathSupport () {
+        OutlineModel mdl = getOutlineModel();
+        if (mdl != null) {
+            return mdl.getTreePathSupport();
+        } else {
+            return null;
+        }
+    }
+    
+    /** Get the layout cache which manages layout data for the Outline.
+     * &lt;strong&gt;Under no circumstances directly call the methods on the
+     * layout cache which change the expanded state - such changes will not
+     * be propagated into the table model, and will leave the model and
+     * its layout in inconsistent states.  Any calls that affect expanded
+     * state must go through &lt;code&gt;getTreePathSupport()&lt;/code&gt;.&lt;/strong&gt; */
+    public final AbstractLayoutCache getLayoutCache () {
+        OutlineModel mdl = getOutlineModel();
+        if (mdl != null) {
+            return mdl.getLayout();
+        } else {
+            return null;
+        }
+    }
+    
+    boolean isTreeColumnIndex (int column) {
+        int c = convertColumnIndexToModel(column);
+        return c == 0;
+    }
+    
+    public boolean isVisible (TreePath path) {
+        if (getTreePathSupport() != null) {
+            return getTreePathSupport().isVisible(path);
+        }
+        return false;
+    }
+    
+    /** Overridden to pass the fixed row height to the tree layout cache */
+    public void setRowHeight(int val) {
+        super.setRowHeight(val);
+        if (getLayoutCache() != null) {
+            getLayoutCache().setRowHeight(val);
+        }
+    }
+    
+    /** Set whether or not the root is visible */
+    public void setRootVisible (boolean val) {
+        if (getOutlineModel() == null) {
+            cachedRootVisible = val ? Boolean.TRUE : Boolean.FALSE;
+        }
+        if (val != isRootVisible()) {
+            //TODO - need to force a property change on the model,
+            //the layout cache doesn't have direct listener support
+            getLayoutCache().setRootVisible(val);
+            firePropertyChange(&quot;rootVisible&quot;, !val, val); //NOI18N
+        }
+    }
+    
+    /** Is the tree root visible.  Default value is true. */
+    public boolean isRootVisible() {
+        if (getLayoutCache() == null) {
+            return cachedRootVisible != null ? 
+                cachedRootVisible.booleanValue() : true;
+        } else {
+            return getLayoutCache().isRootVisible();
+        }
+    }
+
+    /**
+     */
+    protected TableColumn createColumn(int modelIndex) {
+        return new OutlineColumn(modelIndex);
+    }
+
+    protected class OutlineColumn extends ETableColumn {
+        public OutlineColumn(int modleIndex) {
+            super(modleIndex, Outline.this);
+        }
+        protected Comparator getRowComparator(int column, boolean ascending) {
+            return new OutlineRowComparator(column, ascending);
+        }
+        public boolean isHidingAllowed() {
+            return getModelIndex() != 0;
+        }
+        public boolean isSortingAllowed() {
+            return getModelIndex() != 0;
+        }
+        /**
+         * Comparator used for sorting the rows according to value in
+         * a given column. Operates on the RowMapping objects.
+         */
+        protected class OutlineRowComparator extends RowComparator {
+            private boolean ascending = true;
+            public OutlineRowComparator(int column, boolean ascending) {
+                super(column);
+                this.ascending = ascending;
+            }
+            public int compare(Object o1, Object o2) {
+                RowMapping rm1 = (RowMapping)o1;
+                RowMapping rm2 = (RowMapping)o2;
+                int index1 = rm1.getModelRowIndex();
+                int index2 = rm2.getModelRowIndex();
+                if (index1 == index2) {
+                    return 0;
+                }
+                TreePath tp1 = getLayoutCache().getPathForRow(index1);
+                TreePath tp2 = getLayoutCache().getPathForRow(index2);
+                if (tp1.isDescendant(tp2)) {
+                    return -1;
+                }
+                if (tp2.isDescendant(tp1)) {
+                    return 1;
+                }
+                TreePath parent1 = tp1.getParentPath();
+                TreePath parent2 = tp2.getParentPath();
+                if (parent1 != null &amp;&amp; parent2 != null &amp;&amp; parent1.equals(parent2) &amp;&amp;
+                        getOutlineModel().isLeaf(tp1.getLastPathComponent()) &amp;&amp;
+                        getOutlineModel().isLeaf(tp2.getLastPathComponent())) {
+                    return ascending ? super.compare(o1, o2) : - super.compare(o1, o2);
+                }
+                while (tp1.getPathCount() &lt; tp2.getPathCount()) {
+                    tp2 = tp2.getParentPath();
+                }
+                while (tp1.getPathCount() &gt; tp2.getPathCount()) {
+                    tp1 = tp1.getParentPath();
+                }
+                parent1 = tp1.getParentPath();
+                parent2 = tp2.getParentPath();
+                while (parent1 != null &amp;&amp; parent2 != null &amp;&amp; !parent1.equals(parent2)) {
+                    tp1 = parent1;
+                    tp2 = parent2;
+                    parent1 = tp1.getParentPath();
+                    parent2 = tp2.getParentPath();
+                }
+                int r1 = getLayoutCache().getRowForPath(tp1);
+                int r2 = getLayoutCache().getRowForPath(tp2);
+                
+                Object obj1 = getModel().getValueAt(r1, column);
+                Object obj2 = getModel().getValueAt(r2, column);
+                obj1 = transformValue(obj1);
+                obj2 = transformValue(obj2);
+                if (obj1 == null &amp;&amp; obj2 == null) {
+                    return 0;
+                }
+                if (obj1 == null) {
+                    return -1;
+                }
+                if (obj2 == null) {
+                    return 1;
+                }
+                if ((obj1 instanceof Comparable) &amp;&amp; (obj1.getClass().isAssignableFrom(obj2.getClass()))){
+                    Comparable c1 = (Comparable) obj1;
+                    return ascending ? c1.compareTo(obj2) : - c1.compareTo(obj2);
+                }
+                return 0;
+            }
+        }
+    }
+    
+    /** Overridden to throw an exception if the passed model is not an instance
+     * of &lt;code&gt;OutlineModel&lt;/code&gt; (with the exception of calls from the 
+     * superclass constructor) */
+    public void setModel (TableModel mdl) {
+        if (initialized &amp;&amp; (!(mdl instanceof OutlineModel))) {
+            throw new IllegalArgumentException (
+                &quot;Table model for an Outline must be an instance of &quot; +
+                &quot;OutlineModel&quot;); //NOI18N
+        }
+        if (mdl instanceof OutlineModel) {
+            AbstractLayoutCache layout = ((OutlineModel) mdl).getLayout();
+            if (cachedRootVisible != null) {
+                
+                layout.setRootVisible(
+                    cachedRootVisible.booleanValue());
+                
+            }
+            
+            layout.setRowHeight(getRowHeight());
+            
+            if (((OutlineModel) mdl).isLargeModel()) {
+                addComponentListener (getComponentListener());
+                layout.setNodeDimensions(new ND());
+            } else {
+                if (componentListener != null) {
+                    removeComponentListener (componentListener);
+                    componentListener = null;
+                }
+            }
+        }
+        
+        super.setModel(mdl);
+    }
+    
+    /** Convenience getter for the &lt;code&gt;TableModel&lt;/code&gt; as an instance of
+     * OutlineModel.  If no OutlineModel has been set, returns null. */
+    public OutlineModel getOutlineModel() {
+        TableModel mdl = getModel();
+        if (mdl instanceof OutlineModel) {
+            return (OutlineModel) getModel();
+        } else {
+            return null;
+        }
+    }
+    
+    /** Expand a tree path */
+    public void expandPath (TreePath path) {
+        getTreePathSupport().expandPath (path);
+    }
+    
+    public void collapsePath (TreePath path) {
+        getTreePathSupport().collapsePath (path);
+    }
+    
+    public Rectangle getPathBounds(TreePath path) {
+        Insets i = getInsets();
+        Rectangle bounds = getLayoutCache().getBounds(path, null);
+
+        if(bounds != null &amp;&amp; i != null) {
+            bounds.x += i.left;
+            bounds.y += i.top;
+        }
+        return bounds;
+    }   
+    
+    public TreePath getClosestPathForLocation(int x, int y) {
+        Insets i = getInsets();
+        if (i != null) {
+            return getLayoutCache().getPathClosestTo(x - i.left, y - i.top);
+        } else {
+            return getLayoutCache().getPathClosestTo(x,y);
+        }
+    }
+    
+    public boolean editCellAt (int row, int column, EventObject e) {
+        //If it was on column 0, it may be a request to expand a tree
+        //node - check for that first.
+        if (isTreeColumnIndex (column) &amp;&amp; e instanceof MouseEvent) {
+            MouseEvent me = (MouseEvent) e;
+            TreePath path = getLayoutCache().getPathForRow(convertRowIndexToModel(row));
+            if (!getOutlineModel().isLeaf(path.getLastPathComponent())) {
+                int handleWidth = DefaultOutlineCellRenderer.getExpansionHandleWidth();
+                Insets ins = getInsets();
+                int nd = path.getPathCount() - (isRootVisible() ? 1 : 2);
+                if (nd &lt; 0) {
+                    nd = 0;
+                }
+                int handleStart = ins.left + (nd * DefaultOutlineCellRenderer.getNestingWidth());
+                int handleEnd = ins.left + handleStart + handleWidth;
+                //TODO: Translate x/y to position of column if non-0
+                
+                if ((me.getX() &gt; ins.left &amp;&amp; me.getX() &gt;= handleStart &amp;&amp; me.getX() &lt;= handleEnd) ||
+                     me.getClickCount() &gt; 1) {
+
+                    boolean expanded = getLayoutCache().isExpanded(path);
+                    if (!expanded) {
+                        getTreePathSupport().expandPath(path);
+                        
+                        Object ourObject = path.getLastPathComponent();
+                        int cCount = getOutlineModel().getChildCount(ourObject);
+                        if (cCount &gt; 0) {
+                            Object lastChild = getOutlineModel().getChild(ourObject, cCount - 1);
+                            TreePath lastChildPath = path.pathByAddingChild(lastChild);
+                            int lastRow = getLayoutCache().getRowForPath(lastChildPath);
+                            Rectangle rect = getCellRect(lastRow, 0, true);
+                            scrollRectToVisible(rect);
+                        }
+                        
+                    } else {
+                        getTreePathSupport().collapsePath(path);
+                    }
+                    return false;
+                }
+            }
+        }
+            
+        return super.editCellAt(row, column, e);
+    }
+    
+    /** Computes row height ...
+     */
+    public void addNotify () {
+        super.addNotify ();
+        calcRowHeight();
+    }
+
+    /** Calculate the height of rows based on the current font. */
+    private void calcRowHeight() {
+        //Users of themes can set an explicit row height, so check for it
+        Integer i = (Integer) UIManager.get(&quot;netbeans.outline.rowHeight&quot;); //NOI18N
+        
+        int rowHeight;
+        if (i != null) {
+            rowHeight = i.intValue();
+        } else {
+            //Derive a row height to accomodate the font and expando icon
+            Font f = getFont();
+            FontMetrics fm = getFontMetrics(f);
+            rowHeight = Math.max(fm.getHeight()+3,
+                DefaultOutlineCellRenderer.getExpansionHandleHeight());
+        }
+        //Set row height.  If displayable, this will generate a new call
+        //to paint()
+        setRowHeight(rowHeight);
+    }    
+    
+    public void tableChanged(TableModelEvent e) {
+//        System.err.println(&quot;Table got tableChanged &quot; + e);
+        super.tableChanged(e);
+//        System.err.println(&quot;row count is &quot; + getRowCount());
+    }
+    
+    /** Create a component listener to handle size changes if the table model
+     * is large-model */
+    private ComponentListener getComponentListener() {
+        if (componentListener == null) {
+            componentListener = new SizeManager();
+        }
+        return componentListener;
+    }
+    
+    private JScrollPane getScrollPane() {
+        JScrollPane result = null;
+        if (getParent() instanceof JViewport) {
+            if (((JViewport) getParent()).getParent() instanceof JScrollPane) {
+                result = (JScrollPane) ((JViewport) getParent()).getParent();
+            }
+        }
+        return result;
+    }
+    
+    private void change() {
+        revalidate();
+        repaint();
+    }
+    
+    private class ND extends AbstractLayoutCache.NodeDimensions {
+        
+        public Rectangle getNodeDimensions(Object value, int row, int depth, 
+            boolean expanded, Rectangle bounds) {
+                int wid = Outline.this.getColumnModel().getColumn(0).getPreferredWidth();
+                bounds.setBounds (0, row * getRowHeight(), wid, getRowHeight());
+                return bounds;
+        }
+        
+    }
+    
+    
+    /** A component listener.  If we're a large model table, we need
+     * to inform the FixedHeightLayoutCache when the size changes, so it
+     * can update its mapping of visible nodes */
+    private class SizeManager extends ComponentAdapter implements ActionListener {
+	protected Timer timer = null;
+	protected JScrollBar scrollBar = null;
+        
+        public void componentMoved(ComponentEvent e) {
+	    if(timer == null) {
+		JScrollPane   scrollPane = getScrollPane();
+
+		if(scrollPane == null) {
+		    change();
+                } else {
+		    scrollBar = scrollPane.getVerticalScrollBar();
+		    if(scrollBar == null || 
+			!scrollBar.getValueIsAdjusting()) {
+			// Try the horizontal scrollbar.
+			if((scrollBar = scrollPane.getHorizontalScrollBar())
+			    != null &amp;&amp; scrollBar.getValueIsAdjusting()) {
+                                
+			    startTimer();
+                        } else {
+			    change();
+                        }
+		    } else {
+			startTimer();
+                    }
+		}
+	    }
+        }
+        
+	protected void startTimer() {
+	    if(timer == null) {
+		timer = new Timer(200, this);
+		timer.setRepeats(true);
+	    }
+	    timer.start();
+	}        
+        
+	public void actionPerformed(ActionEvent ae) {
+	    if(scrollBar == null || !scrollBar.getValueIsAdjusting()) {
+		if(timer != null)
+		    timer.stop();
+		change();
+		timer = null;
+		scrollBar = null;
+	    }
+	}        
+        
+        public void componentHidden(ComponentEvent e) {
+        }
+        
+        public void componentResized(ComponentEvent e) {
+        }
+        
+        public void componentShown(ComponentEvent e) {
+        }
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/OutlineModel.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/OutlineModel.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/OutlineModel.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,55 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is NetBeans. The Initial Developer of the Original
+ * Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+ * Microsystems, Inc. All Rights Reserved.
+ */
+package org.netbeans.swing.outline;
+
+import javax.swing.table.TableModel;
+import javax.swing.tree.AbstractLayoutCache;
+import javax.swing.tree.TreeModel;
+
+/** A model for an Outline (&quot;tree-table&quot;).  Implements both
+ * TreeModel and TableModel (the default implementation, DefaultOutlineModel,
+ * wraps a supplied TreeModel and TableModel).  It is vastly easier to
+ * use &lt;code&gt;DefaultOutlineModel&lt;/code&gt; than to implement this interface
+ * directly.
+ *
+ * @author  Tim Boudreau  */
+public interface OutlineModel extends TableModel, TreeModel {
+    /** Get the &lt;code&gt;TreePathSupport&lt;/code&gt; object this model uses to manage
+     * information about expanded nodes.  &lt;code&gt;TreePathSupport&lt;/code&gt; implements
+     * logic for tracking expanded nodes, manages &lt;code&gt;TreeWillExpandListener&lt;/code&gt;s,
+     * and is a repository for preserving expanded state information about nodes whose parents
+     * are currently collapsed.  JTree implements very similar logic internally
+     * to itself.
+     * &lt;p&gt;
+     * &lt;i&gt;(PENDING) It is not yet determined if TreePathSupport will remain a
+     * public class.&lt;/i&gt;
+     */
+    public TreePathSupport getTreePathSupport ();
+    /** Get the layout cache which is used to track the visual state of nodes.
+     * This is typically one of the standard JDK layout cache classes, such
+     * as &lt;code&gt;VariableHeightLayoutCache&lt;/code&gt; or &lt;code&gt;
+     * FixedHeightLayoutCache&lt;/code&gt;.  */
+    public AbstractLayoutCache getLayout ();
+    /** Determine if the model is a large-model.  Large model trees keep less
+     * internal state information, relying on the TreeModel more.  Essentially
+     * they trade performance for scalability. An OutlineModel may be large
+     * model or small model; primarily this affects the type of layout cache
+     * used, just as it does with JTree.  */
+    public boolean isLargeModel();
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/ProxyTableModel.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/ProxyTableModel.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/ProxyTableModel.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,125 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is NetBeans. The Initial Developer of the Original
+ * Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+ * Microsystems, Inc. All Rights Reserved.
+ */
+/*
+ * ConverterTableModel.java
+ *
+ * Created on January 28, 2004, 7:02 PM
+ */
+
+package org.netbeans.swing.outline;
+
+import java.util.ArrayList;
+import java.util.List;
+import javax.swing.event.TableModelEvent;
+import javax.swing.event.TableModelListener;
+import javax.swing.table.TableModel;
+
+/** A TableModel which is driven by a RowModel - the RowModel
+ * supplies row contents, based on nodes suppled by the tree
+ * column of an OutlineModel.  This model supplies the additional
+ * rows of the TableModel to the OutlineModel.
+ *
+ * @author  Tim Boudreau
+ */
+final class ProxyTableModel implements TableModel {
+    private List listeners = new ArrayList();
+    private RowModel rowmodel;
+    private OutlineModel outlineModel;
+    /** Creates a new instance of ProxyTableModel that will use the supplied
+     * RowModel to produce its values.  */
+    public ProxyTableModel(RowModel rowmodel) {
+        this.rowmodel = rowmodel;
+    }
+    
+    /** Set the OutlineModel that will be used to find nodes for
+     * rows.  DefaultOutlineModel will do this in its constructor. */
+    void setOutlineModel (OutlineModel mdl) {
+        this.outlineModel = mdl;
+    }
+    
+    /** Get the outline model used to provide column 0 nodes to the
+     * RowModel for setting the values.  */
+    OutlineModel getOutlineModel () {
+        return outlineModel;
+    }
+    
+    public Class getColumnClass(int columnIndex) {
+        return rowmodel.getColumnClass(columnIndex);
+    }
+    
+    public int getColumnCount() {
+        return rowmodel.getColumnCount();
+    }
+    
+    public String getColumnName(int columnIndex) {
+        return rowmodel.getColumnName(columnIndex);
+    }
+    
+    public int getRowCount() {
+        //not interesting, will never be called - the outline model
+        //handles this
+        return -1;
+    }
+    
+    public Object getValueAt(int rowIndex, int columnIndex) {
+        Object node = getNodeForRow(rowIndex);
+        return rowmodel.getValueFor(node, columnIndex);
+    }
+    
+    public boolean isCellEditable(int rowIndex, int columnIndex) {
+        Object node = getNodeForRow(rowIndex);
+        return rowmodel.isCellEditable (node, columnIndex);
+    }
+    
+    public synchronized void removeTableModelListener(TableModelListener l) {
+        listeners.remove(l);
+    }
+    
+    public synchronized void addTableModelListener(TableModelListener l) {
+        listeners.add(l);
+    }
+    
+    private void fire (TableModelEvent e) {
+        TableModelListener[] l;
+        synchronized (this) {
+            l = new TableModelListener[listeners.size()];
+            l = (TableModelListener[]) listeners.toArray(l);
+        }
+        for (int i=0; i &lt; l.length; i++) {
+            l[i].tableChanged(e);
+        }
+    }
+    
+    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
+        Object node = getNodeForRow(rowIndex);
+        rowmodel.setValueFor (node, columnIndex, aValue);
+        TableModelEvent e = new TableModelEvent (this, rowIndex, rowIndex, 
+            columnIndex);
+        fire(e);
+    }
+    
+    /** Get the object that will be passed to the RowModel to fetch values
+     * for the given row. 
+     * @param row The row we need the tree node for */
+    private Object getNodeForRow(int row) {
+        return getOutlineModel().getValueAt(row, 0);
+    }    
+
+    
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/RenderDataProvider.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/RenderDataProvider.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/RenderDataProvider.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,62 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is NetBeans. The Initial Developer of the Original
+ * Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+ * Microsystems, Inc. All Rights Reserved.
+ */
+/*
+ * RenderDataProvider.java
+ *
+ * Created on January 29, 2004, 12:01 AM
+ */
+
+package org.netbeans.swing.outline;
+
+import java.awt.Color;
+import javax.swing.Icon;
+
+/** A class which can provide rendering data for the tree portion an Outline,
+ * such as converting values to text, providing tooltip text and icons.
+ * Makes it possible to provide most of the interesting data that affects
+ * display without needing to provide a custom cell renderer.  An Outline
+ * will use its RenderDataProvider to fetch data for &lt;strong&gt;all&lt;/strong&gt;
+ * its columns, so it is possible to affect the display of both property
+ * columns and the tree column via this interface.
+ *
+ * @author  Tim Boudreau
+ */
+public interface RenderDataProvider {
+    /** Convert an object in the tree to the string that should be used to
+     * display its node */
+    public String getDisplayName (Object o);
+    /** Returns true of the display name for this object should use HTML 
+     * rendering (future support for integration of the lightweight HTML
+     * renderer into NetBeans).  */
+    public boolean isHtmlDisplayName (Object o);
+    /** Get the background color to be used for rendering this node.  Return
+     * null if the standard table background or selected color should be used.
+     */
+    public Color getBackground (Object o);
+    /** Get the foreground color to be used for rendering this node.  Return
+     * null if the standard table foreground or selected foreground should be
+     * used. */
+    public Color getForeground (Object o);
+    /** Get a description for this object suitable for use in a tooltip.  Return
+     * null if no tooltip is desired.  */
+    public String getTooltipText (Object o);
+    /** Get an icon to be used for this object.  Return null if the look and 
+     * feel's default tree folder/leaf icons should be used as appropriate. */
+    public Icon getIcon (Object o);
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/RowModel.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/RowModel.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/RowModel.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,75 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is NetBeans. The Initial Developer of the Original
+ * Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+ * Microsystems, Inc. All Rights Reserved.
+ */
+/*
+ * RowModel.java
+ *
+ * Created on January 28, 2004, 11:07 PM
+ */
+
+package org.netbeans.swing.outline;
+
+/** A model for the rows in an Outline.  This is passed the object in
+ * column 0 of an Outline table (the tree column), and provides objects
+ * for the other columns - essentially a model for the data in the
+ * rows of an Outline.
+ * &lt;p&gt;
+ * Note that all column indexes passed to this interface are 0-based -
+ * that is, column 0 is the first column &lt;strong&gt;after&lt;/strong&gt; the
+ * tree node column, so the object returned by &lt;code&gt;getValueFor(someObject, 0)&lt;/code&gt;
+ * is the object that should appear in column &lt;strong&gt;1&lt;/strong&gt; of the
+ * actual table.
+ * &lt;p&gt;
+ *
+ * @author Tim Boudreau
+ */
+public interface RowModel {
+    /** Get the column count.  Do not include the base (nodes) column
+     * of the Outline, only the number of columns in addition to it
+     * that should be displayed. 
+     * @return the number of columns this model will contribute to the
+     *  OutlineModel, not including the tree column */
+    public int getColumnCount();
+    /** Get the value at a given column.  
+     * @param node The node in column 0 of the Outline
+     * @param column The index of the column minus the nodes column  
+     * @return the value that should be displayed in the specified column,
+     *  given the node in the tree column */
+    public Object getValueFor (Object node, int column);
+    /** Get the object class for the column.  Analogous to 
+     * &lt;code&gt;TableModel.getColumnClass(int column)&lt;/code&gt; 
+     * @param column an index into the columns represented by this model (0
+     *  based - does not include the tree column of the OutlineModel)
+     * @return the class of object that will be displayed in the specified
+     * column */
+    public Class getColumnClass (int column);
+    /** Determine if the cell in this column is editable for the passed
+     * node.
+     * @param node the object displayed in the tree column of the Outline
+     * @param column the column index into the columns defined by this
+     *  RowModel  */
+    public boolean isCellEditable (Object node, int column);
+    /** Set the value of the object in this column.  Typically this may
+     * call a setter on the node object in column 0.  */
+    public void setValueFor (Object node, int column, Object value);
+    /** Get a localized name of this column that can be displayed in
+     * the table header
+     * @param column the column a name is requested for
+     * @return a localized name for the column  */
+    public String getColumnName (int column);
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/TestOutline.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/TestOutline.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/TestOutline.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,218 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is NetBeans. The Initial Developer of the Original
+ * Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+ * Microsystems, Inc. All Rights Reserved.
+ */
+/*
+ * Test.java
+ *
+ * Created on January 28, 2004, 6:15 PM
+ */
+
+package org.netbeans.swing.outline;
+
+import java.awt.BorderLayout;
+import java.io.File;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Map;
+import javax.swing.JFrame;
+import javax.swing.JScrollPane;
+import javax.swing.UIManager;
+import javax.swing.table.TableModel;
+import javax.swing.tree.DefaultTreeModel;
+import javax.swing.tree.TreeModel;
+import javax.swing.tree.TreeNode;
+
+/** A simple test of the Outline (akaTreeTable) class which implements
+ * a filesystem browser.
+ *
+ * @author  Tim Boudreau
+ */
+public class TestOutline extends JFrame {
+    private Outline outline;
+    /** Creates a new instance of Test */
+    public TestOutline() {
+        setDefaultCloseOperation (EXIT_ON_CLOSE);
+        getContentPane().setLayout (new BorderLayout());
+        
+        //Use root 1 on windows to avoid making a tree of the floppy drive.
+        /*
+        TreeModel treeMdl = new DefaultTreeModel(
+            new FileTreeNode(File.listRoots()[Utilities.isWindows() ? 1 : 0]));
+         */
+            
+        TreeModel treeMdl = createModel();
+        
+        OutlineModel mdl = DefaultOutlineModel.createOutlineModel(treeMdl, 
+            new FileRowModel(), true);
+        
+        outline = new Outline();
+        
+        outline.setRenderDataProvider(new RenderData()); 
+        
+        outline.setRootVisible (true);
+        
+        outline.setModel (mdl);
+        
+        
+        getContentPane().add(new JScrollPane(outline), BorderLayout.CENTER);
+        setBounds (20, 20, 700, 400);
+    }
+    
+    /** A handy method to create a model to install into a JTree to compare
+     * behavior of a real JTree's layout cache and ours */
+    public static TreeModel createModel() {
+//        TreeModel treeMdl = /*new DefaultTreeModel(
+//            new FileTreeNode(File.listRoots()[Utilities.isWindows() ? 1 : 0]));
+                           
+        TreeModel treeMdl = new FileTreeModel (
+            File.listRoots()[0]);
+        return treeMdl;
+    }
+    
+    public static void main(String[] ignored) {
+        try {
+           //UIManager.setLookAndFeel (new javax.swing.plaf.metal.MetalLookAndFeel());
+        } catch (Exception e) {}
+        
+        new TestOutline().show();
+    }
+    
+    private class FileRowModel implements RowModel {
+        
+        public Class getColumnClass(int column) {
+            switch (column) {
+                case 0 : return Date.class;
+                case 1 : return Long.class;
+                default : assert false;
+            }
+            return null;
+        }
+        
+        public int getColumnCount() {
+            return 2;
+        }
+        
+        public String getColumnName(int column) {
+            return column == 0 ? &quot;Date&quot; : &quot;Size&quot;;
+        }
+        
+        public Object getValueFor(Object node, int column) {
+            File f = (File) node;
+            switch (column) {
+                case 0 : return new Date (f.lastModified());
+                case 1 : return new Long (f.length());
+                default : assert false;
+            }
+            return null;
+        }
+        
+        public boolean isCellEditable(Object node, int column) {
+            return false;
+        }
+        
+        public void setValueFor(Object node, int column, Object value) {
+            //do nothing for now
+        }
+        
+    }
+    
+    
+    private class RenderData implements RenderDataProvider {
+        
+        public java.awt.Color getBackground(Object o) {
+            return null;
+        }
+        
+        public String getDisplayName(Object o) {
+            return ((File) o).getName();
+        }
+        
+        public java.awt.Color getForeground(Object o) {
+            File f = (File) o;
+            if (!f.isDirectory() &amp;&amp; !f.canWrite()) {
+                return UIManager.getColor (&quot;controlShadow&quot;);
+            }
+            return null;
+        }
+        
+        public javax.swing.Icon getIcon(Object o) {
+            return null;
+        
+        }
+        
+        public String getTooltipText(Object o) {
+            File f = (File) o;
+            return f.getAbsolutePath();
+        }
+        
+        public boolean isHtmlDisplayName(Object o) {
+            return false;
+        }
+        
+    }
+    
+    private static class FileTreeModel implements TreeModel {
+        private File root;
+        public FileTreeModel (File root) {
+            this.root = root;
+        }
+        
+        public void addTreeModelListener(javax.swing.event.TreeModelListener l) {
+            //do nothing
+        }
+        
+        public Object getChild(Object parent, int index) {
+            File f = (File) parent;
+            return f.listFiles()[index];
+        }
+        
+        public int getChildCount(Object parent) {
+            File f = (File) parent;
+            if (!f.isDirectory()) {
+                return 0;
+            } else {
+                return f.list().length;
+            }
+        }
+        
+        public int getIndexOfChild(Object parent, Object child) {
+            File par = (File) parent;
+            File ch = (File) child;
+            return Arrays.asList(par.listFiles()).indexOf(ch);
+        }
+        
+        public Object getRoot() {
+            return root;
+        }
+        
+        public boolean isLeaf(Object node) {
+            File f = (File) node;
+            return !f.isDirectory();
+        }
+        
+        public void removeTreeModelListener(javax.swing.event.TreeModelListener l) {
+            //do nothing
+        }
+        
+        public void valueForPathChanged(javax.swing.tree.TreePath path, Object newValue) {
+            //do nothing
+        }
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/TestOutlineDynamic.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/TestOutlineDynamic.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/TestOutlineDynamic.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,374 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is NetBeans. The Initial Developer of the Original
+ * Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+ * Microsystems, Inc. All Rights Reserved.
+ */
+/*
+ * TestOutlineDynamic.java
+ *
+ * Created on February 1, 2004, 12:53 PM
+ */
+
+package org.netbeans.swing.outline;
+
+import java.awt.BorderLayout;
+import java.awt.Color;
+import java.awt.FlowLayout;
+import java.awt.event.ActionListener;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import javax.swing.BoxLayout;
+import javax.swing.DefaultListSelectionModel;
+import javax.swing.JButton;
+import javax.swing.JFrame;
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+import javax.swing.JScrollPane;
+import javax.swing.ListSelectionModel;
+import javax.swing.UIManager;
+import javax.swing.event.ListSelectionEvent;
+import javax.swing.event.ListSelectionListener;
+import javax.swing.event.TreeModelEvent;
+import javax.swing.event.TreeModelListener;
+import javax.swing.table.TableModel;
+import javax.swing.tree.DefaultMutableTreeNode;
+import javax.swing.tree.DefaultTreeModel;
+import javax.swing.tree.TreeModel;
+import javax.swing.tree.TreeNode;
+import javax.swing.tree.TreePath;
+
+/** Another Outline test app - this one allows dynamic adding and removal of
+ * nodes and provides an editable column called &quot;comment&quot;.
+ *
+ * @author  Tim Boudreau
+ */
+public class TestOutlineDynamic extends JFrame implements ActionListener {
+    private Outline outline;
+    private TreeModel treeMdl;
+    static int nodeCount = 0;
+    
+    /** Creates a new instance of Test */
+    public TestOutlineDynamic() {
+        setDefaultCloseOperation (EXIT_ON_CLOSE);
+        getContentPane().setLayout (new BorderLayout());
+  
+        treeMdl = createModel();
+        
+        OutlineModel mdl = DefaultOutlineModel.createOutlineModel(treeMdl, 
+            new NodeRowModel(), true);
+        
+        outline = new Outline();
+        
+       // outline.setRenderDataProvider(new RenderData()); 
+        
+        outline.setRootVisible (true);
+        
+        outline.setModel (mdl);
+        
+        JPanel buttons = new JPanel();
+        
+        JLabel jl = new JLabel(&quot;Read the button tooltips&quot;);
+        
+        buttons.setLayout(new BoxLayout(buttons, BoxLayout.Y_AXIS));
+        buttons.add(jl);
+        
+        final JButton add = new JButton (&quot;Add child&quot;);
+        final JButton remove = new JButton (&quot;Delete child&quot;);
+        final JButton clear = new JButton(&quot;Clear&quot;);
+        final JButton addDis = new JButton (&quot;Add discontiguous&quot;);
+        final JButton removeDis = new JButton (&quot;Delete discontiguous&quot;);
+        
+        addDis.setEnabled(false);
+        removeDis.setEnabled(false);
+        removeDis.setToolTipText(&quot;To enable, select more than one immediate child node of the same parent node&quot;);
+        addDis.setToolTipText(&quot;To enable, select a node with more than one child&quot;);
+        add.setToolTipText(&quot;Add a child to the selected node&quot;);
+        remove.setToolTipText(&quot;Delete the selected node&quot;);
+        clear.setToolTipText(&quot;Clear the model, leaving only the root node&quot;);
+        clear.setEnabled(false);
+        
+        add.addActionListener (this);
+        remove.addActionListener(this);
+        clear.addActionListener(this);
+        addDis.addActionListener(this);
+        removeDis.addActionListener(this);
+        add.setName(&quot;add&quot;);
+        remove.setName(&quot;remove&quot;);
+        clear.setName(&quot;clear&quot;);
+        addDis.setName(&quot;addDis&quot;);
+        removeDis.setName(&quot;removeDis&quot;);
+        buttons.add (add);
+        buttons.add(remove);
+        buttons.add(clear);
+        buttons.add(addDis);
+        buttons.add(removeDis);
+        
+        add.setEnabled(false);
+        remove.setEnabled(false);
+        
+        outline.getSelectionModel().addListSelectionListener(
+            new ListSelectionListener() {
+                public void valueChanged(ListSelectionEvent e) {
+                    boolean en = outline.getSelectedRow() != -1;
+                    add.setEnabled(en);
+                    remove.setEnabled(en &amp;&amp; outline.getSelectedRow() != 0);
+                    clear.setEnabled(outline.getRowCount() &gt; 1);
+                    
+                    ListSelectionModel m =  
+                        outline.getSelectionModel();
+                    //en = (m.getMinSelectionIndex() != m.getMaxSelectionIndex());
+                    en = getSelectedNode() != null;
+                    if (en) {
+                        DefaultMutableTreeNode nd = getSelectedNode();
+                        en = nd.getChildCount() &gt; 1;
+                    }
+                    addDis.setEnabled(en);
+                    
+                    en = getSelectedNode() != null;
+                    if (en) {
+                        int[] sels = getSelectedIndices();
+                        en = sels.length &gt; 1;
+                        if (sels.length &gt; outline.getRowCount()) {
+                            en = false;
+                        }
+                        if (en) {
+                            DefaultMutableTreeNode lastParent = null;
+                            for (int i=0; i &lt; sels.length; i++) {
+                                DefaultMutableTreeNode nd = (DefaultMutableTreeNode)
+                                    outline.getValueAt(sels[i], 0);
+                                if (nd == null) {
+                                    en = false;
+                                    break;
+                                }
+                                if (lastParent != null) {
+                                    en &amp;= nd.getParent() == lastParent;
+                                    if (!en) {
+                                        break;
+                                    }
+                                } else {
+                                    lastParent = (DefaultMutableTreeNode) nd.getParent();
+                                }
+                            }
+                        }
+                        
+                    }
+                    
+                    removeDis.setEnabled(en);
+                }
+        });
+                
+        getContentPane().add(new JScrollPane(outline), BorderLayout.CENTER);
+        getContentPane().add(buttons, BorderLayout.EAST);
+        
+        setBounds (20, 20, 700, 400);
+    }
+
+    public void actionPerformed(java.awt.event.ActionEvent e) {
+        JButton b = (JButton) e.getSource();
+        DefaultMutableTreeNode n = getSelectedNode();
+        DefaultTreeModel mdl = (DefaultTreeModel) treeMdl;
+        
+        if (&quot;add&quot;.equals(b.getName())) {
+            Node newNode = new Node();
+            DefaultMutableTreeNode nd = new DefaultMutableTreeNode(newNode, true);
+            n.add(nd);
+            
+            mdl.nodesWereInserted(n, new int[] {n.getChildCount()-1});
+            
+//            mdl.insertNodeInto(new DefaultMutableTreeNode(newNode, true), n, n.getChildCount());
+            
+        } else if (&quot;remove&quot;.equals(b.getName())) {
+            mdl.removeNodeFromParent(n);
+        } else if (&quot;clear&quot;.equals(b.getName())) {
+            DefaultMutableTreeNode root = (DefaultMutableTreeNode) mdl.getRoot();
+            root.removeAllChildren();
+            nodeCount = 1;
+            mdl.reload(root);
+        } else if (&quot;addDis&quot;.equals(b.getName())) {
+            DefaultMutableTreeNode nd = getSelectedNode();
+            int ch = nd.getChildCount();
+            
+            DefaultMutableTreeNode atStart = new DefaultMutableTreeNode(new Node(), true);
+            DefaultMutableTreeNode atEnd = new DefaultMutableTreeNode(new Node(), true);
+            
+            nd.insert(atEnd, ch);
+            nd.insert(atStart, 0);
+            
+            mdl.nodesWereInserted(nd, new int[] {0, nd.getChildCount()-1});
+            
+            
+        } else if (&quot;removeDis&quot;.equals(b.getName())) {
+            int[] sels = getSelectedIndices();
+            
+            
+            //they all have the same parent if the button is enabled
+            DefaultMutableTreeNode aNode = (DefaultMutableTreeNode) 
+                outline.getValueAt(sels[0], 0);
+            
+            DefaultMutableTreeNode parent = (DefaultMutableTreeNode) aNode.getParent();
+            
+            //reverse sort the selections, so we remove nodes from bottom to top
+            for (int i=0; i &lt; sels.length; i++) {
+                sels[i] *= -1;
+            }
+            Arrays.sort(sels);
+            for (int i=0; i &lt; sels.length; i++) {
+                sels[i] *= -1;
+            }
+
+//            System.err.println(&quot;Going to remove &quot; + Arrays.asList(Utilities.toObjectArray(sels)));
+            
+            ArrayList nodes = new ArrayList();
+            int[] indices = new int[sels.length];
+            //Build the list of nodes we'll play with before we start
+            //modifying the model - we can't do it while we're going
+            for (int i=0; i &lt; sels.length; i++) {
+                aNode = (DefaultMutableTreeNode) outline.getValueAt(sels[i], 0);
+                System.err.println(&quot;To delete user object class &quot; + aNode.getUserObject().getClass() + &quot; = &quot; + aNode.getUserObject());
+                nodes.add (aNode);
+                indices[i] = parent.getIndex(aNode);
+            }
+            
+//            System.err.println(&quot;Will really remove indices &quot; + Arrays.asList(Utilities.toObjectArray(indices)));
+            
+            for (int i=0; i &lt; nodes.size(); i++) {
+                aNode = (DefaultMutableTreeNode) nodes.get(i);
+                if (aNode.getParent() != parent) {
+                    System.err.println(aNode + &quot; not child of &quot; + parent + &quot; but of &quot; + aNode.getParent());
+                } else {
+                    System.err.println(&quot;REMOVING &quot; + aNode + &quot; from parent&quot;);
+                    parent.remove(aNode);
+                    nodes.add(aNode);
+                }
+            }
+            
+            mdl.nodesWereRemoved(parent, indices, nodes.toArray());
+            
+        }
+    }
+    
+    private int[] getSelectedIndices() {
+        ListSelectionModel lsm = outline.getSelectionModel();
+        int min = lsm.getMinSelectionIndex();
+        int max = lsm.getMaxSelectionIndex();
+        if (min == max) {
+            return new int[] {min};
+        }
+        ArrayList al = new ArrayList();
+        for (int i=min; i &lt;= max; i++) {
+            if (lsm.isSelectedIndex(i)) {
+                al.add (new Integer(i));
+            }
+        }
+        Integer[] ints = (Integer[]) al.toArray(new Integer[0]);
+//        return (int[]) Utilities.toPrimitiveArray(ints);
+        int []res = new int[ints.length];
+        for (int i = 0; i &lt; res.length; i++) {
+            res[i] = ints[i].intValue();
+        }
+        return res;
+    }
+    
+    public DefaultMutableTreeNode getSelectedNode() {
+        return ((DefaultMutableTreeNode) outline.getValueAt(
+            outline.getSelectedRow(), 0));
+    }
+    
+    /** A handy method to create a model to install into a JTree to compare
+     * behavior of a real JTree's layout cache and ours */
+    public static TreeModel createModel() {
+        DefaultMutableTreeNode root = new DefaultMutableTreeNode(new Node());
+        TreeModel treeMdl = new DefaultTreeModel (root, false);
+        return treeMdl;
+    }
+    
+    public static void main(String[] ignored) {
+        try {
+           //UIManager.setLookAndFeel (new javax.swing.plaf.metal.MetalLookAndFeel());
+        } catch (Exception e) {}
+        
+        new TestOutlineDynamic().show();
+    }
+    
+    
+    private class NodeRowModel implements RowModel {
+        
+        public Class getColumnClass(int column) {
+            switch (column) {
+                case 0 : return Integer.class;
+                case 1 : return String.class;
+                default : assert false;
+            }
+            return null;
+        }
+        
+        public int getColumnCount() {
+            return 2;
+        }
+        
+        public String getColumnName(int column) {
+            return column == 0 ? &quot;Hash code&quot; : &quot;Comment&quot;;
+        }
+        
+        public Object getValueFor(Object node, int column) {
+            Node n = (Node) ((DefaultMutableTreeNode) node).getUserObject();
+            switch (column) {
+                case 0 : return new Integer(node.hashCode());
+                case 1 : return n.getComment();
+                default : assert false;
+            }
+            return null;
+        }
+        
+        public boolean isCellEditable(Object node, int column) {
+            return column == 1;
+        }
+        
+        public void setValueFor(Object node, int column, Object value) {
+            if (column == 1) {
+                ((Node) ((DefaultMutableTreeNode) node).getUserObject())
+                    .setComment(value.toString());
+            }
+        }
+    }
+    
+    private static class Node {
+        int idx;
+        private String comment = &quot;no comment&quot;;
+        public Node() {
+            idx = nodeCount++;
+        }
+        
+        public String getComment() {
+            return comment;
+        }
+        
+        public void setComment(String s) {
+            comment = s;
+        }        
+        
+        public String toString() {
+            return &quot;Node &quot; + idx;
+        }
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/TreePathSupport.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/TreePathSupport.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/src/org/netbeans/swing/outline/TreePathSupport.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,303 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is NetBeans. The Initial Developer of the Original
+ * Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+ * Microsystems, Inc. All Rights Reserved.
+ */
+/*
+ * TreePathSupport.java
+ *
+ * Created on January 27, 2004, 7:06 PM
+ */
+
+package org.netbeans.swing.outline;
+
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import javax.swing.event.TreeExpansionEvent;
+import javax.swing.event.TreeExpansionListener;
+import javax.swing.event.TreeWillExpandListener;
+import javax.swing.tree.AbstractLayoutCache;
+import javax.swing.tree.ExpandVetoException;
+import javax.swing.tree.TreePath;
+
+/** Manages expanded/collapsed paths for the Outline.  Provides services similar
+ * to those JTree implements inside its own class body.  Propagates changes
+ * in expanded state to the layout cache.
+ * &lt;p&gt;
+ * Principally what this class does is manage the state of expanded paths which
+ * are not visible, or whose parents have been closed/opened.  Whereas the
+ * layout cache retains information only about what is visibly expanded, this
+ * class manages information about any path that has been expanded at some
+ * point in the lifetime of an Outline, so that for example, if A contains B
+ * contains C, and A and B and C are expanded, then the user collapses A,
+ * and later re&euml;expands A, B and C will retain their expanded state and
+ * appear as they did the last time A was expanded.
+ * &lt;p&gt;
+ * When nodes are removed, the OutlineModel must call removePath() for any
+ * defunct paths to avoid memory leaks by the TreePathSupport holding 
+ * references to defunct nodes and not allowing them to be garbage collected.
+ * &lt;p&gt;
+ * Its &lt;code&gt;addTreeWillExpandListener&lt;/code&gt; code supports 
+ * &lt;code&gt;ExtTreeWillExpandListener&lt;/code&gt;, so such a listener may be notified
+ * if some other listener vetos a pending expansion event.
+ *
+ * @author  Tim Boudreau
+ */
+public final class TreePathSupport {
+    private OutlineModel mdl;
+    private Map expandedPaths = new HashMap();
+    private List eListeners = new ArrayList();
+    private List weListeners = new ArrayList();
+    private AbstractLayoutCache layout;
+    
+    /** Creates a new instance of TreePathSupport */
+    public TreePathSupport(OutlineModel mdl, AbstractLayoutCache layout) {
+        this.mdl = mdl;
+        this.layout = layout;
+    }
+    
+    /** Clear all expanded path data.  This is called if the tree model fires
+     * a structural change, and any or all of the nodes it contains may no
+     * longer be present. */
+    public void clear() {
+        expandedPaths.clear();
+    }
+    
+    /** Expand a path.  Notifies the layout cache of the change,
+     * stores the expanded path info (so reexpanding a parent node also reexpands
+     * this path if a parent node containing it is later collapsed).  Fires
+     * TreeWillExpand and TreeExpansion events. */
+    public void expandPath (TreePath path) {
+        if (Boolean.TRUE.equals(expandedPaths.get(path))) {
+            //It's already expanded, don't waste cycles firing bogus events
+            return;
+        }
+        TreeExpansionEvent e = new TreeExpansionEvent (this, path);
+        try {
+            fireTreeWillExpand(e, true);
+            expandedPaths.put(path, Boolean.TRUE);
+            layout.setExpandedState(path, true);
+            fireTreeExpansion(e, true);
+        } catch (ExpandVetoException eve) {
+            fireTreeExpansionVetoed (e, eve);
+        }
+    }
+    
+    /** Collapse a path.  Notifies the layout cache of the change,
+     * stores the expanded path info (so reexpanding a parent node also reexpands
+     * this path if a parent node containing it is later collapsed).  Fires
+     * TreeWillExpand and TreeExpansion events. */
+    public void collapsePath (TreePath path) {
+        if (Boolean.FALSE.equals(expandedPaths.get(path))) {
+            //It's already collapsed, don't waste cycles firing bogus events
+            return;
+        }
+        TreeExpansionEvent e = new TreeExpansionEvent (this, path);
+        try {
+            fireTreeWillExpand(e, false);
+            expandedPaths.put(path, Boolean.FALSE);
+            layout.setExpandedState(path, false);
+            fireTreeExpansion(e, false);
+        } catch (ExpandVetoException eve) {
+            fireTreeExpansionVetoed (e, eve);
+        }
+    }
+    
+    /** Remove a path's data from the list of known paths.  Called when
+     * a tree model deletion event occurs */
+    public void removePath (TreePath path) {
+        expandedPaths.remove(path);
+    }
+    
+    private void fireTreeExpansion (TreeExpansionEvent e, boolean expanded) {
+        int size = eListeners.size();
+        
+        TreeExpansionListener[] listeners = new TreeExpansionListener[size];
+        synchronized (this) {
+            listeners = (TreeExpansionListener[]) eListeners.toArray(listeners);
+        }
+        for (int i=0; i &lt; listeners.length; i++) {
+            if (expanded) {
+                listeners[i].treeExpanded(e);
+            } else {
+                listeners[i].treeCollapsed(e);
+            }
+        }
+    }
+    
+    private void fireTreeWillExpand (TreeExpansionEvent e, boolean expanded) throws ExpandVetoException {
+        int size = eListeners.size();
+        
+        TreeWillExpandListener[] listeners = new TreeWillExpandListener[size];
+        synchronized (this) {
+            listeners = (TreeWillExpandListener[]) weListeners.toArray(listeners);
+        }
+        for (int i=0; i &lt; listeners.length; i++) {
+            if (expanded) {
+                listeners[i].treeWillExpand(e);
+            } else {
+                listeners[i].treeWillCollapse(e);
+            }
+        }
+    }
+    
+    private void fireTreeExpansionVetoed (TreeExpansionEvent e, ExpandVetoException ex) {
+        int size = eListeners.size();
+        
+        TreeWillExpandListener[] listeners = new TreeWillExpandListener[size];
+        synchronized (this) {
+            listeners = (TreeWillExpandListener[]) weListeners.toArray(listeners);
+        }
+        for (int i=0; i &lt; listeners.length; i++) {
+            if (listeners[i] instanceof ExtTreeWillExpandListener) {
+                ((ExtTreeWillExpandListener) listeners[i]).treeExpansionVetoed(e,
+                    ex);
+            }
+        }
+    }
+    
+    
+    public boolean hasBeenExpanded(TreePath path) {
+	return (path != null &amp;&amp; expandedPaths.get(path) != null);
+    }
+
+    /**
+     * Returns true if the node identified by the path is currently expanded,
+     * 
+     * @param path  the &lt;code&gt;TreePath&lt;/code&gt; specifying the node to check
+     * @return false if any of the nodes in the node's path are collapsed, 
+     *               true if all nodes in the path are expanded
+     */
+    public boolean isExpanded(TreePath path) {
+	if(path == null)
+	    return false;
+
+	// Is this node expanded?
+	Object          value = expandedPaths.get(path);
+
+	if(value == null || !((Boolean)value).booleanValue())
+	    return false;
+
+	// It is, make sure its parent is also expanded.
+	TreePath parentPath = path.getParentPath();
+
+	if(parentPath != null)
+	    return isExpanded(parentPath);
+        return true;
+    }
+    
+     protected void removeDescendantToggledPaths(Enumeration toRemove) {
+	 if(toRemove != null) {
+	     while(toRemove.hasMoreElements()) {
+                 TreePath[] descendants = getDescendantToggledPaths(
+                    (TreePath) toRemove.nextElement());
+                 for (int i=0; i &lt; descendants.length; i++) {
+                     expandedPaths.remove(descendants[i]);
+                 }
+	     }
+	 }
+     }
+     
+    protected TreePath[] getDescendantToggledPaths(TreePath parent) {
+	if(parent == null)
+	    return null;
+
+	ArrayList descendants = new ArrayList();
+        Iterator nodes = expandedPaths.keySet().iterator();
+        TreePath path;
+        while (nodes.hasNext()) {
+            path = (TreePath) nodes.next();
+            if (parent.isDescendant(path)) {
+                descendants.add(path);
+            }
+        }
+        TreePath[] result = new TreePath[descendants.size()];
+        return (TreePath[]) descendants.toArray(result);
+    }
+    
+    public boolean isVisible(TreePath path) {
+        if(path != null) {
+	    TreePath parentPath = path.getParentPath();
+
+	    if(parentPath != null) {
+		return isExpanded(parentPath);
+            }
+	    // Root.
+	    return true;
+	}
+        return false;
+    }    
+    
+    public TreePath[] getExpandedDescendants(TreePath parent) {
+        TreePath[] result = new TreePath[0];
+	if(isExpanded(parent)) {
+            TreePath path;
+            Object value;
+            List results = null;
+
+            if (!expandedPaths.isEmpty()) {
+
+                Iterator i = expandedPaths.keySet().iterator();
+
+                while(i.hasNext()) {
+                    path = (TreePath) i.next();
+                    value = expandedPaths.get(path);
+
+                    // Add the path if it is expanded, a descendant of parent,
+                    // and it is visible (all parents expanded). This is rather
+                    // expensive!
+                    if(path != parent &amp;&amp; value != null &amp;&amp;
+                       ((Boolean)value).booleanValue() &amp;&amp;
+                        parent.isDescendant(path) &amp;&amp; isVisible(path)) {
+                        if (results == null) {
+                            results = new ArrayList();
+                        }
+                        results.add (path);
+                    }
+                }
+                if (results != null) {
+                    result = (TreePath[]) results.toArray(result);
+                }
+            }
+        }
+        return result;
+    }    
+    
+    /** Add a TreeExpansionListener.  If the TreeWillExpandListener implements
+     * ExtTreeExpansionListener, it will be notified if another 
+     * TreeWillExpandListener vetoes the expansion event */
+    public synchronized void addTreeExpansionListener (TreeExpansionListener l) {
+        eListeners.add(l);
+    }
+    
+    public synchronized void removeTreeExpansionListener (TreeExpansionListener l) {
+        eListeners.remove(l);
+    }
+    
+    public synchronized void addTreeWillExpandListener (TreeExpansionListener l) {
+        weListeners.add(l);
+    }
+    
+    public synchronized void removeTreeWillExpandListener (TreeExpansionListener l) {
+        weListeners.remove(l);
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/test/build-unit.xml
===================================================================
--- trunk/project/JFindMyFiles/tableview/test/build-unit.xml	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/test/build-unit.xml	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,31 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;!--
+
+The contents of this file are subject to the terms of the Common Development
+and Distribution License (the License). You may not use this file except in
+compliance with the License.
+
+You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+
+When distributing Covered Code, include this CDDL Header Notice in each file
+and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+If applicable, add the following below the CDDL Header, with the fields
+enclosed by brackets [] replaced by your own identifying information:
+&quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+
+The Original Software is NetBeans. The Initial Developer of the Original
+Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+Microsystems, Inc. All Rights Reserved.
+--&gt;
+
+&lt;project name=&quot;openidex/enode/test-unit&quot; basedir=&quot;.&quot; default=&quot;all&quot;&gt;
+    &lt;import file=&quot;../../../nbbuild/templates/xtest-unit.xml&quot;/&gt;
+
+    &lt;target name=&quot;runcodetest&quot;&gt;
+	&lt;executeTests pluginName=&quot;jvm&quot;&gt;
+	&lt;classpath refid=&quot;codetest.classpath&quot;/&gt;
+	&lt;/executeTests&gt;
+    &lt;/target&gt;
+
+&lt;/project&gt;

Added: trunk/project/JFindMyFiles/tableview/test/build.xml
===================================================================
--- trunk/project/JFindMyFiles/tableview/test/build.xml	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/test/build.xml	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,30 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;!--
+The contents of this file are subject to the terms of the Common Development
+and Distribution License (the License). You may not use this file except in
+compliance with the License.
+
+You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+
+When distributing Covered Code, include this CDDL Header Notice in each file
+and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+If applicable, add the following below the CDDL Header, with the fields
+enclosed by brackets [] replaced by your own identifying information:
+&quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+
+The Original Software is NetBeans. The Initial Developer of the Original
+Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+Microsystems, Inc. All Rights Reserved.
+--&gt;
+&lt;project name=&quot;contrib/ttv/test&quot; basedir=&quot;.&quot; default=&quot;all&quot; &gt;
+    &lt;!-- Name of tested module --&gt;
+    &lt;property name=&quot;xtest.module&quot; value=&quot;contrib/ttv&quot;/&gt;
+
+    &lt;import file=&quot;../../../nbbuild/templates/xtest.xml&quot;/&gt;
+
+    &lt;!-- default testtypes, attributes used when no value is supplied from command line --&gt;
+    &lt;property name=&quot;xtest.testtype&quot; value=&quot;unit&quot;/&gt;
+    &lt;property name=&quot;xtest.attribs&quot; value=&quot;stable,code,ide&quot;/&gt;
+
+&lt;/project&gt;

Added: trunk/project/JFindMyFiles/tableview/test/cfg-unit.xml
===================================================================
--- trunk/project/JFindMyFiles/tableview/test/cfg-unit.xml	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/test/cfg-unit.xml	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,66 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;!DOCTYPE mconfig PUBLIC &quot;-//NetBeans//DTD XTest cfg 1.0//EN&quot; &quot;<A HREF="http://www.netbeans.org/dtds/xtest-cfg-1_0.dtd">http://www.netbeans.org/dtds/xtest-cfg-1_0.dtd</A>&quot;&gt;
+&lt;!--
+The contents of this file are subject to the terms of the Common Development
+and Distribution License (the License). You may not use this file except in
+compliance with the License.
+
+You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+
+When distributing Covered Code, include this CDDL Header Notice in each file
+and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+If applicable, add the following below the CDDL Header, with the fields
+enclosed by brackets [] replaced by your own identifying information:
+&quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+
+The Original Software is NetBeans. The Initial Developer of the Original
+Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
+Microsystems, Inc. All Rights Reserved.
+--&gt;
+
+&lt;!--
+  These classes are excluded by default (defined by XTest):
+    &quot;**/*$$*.class&quot;
+    &quot;**/data/**&quot;
+    &quot;**/hidden/**&quot;
+    &quot;**/*Hidden.*&quot;
+    &quot;**/*Hid.*&quot;
+--&gt;
+
+&lt;mconfig name=&quot;ttv unit test config&quot;&gt;
+
+    &lt;!-- testbag with all MyModule tests running in code mode (i.e. in standard JVM)
+         use ant runtests -Dxtest.attribs=stable,code to run this testbag  --&gt;
+    &lt;testbag testattribs=&quot;all and code&quot; executor=&quot;code&quot; name=&quot;all tests (no ide)&quot;&gt;
+        &lt;testset dir=&quot;unit/src&quot;&gt;
+            &lt;patternset&gt;
+                &lt;include name=&quot;**&quot;/&gt;
+           &lt;/patternset&gt;
+        &lt;/testset&gt;
+    &lt;/testbag&gt;
+
+    &lt;!-- testbag with tests which does not fail, use ant runtests -Dxtest.attribs=stable,code --&gt;
+    &lt;testbag testattribs=&quot;stable and code&quot; executor=&quot;code&quot; name=&quot;stable tests (no ide)&quot;&gt;
+        &lt;testset dir=&quot;unit/src&quot;&gt;
+            &lt;patternset&gt;
+                &lt;include name=&quot;**&quot;/&gt;
+            &lt;/patternset&gt;
+        &lt;/testset&gt;
+    &lt;/testbag&gt;
+    
+    &lt;!-- empty testbag - for use with xtest.includes and xtest.excludes properties --&gt;
+    &lt;testbag testattribs=&quot;empty&quot; executor=&quot;code&quot; name=&quot;empty&quot;&gt;
+        &lt;testset dir=&quot;unit/src&quot;&gt;
+            &lt;patternset/&gt;
+        &lt;/testset&gt;
+    &lt;/testbag&gt;
+
+    &lt;!-- xxxxx --&gt;
+
+    &lt;compiler name=&quot;default-compiler&quot; antfile=&quot;build-unit.xml&quot; target=&quot;default-compiler&quot; default=&quot;true&quot;/&gt;
+    &lt;executor name=&quot;code&quot; antfile=&quot;build-unit.xml&quot; target=&quot;run-unit-test&quot;/&gt;
+    &lt;executor name=&quot;ide&quot; antfile=&quot;build-unit.xml&quot; target=&quot;runidetest&quot;/&gt;
+  
+    
+&lt;/mconfig&gt;

Added: trunk/project/JFindMyFiles/tableview/test/org/netbeans/swing/etable/ETableColumnModelTest.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/test/org/netbeans/swing/etable/ETableColumnModelTest.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/test/org/netbeans/swing/etable/ETableColumnModelTest.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,134 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2004 Nokia. All Rights Reserved.
+ */
+
+package org.netbeans.swing.etable;
+
+import javax.swing.table.DefaultTableModel;
+import javax.swing.table.TableModel;
+import java.util.Properties;
+import junit.framework.TestCase;
+
+/**
+ * Tests for class ETableColumnModel.
+ * @author David Strupl
+ */
+public class ETableColumnModelTest extends TestCase {
+
+    public ETableColumnModelTest(String testName) {
+        super(testName);
+    }
+
+    /**
+     * Test of readSettings, writeSettings methods, of class org.netbeans.swing.etable.ETableColumnModel.
+     */
+    public void testReadWriteSettings() {
+        System.out.println(&quot;testReadWriteSettings&quot;);
+        ETableColumnModel etcm = new ETableColumnModel();
+        ETableColumn etc1 = new ETableColumn(0);
+        etcm.addColumn(etc1);
+        ETableColumn etc2 = new ETableColumn(1);
+        etcm.addColumn(etc2);
+        ETableColumn etc3 = new ETableColumn(2);
+        etcm.addColumn(etc3);
+        etcm.setColumnHidden(etc3, true);
+        Properties p = new Properties();
+        
+        etcm.writeSettings(p, &quot;test&quot;);
+        ETableColumnModel etcm2 = new ETableColumnModel();
+        etcm2.readSettings(p, &quot;test&quot;);
+        
+        assertEquals(&quot;Should restore 2 columns&quot;, 2, etcm2.getColumnCount());
+        assertEquals(&quot;One hidden column&quot;, 1, etcm2.hiddenColumns.size());
+    }
+
+    /**
+     * Test of getComparator method, of class org.netbeans.swing.etable.ETableColumnModel.
+     */
+    public void testGetComparator() {
+        System.out.println(&quot;testGetComparator&quot;);
+        ETableColumnModel etcm = new ETableColumnModel();
+        assertTrue(etcm.getComparator() instanceof ETable.OriginalRowComparator);
+        TableModel tm = new DefaultTableModel(new Object[][] {{&quot;b&quot;},{&quot;a&quot;}}, new Object[] {&quot;a&quot;, &quot;b&quot;}); 
+        ETable.RowMapping rm1 = new ETable.RowMapping(0, tm);
+        ETable.RowMapping rm2 = new ETable.RowMapping(1, tm);
+        assertTrue(&quot;Without sort use index of rows, &quot;, etcm.getComparator().compare(rm1, rm2) &lt; 0);
+        
+        ETableColumn etc = new ETableColumn(0);
+        etcm.addColumn(etc);
+        etcm.toggleSortedColumn(etc, true);
+        assertTrue(&quot;Sorting according to data model failed, &quot;, etcm.getComparator().compare(rm1, rm2) &gt; 0);
+    }
+
+    /**
+     * Test of toggleSortedColumn method, of class org.netbeans.swing.etable.ETableColumnModel.
+     */
+    public void testToggleSortedColumn() {
+        System.out.println(&quot;testToggleSortedColumn&quot;);
+        ETableColumnModel etcm = new ETableColumnModel();
+        ETableColumn etc = new ETableColumn(0);
+        etcm.addColumn(etc);
+        
+        etcm.toggleSortedColumn(etc, true);
+        assertTrue(etcm.sortedColumns.contains(etc));
+        assertTrue(etc.isAscending());
+        assertTrue(etc.isSorted());
+        
+        etcm.toggleSortedColumn(etc, true);
+        assertTrue(etcm.sortedColumns.contains(etc));
+        assertFalse(etc.isAscending());
+        assertTrue(etc.isSorted());
+        
+        etcm.toggleSortedColumn(etc, true);
+        assertFalse(etcm.sortedColumns.contains(etc));
+        assertFalse(etc.isSorted());
+    }
+
+    /**
+     * Test of setColumnHidden method, of class org.netbeans.swing.etable.ETableColumnModel.
+     */
+    public void testSetColumnHidden() {
+        System.out.println(&quot;testSetColumnHidden&quot;);
+        ETableColumnModel etcm = new ETableColumnModel();
+        ETableColumn etc = new ETableColumn(0);
+        etcm.addColumn(etc);
+        
+        etcm.setColumnHidden(etc, true);
+        assertTrue(etcm.hiddenColumns.contains(etc));
+        assertTrue(etcm.getColumnCount() == 0);
+        assertTrue(etcm.isColumnHidden(etc));
+        
+        etcm.setColumnHidden(etc, false);
+        assertFalse(etcm.hiddenColumns.contains(etc));
+        assertTrue(etcm.getColumnCount() == 1);
+        assertFalse(etcm.isColumnHidden(etc));
+    }
+
+    /**
+     * Test of clearSortedColumns method, of class org.netbeans.swing.etable.ETableColumnModel.
+     */
+    public void testClearSortedColumns() {
+        System.out.println(&quot;testClearSortedColumns&quot;);
+        ETableColumnModel etcm = new ETableColumnModel();
+        ETableColumn etc = new ETableColumn(0);
+        etcm.addColumn(etc);
+        etcm.toggleSortedColumn(etc, true);
+        
+        etcm.clearSortedColumns();
+        assertFalse(etcm.sortedColumns.contains(etc));
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/test/org/netbeans/swing/etable/ETableColumnTest.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/test/org/netbeans/swing/etable/ETableColumnTest.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/test/org/netbeans/swing/etable/ETableColumnTest.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,133 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2004 Nokia. All Rights Reserved.
+ */
+
+package org.netbeans.swing.etable;
+import java.awt.Component;
+import java.util.Comparator;
+import java.util.Properties;
+import javax.swing.JTable;
+import javax.swing.table.TableCellRenderer;
+import junit.framework.TestCase;
+
+/**
+ * Tests for ETableColumn class.
+ * @author David Strupl
+ */
+public class ETableColumnTest extends TestCase {
+
+    public ETableColumnTest(String testName) {
+        super(testName);
+    }
+
+    /**
+     * Test of setSorted method, of class org.netbeans.swing.etable.ETableColumn.
+     */
+    public void testSetSorted() {
+        System.out.println(&quot;testSetSorted&quot;);
+        ETableColumn etc = new ETableColumn(2);
+        Comparator c = new Comparator() {
+            public int compare(Object a1, Object a2) {
+                return 0;
+            }
+        };
+        etc.setSorted(2, c);
+        
+        assertEquals(2, etc.getSortRank());
+        assertEquals(c, etc.getComparator());
+        assertTrue(etc.isSorted());
+        assertTrue(etc.isAscending());
+    }
+
+    /**
+     * Test of setAscending method, of class org.netbeans.swing.etable.ETableColumn.
+     */
+    public void testSetAscending() {
+        System.out.println(&quot;testSetAscending&quot;);
+        ETableColumn etc = new ETableColumn(2);
+        Comparator c = new Comparator() {
+            public int compare(Object a1, Object a2) {
+                return 0;
+            }
+        };
+        etc.setSorted(2, c);
+        etc.setAscending(false);
+        
+        assertTrue(etc.getComparator() instanceof ETableColumn.FlippingComparator);
+        etc.setAscending(true);
+        assertFalse(etc.getComparator() instanceof ETableColumn.FlippingComparator);
+    }
+
+    /**
+     * Test of setHeaderRenderer method, of class org.netbeans.swing.etable.ETableColumn.
+     */
+    public void testSetHeaderRenderer() {
+        System.out.println(&quot;testSetHeaderRenderer&quot;);
+        TableCellRenderer tcr = new TableCellRenderer() {
+            public Component getTableCellRendererComponent(JTable table, Object value,
+					    boolean isSelected, boolean hasFocus, 
+					    int row, int column) {
+                return null;
+            }
+        };
+        ETableColumn etc = new ETableColumn(0);
+        etc.setHeaderRenderer(tcr);
+        assertEquals(&quot;Externally set headerRenderer should be returned, &quot;, tcr, etc.getHeaderRenderer());
+    }
+
+    /**
+     * Test of getHeaderRenderer method, of class org.netbeans.swing.etable.ETableColumn.
+     */
+    public void testGetHeaderRenderer() {
+        System.out.println(&quot;testGetHeaderRenderer&quot;);
+        ETableColumn etc = new ETableColumn(0);
+        TableCellRenderer tcr1 = etc.createDefaultHeaderRenderer();
+        TableCellRenderer tcr2 = etc.getHeaderRenderer();
+        assertEquals(&quot;createDefaultHeaderRenderer and getHeaderRenderer should return the same object, &quot;, tcr1, tcr2);
+    }
+
+    /**
+     * Test of readSettings and writeSettings methods, of class org.netbeans.swing.etable.ETableColumn.
+     */
+    public void testReadWriteSettings() {
+        System.out.println(&quot;testReadWriteSettings&quot;);
+        ETableColumn etc1 = new ETableColumn(1, 90);
+        etc1.setWidth(100);
+        etc1.setSorted(3, etc1.getRowComparator(1));
+        Properties p = new Properties();
+        etc1.writeSettings(p, 1, &quot;test&quot;);
+        
+        ETableColumn etc2 = new ETableColumn();
+        etc2.readSettings(p, 1, &quot;test&quot;);
+        
+        assertEquals(3, etc2.getSortRank());
+        assertTrue(etc2.isSorted());
+        assertTrue(etc2.isAscending());
+        assertEquals(etc1.getWidth(), etc2.getWidth());
+        assertEquals(etc1.getPreferredWidth(), etc2.getPreferredWidth());
+    }
+
+    /**
+     * Test of compareTo method, of class org.netbeans.swing.etable.ETableColumn.
+     */
+    public void testCompareTo() {
+        System.out.println(&quot;testCompareTo&quot;);
+        ETableColumn etc1 = new ETableColumn(1);
+        ETableColumn etc2 = new ETableColumn(2);
+        assertTrue(etc1.compareTo(etc2) &lt; 0);
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/test/org/netbeans/swing/etable/ETableTest.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/test/org/netbeans/swing/etable/ETableTest.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/test/org/netbeans/swing/etable/ETableTest.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,311 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2004 Nokia. All Rights Reserved.
+ */
+
+package org.netbeans.swing.etable;
+
+import java.awt.event.InputEvent;
+import java.awt.event.KeyEvent;
+import java.util.Properties;
+import javax.swing.table.DefaultTableModel;
+import javax.swing.table.TableColumn;
+import javax.swing.table.TableColumnModel;
+import junit.framework.TestCase;
+
+/**
+ * Tests for class ETable.
+ * @author David Strupl
+ */
+public class ETableTest extends TestCase {
+
+    public ETableTest(String testName) {
+        super(testName);
+    }
+
+    /**
+     * Test of isCellEditable method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testIsCellEditable() {
+        System.out.println(&quot;testIsCellEditable&quot;);
+        ETable t = createTestingTable(true);
+        assertTrue(&quot;Should be editable according to the model&quot;, t.isCellEditable(0, 0));
+        t.setFullyNonEditable(true);
+        assertFalse(&quot;Should be non-editable when in fully non-ed mode&quot; , t.isCellEditable(0, 0));
+        t.setFullyEditable(true);
+        assertTrue(&quot;Should be editable after fully editable&quot;, t.isCellEditable(0, 0));
+    }
+
+    /**
+     * Test of convertRowIndexToModel method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testConvertRowIndexToModel() {
+        System.out.println(&quot;testConvertRowIndexToModel&quot;);
+        ETable t = createTestingTable(true);
+        t.setQuickFilter(0, &quot;b&quot;);
+        assertEquals(&quot;Filter should hide rows&quot;, 3, t.convertRowIndexToModel(1));
+        t.unsetQuickFilter();
+        assertEquals(&quot;Unsetting filter should return original value&quot;, 1, t.convertRowIndexToModel(1));
+        ETableColumnModel etcm = (ETableColumnModel)t.getColumnModel();
+        ETableColumn etc = (ETableColumn)etcm.getColumn(3);
+        etcm.toggleSortedColumn(etc, true);
+        t.sortingPermutation = null; // because that is what we do after calling toggleSortedColumn
+        assertEquals(&quot;Sort reorder (3) not ok&quot;, 3, t.convertRowIndexToModel(0));
+        assertEquals(&quot;Sort reorder (4) not ok&quot;, 4, t.convertRowIndexToModel(5));
+    }
+
+    
+    /**
+     * Test of getFullyEditable method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testGetFullyEditable() {
+        System.out.println(&quot;testGetFullyEditable&quot;);
+        ETable t = createTestingTable(true);
+        assertFalse(&quot;False after creation &quot;, t.isFullyEditable());
+        t.setFullyEditable(true);
+        assertTrue(&quot;Should be editable after setting&quot; , t.isFullyEditable());
+        t.setFullyNonEditable(true);
+        assertFalse(&quot;Should be false if fully non-editable&quot;, t.isFullyEditable());
+    }
+
+    /**
+     * Test of getFullyNonEditable method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testGetFullyNonEditable() {
+        System.out.println(&quot;testGetFullyNonEditable&quot;);
+        
+        ETable t = createTestingTable(true);
+        assertFalse(&quot;False after creation &quot;, t.isFullyNonEditable());
+        t.setFullyNonEditable(true);
+        assertTrue(&quot;Should be non-editable after setting&quot; , t.isFullyNonEditable());
+        t.setFullyEditable(true);
+        assertFalse(&quot;Should be false if fully editable&quot;, t.isFullyNonEditable());
+    }
+
+    /**
+     * Tests passing a QuickFilter object as a parameter to setQuickFilter method.
+     */
+    public void testSetQuickFilter() {
+        System.out.println(&quot;testSetQuickFilter&quot;);
+        ETable t = createTestingTable(true);
+        QuickFilter quick = new QuickFilter() {
+            public boolean accept(Object object) {
+                return &quot;x&quot;.equals(object);
+            }
+        };
+        t.setQuickFilter(1, quick);
+        assertEquals(1, t.getRowCount());
+    }
+    
+    /**
+     * Test of createDefaultColumnsFromModel method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testCreateDefaultColumnsFromModel() {
+        System.out.println(&quot;testCreateDefaultColumnsFromModel&quot;);
+        ETable t = createTestingTable(true);
+        assertTrue(&quot;Should create ETableColumnModel&quot;, t.createDefaultColumnModel() instanceof ETableColumnModel);
+    }
+
+    /**
+     * Test of createColumn method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testCreateColumn() {
+        System.out.println(&quot;testCreateColumn&quot;);
+        final boolean [] called = new boolean[1];
+        ETable t = new ETable(1, 1) {
+            public TableColumn createColumn(int index){ 
+                TableColumn tc = super.createColumn(index);
+                called[0] = tc instanceof ETableColumn;
+                return tc;
+            }
+        };
+        assertTrue(&quot;createColumn should have been called and returned correct type&quot;, called[0]);
+    }
+
+    /**
+     * Test of createDefaultColumnModel method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testCreateDefaultColumnModel() {
+        System.out.println(&quot;testCreateDefaultColumnModel&quot;);
+        final boolean [] called = new boolean[1];
+        ETable t = new ETable(1, 1) {
+            protected TableColumnModel createDefaultColumnModel() {  
+                TableColumnModel tcm = super.createDefaultColumnModel();
+                called[0] = tcm instanceof ETableColumnModel;
+                return tcm;
+            }
+        };
+        assertTrue(&quot;createColumn should have been called and created correct type&quot;, called[0]);
+    }
+
+    /**
+     * Test of getValueAt method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testGetValueAt() {
+        System.out.println(&quot;testGetValueAt&quot;);
+        System.out.println(&quot;testSetValueAt&quot;);
+        ETable t = createTestingTable(true);
+        t.setQuickFilter(0, &quot;b&quot;);
+        assertEquals(&quot;Filter should hide rows&quot;, t.getValueAt(1,1), t.getModel().getValueAt(3, 1));
+        t.unsetQuickFilter();
+        ETableColumnModel etcm = (ETableColumnModel)t.getColumnModel();
+        ETableColumn etc = (ETableColumn)etcm.getColumn(3);
+        etcm.toggleSortedColumn(etc, true);
+        t.sortingPermutation = null; // because that is what we do after calling toggleSortedColumn
+        assertEquals(&quot;Sort reorder (3) not ok&quot;, t.getValueAt(0,1), t.getModel().getValueAt(3, 1));
+        assertEquals(&quot;Sort reorder (4) not ok&quot;, t.getValueAt(5,1), t.getModel().getValueAt(4, 1));
+    }
+
+    /**
+     * Test of setValueAt method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testSetValueAt() {
+        System.out.println(&quot;testSetValueAt&quot;);
+        ETable t = createTestingTable(true);
+        t.setQuickFilter(0, &quot;b&quot;);
+        t.setValueAt(&quot;ahoj&quot;, 1, 1);
+        assertEquals(&quot;Filter should hide rows&quot;, &quot;ahoj&quot;, t.getModel().getValueAt(3, 1));
+        t.unsetQuickFilter();
+        ETableColumnModel etcm = (ETableColumnModel)t.getColumnModel();
+        ETableColumn etc = (ETableColumn)etcm.getColumn(3);
+        etcm.toggleSortedColumn(etc, true);
+        t.sortingPermutation = null; // because that is what we do after calling toggleSortedColumn
+        t.setValueAt(&quot;ahoj1&quot;, 0, 1);
+        t.setValueAt(&quot;ahoj2&quot;, 5, 1);
+        assertEquals(&quot;Sort reorder (3) not ok&quot;, &quot;ahoj1&quot;, t.getModel().getValueAt(3, 1));
+        assertEquals(&quot;Sort reorder (4) not ok&quot;, &quot;ahoj2&quot;, t.getModel().getValueAt(4, 1));
+    }
+
+    /**
+     * Test of getRowCount method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testGetRowCount() {
+        System.out.println(&quot;testGetRowCount&quot;);
+        
+        ETable t = createTestingTable(true);
+        t.setQuickFilter(0, &quot;b&quot;);
+        assertEquals(&quot;Filter should hide rows&quot;, 2, t.getRowCount());
+    }
+
+    /**
+     * Test of setModel method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testSetModel() {
+        System.out.println(&quot;testSetModel&quot;);
+        ETable t = createTestingTable(true);
+        t.setQuickFilter(0, &quot;b&quot;);
+        t.setModel(new DefaultTableModel(100, 100));
+        assertEquals(&quot;row count should be according to the new model&quot;, 100, t.getRowCount());
+    }
+
+    /**
+     * Test of initializeLocalVars method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testInitializeLocalVars() {
+        System.out.println(&quot;testInitializeLocalVars&quot;);
+        ETable t = createTestingTable(true);
+        for (int i = 0; i &lt; t.getColumnCount(); i++) {
+            int pw = t.getColumnModel().getColumn(i).getPreferredWidth();
+            if ((pw == 0) || (pw == 75)) { // the default values
+                fail(&quot;PreferredWidth is &quot; + pw);
+            }
+        }
+    }
+
+    /**
+     * Test of processKeyBinding method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testProcessKeyBinding() {
+        System.out.println(&quot;testProcessKeyBinding&quot;);
+        final boolean []called = new boolean[1];
+        ETable t = new ETable() {
+            void updatePreferredWidths() {
+                super.updatePreferredWidths();
+                called[0] = true;
+            }
+        };
+        KeyEvent ke = new KeyEvent(t, 0, System.currentTimeMillis(), InputEvent.CTRL_MASK, 0, '+');
+        t.processKeyBinding(null, ke, 0, true);
+        assertTrue(&quot;update pref size not called&quot;, called[0]);
+    }
+
+    /**
+     * Test of readSettings and writeSettings methods, 
+     * of class org.netbeans.swing.etable.ETable.
+     */
+    public void testWriteReadSettings() {
+        System.out.println(&quot;testWriteReadSettings&quot;);
+        ETable t = createTestingTable(false);
+        ETableColumnModel etcm = (ETableColumnModel) t.getColumnModel();
+        ETableColumn etc = (ETableColumn)etcm.getColumn(3);
+        etcm.setColumnHidden(etcm.getColumn(0), true);
+        etcm.toggleSortedColumn(etc, true);
+
+        assertEquals(&quot;One column should be hidden&quot;, 3, t.getColumnCount());
+        assertEquals(&quot;Sort reorder (3) not ok&quot;, 3, t.convertRowIndexToModel(0));
+        assertEquals(&quot;Sort reorder (4) not ok&quot;, 4, t.convertRowIndexToModel(5));
+        assertEquals(&quot;Sort reorder (3) not ok&quot;, t.getValueAt(0, 0), t.getModel().getValueAt(3, 1));
+        assertEquals(&quot;Sort reorder (4) not ok&quot;, t.getValueAt(5, 0), t.getModel().getValueAt(4, 1));
+        
+        Properties p = new Properties();
+        t.writeSettings(p, &quot;blabla&quot;);
+        
+        ETable t2 = createTestingTable(false);
+        t2.readSettings(p, &quot;blabla&quot;);
+        
+        assertEquals(&quot;One column should be hidden&quot;, 3, t2.getColumnCount());
+        assertEquals(&quot;Sort reorder (3) not ok&quot;, 3, t2.convertRowIndexToModel(0));
+        assertEquals(&quot;Sort reorder (4) not ok&quot;, 4, t2.convertRowIndexToModel(5));
+        assertEquals(&quot;Sort reorder (3) not ok&quot;, t2.getValueAt(0, 0), t2.getModel().getValueAt(3, 1));
+        assertEquals(&quot;Sort reorder (4) not ok&quot;, t2.getValueAt(5, 0), t2.getModel().getValueAt(4, 1));
+    }
+    
+    /**
+     * Create a test ETable instance with some dummy data. BUT please
+     * be aware that the tests result depend on this data so if you do
+     * any change here make sure you fix all the tests.
+     */
+    private ETable createTestingTable(final boolean cellsEditable) {
+        ETable eTable1 = new ETable();
+        eTable1.setModel(new javax.swing.table.DefaultTableModel(
+            new Object [][] {
+                {&quot;a&quot;, &quot;x&quot;, &quot;tttttttt&quot;, new Integer(5)},
+                {&quot;a&quot;, &quot;y&quot;, &quot;ggggggggg&quot;, new Integer(10)},
+                {&quot;b&quot;, &quot;z&quot;, &quot;nnnnnnnn&quot;, new Integer(7)},
+                {&quot;b&quot;, &quot;w&quot;, &quot;mmmmmm&quot;, new Integer(1)},
+                {&quot;c&quot;, &quot;m&quot;, &quot;kkkkkkkkkk&quot;, new Integer(10000)},
+                {&quot;c&quot;, &quot;n&quot;, &quot;kkkkk&quot;, new Integer(4)}
+            },
+            new String [] { &quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;, &quot;DD&quot;}
+        ) {
+            Class[] types = new Class [] {
+                java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Integer.class
+            };
+            boolean[] canEdit = new boolean [] {
+                cellsEditable, cellsEditable, cellsEditable, cellsEditable
+            };
+            
+            public Class getColumnClass(int columnIndex) {
+                return types [columnIndex];
+            }
+            
+            public boolean isCellEditable(int rowIndex, int columnIndex) {
+                return canEdit [columnIndex];
+            }
+        });
+        return eTable1;
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/test/unit/src/org/netbeans/swing/etable/ETableColumnModelTest.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/test/unit/src/org/netbeans/swing/etable/ETableColumnModelTest.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/test/unit/src/org/netbeans/swing/etable/ETableColumnModelTest.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,135 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2004 Nokia. All Rights Reserved.
+ */
+
+package org.netbeans.swing.etable;
+
+import javax.swing.table.DefaultTableModel;
+import javax.swing.table.TableModel;
+import java.util.Properties;
+import junit.framework.TestCase;
+
+/**
+ * Tests for class ETableColumnModel.
+ * @author David Strupl
+ */
+public class ETableColumnModelTest extends TestCase {
+
+    public ETableColumnModelTest(String testName) {
+        super(testName);
+    }
+
+    /**
+     * Test of readSettings, writeSettings methods, of class org.netbeans.swing.etable.ETableColumnModel.
+     */
+    public void testReadWriteSettings() {
+        ETable et = new ETable();
+        System.out.println(&quot;testReadWriteSettings&quot;);
+        ETableColumnModel etcm = new ETableColumnModel();
+        ETableColumn etc1 = new ETableColumn(0, et);
+        etcm.addColumn(etc1);
+        ETableColumn etc2 = new ETableColumn(1, et);
+        etcm.addColumn(etc2);
+        ETableColumn etc3 = new ETableColumn(2, et);
+        etcm.addColumn(etc3);
+        etcm.setColumnHidden(etc3, true);
+        Properties p = new Properties();
+        
+        etcm.writeSettings(p, &quot;test&quot;);
+        ETableColumnModel etcm2 = new ETableColumnModel();
+        etcm2.readSettings(p, &quot;test&quot;, et);
+        
+        assertEquals(&quot;Should restore 2 columns&quot;, 2, etcm2.getColumnCount());
+        assertEquals(&quot;One hidden column&quot;, 1, etcm2.hiddenColumns.size());
+    }
+
+    /**
+     * Test of getComparator method, of class org.netbeans.swing.etable.ETableColumnModel.
+     */
+    public void testGetComparator() {
+        System.out.println(&quot;testGetComparator&quot;);
+        ETableColumnModel etcm = new ETableColumnModel();
+        assertTrue(etcm.getComparator() instanceof ETable.OriginalRowComparator);
+        TableModel tm = new DefaultTableModel(new Object[][] {{&quot;b&quot;},{&quot;a&quot;}}, new Object[] {&quot;a&quot;, &quot;b&quot;}); 
+        ETable.RowMapping rm1 = new ETable.RowMapping(0, tm);
+        ETable.RowMapping rm2 = new ETable.RowMapping(1, tm);
+        assertTrue(&quot;Without sort use index of rows, &quot;, etcm.getComparator().compare(rm1, rm2) &lt; 0);
+        
+        ETableColumn etc = new ETableColumn(0, new ETable());
+        etcm.addColumn(etc);
+        etcm.toggleSortedColumn(etc, true);
+        assertTrue(&quot;Sorting according to data model failed, &quot;, etcm.getComparator().compare(rm1, rm2) &gt; 0);
+    }
+
+    /**
+     * Test of toggleSortedColumn method, of class org.netbeans.swing.etable.ETableColumnModel.
+     */
+    public void testToggleSortedColumn() {
+        System.out.println(&quot;testToggleSortedColumn&quot;);
+        ETableColumnModel etcm = new ETableColumnModel();
+        ETableColumn etc = new ETableColumn(0, null);
+        etcm.addColumn(etc);
+        
+        etcm.toggleSortedColumn(etc, true);
+        assertTrue(etcm.sortedColumns.contains(etc));
+        assertTrue(etc.isAscending());
+        assertTrue(etc.isSorted());
+        
+        etcm.toggleSortedColumn(etc, true);
+        assertTrue(etcm.sortedColumns.contains(etc));
+        assertFalse(etc.isAscending());
+        assertTrue(etc.isSorted());
+        
+        etcm.toggleSortedColumn(etc, true);
+        assertFalse(etcm.sortedColumns.contains(etc));
+        assertFalse(etc.isSorted());
+    }
+
+    /**
+     * Test of setColumnHidden method, of class org.netbeans.swing.etable.ETableColumnModel.
+     */
+    public void testSetColumnHidden() {
+        System.out.println(&quot;testSetColumnHidden&quot;);
+        ETableColumnModel etcm = new ETableColumnModel();
+        ETableColumn etc = new ETableColumn(0, null);
+        etcm.addColumn(etc);
+        
+        etcm.setColumnHidden(etc, true);
+        assertTrue(etcm.hiddenColumns.contains(etc));
+        assertTrue(etcm.getColumnCount() == 0);
+        assertTrue(etcm.isColumnHidden(etc));
+        
+        etcm.setColumnHidden(etc, false);
+        assertFalse(etcm.hiddenColumns.contains(etc));
+        assertTrue(etcm.getColumnCount() == 1);
+        assertFalse(etcm.isColumnHidden(etc));
+    }
+
+    /**
+     * Test of clearSortedColumns method, of class org.netbeans.swing.etable.ETableColumnModel.
+     */
+    public void testClearSortedColumns() {
+        System.out.println(&quot;testClearSortedColumns&quot;);
+        ETableColumnModel etcm = new ETableColumnModel();
+        ETableColumn etc = new ETableColumn(0, null);
+        etcm.addColumn(etc);
+        etcm.toggleSortedColumn(etc, true);
+        
+        etcm.clearSortedColumns();
+        assertFalse(etcm.sortedColumns.contains(etc));
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/test/unit/src/org/netbeans/swing/etable/ETableColumnTest.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/test/unit/src/org/netbeans/swing/etable/ETableColumnTest.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/test/unit/src/org/netbeans/swing/etable/ETableColumnTest.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,127 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2004 Nokia. All Rights Reserved.
+ */
+
+package org.netbeans.swing.etable;
+import java.awt.Component;
+import java.util.Comparator;
+import java.util.Properties;
+import javax.swing.JTable;
+import javax.swing.table.TableCellRenderer;
+import junit.framework.TestCase;
+
+/**
+ * Tests for ETableColumn class.
+ * @author David Strupl
+ */
+public class ETableColumnTest extends TestCase {
+
+    public ETableColumnTest(String testName) {
+        super(testName);
+    }
+
+    /**
+     * Test of setSorted method, of class org.netbeans.swing.etable.ETableColumn.
+     */
+    public void testSetSorted() {
+        System.out.println(&quot;testSetSorted&quot;);
+        ETableColumn etc = new ETableColumn(2, null);
+        etc.setSorted(2, true);
+        
+        assertEquals(2, etc.getSortRank());
+        assertTrue(etc.isSorted());
+        assertTrue(etc.isAscending());
+    }
+
+    /**
+     * Test of setAscending method, of class org.netbeans.swing.etable.ETableColumn.
+     */
+    public void testSetAscending() {
+        System.out.println(&quot;testSetAscending&quot;);
+        ETableColumn etc = new ETableColumn(2, null);
+//        Comparator c = new Comparator() {
+//            public int compare(Object a1, Object a2) {
+//                return 0;
+//            }
+//        };
+        etc.setSorted(2, true);
+        etc.setAscending(false);
+        
+        assertTrue(etc.getComparator() instanceof ETableColumn.FlippingComparator);
+        etc.setAscending(true);
+        assertFalse(etc.getComparator() instanceof ETableColumn.FlippingComparator);
+    }
+
+    /**
+     * Test of setHeaderRenderer method, of class org.netbeans.swing.etable.ETableColumn.
+     */
+    public void testSetHeaderRenderer() {
+        System.out.println(&quot;testSetHeaderRenderer&quot;);
+        TableCellRenderer tcr = new TableCellRenderer() {
+            public Component getTableCellRendererComponent(JTable table, Object value,
+					    boolean isSelected, boolean hasFocus, 
+					    int row, int column) {
+                return null;
+            }
+        };
+        ETableColumn etc = new ETableColumn(0, null);
+        etc.setHeaderRenderer(tcr);
+        assertEquals(&quot;Externally set headerRenderer should be returned, &quot;, tcr, etc.getHeaderRenderer());
+    }
+
+    /**
+     * Test of getHeaderRenderer method, of class org.netbeans.swing.etable.ETableColumn.
+     */
+    public void testGetHeaderRenderer() {
+        System.out.println(&quot;testGetHeaderRenderer&quot;);
+        ETableColumn etc = new ETableColumn(0, null);
+        TableCellRenderer tcr1 = etc.createDefaultHeaderRenderer();
+        TableCellRenderer tcr2 = etc.getHeaderRenderer();
+        assertEquals(&quot;createDefaultHeaderRenderer and getHeaderRenderer should return the same object, &quot;, tcr1, tcr2);
+    }
+
+    /**
+     * Test of readSettings and writeSettings methods, of class org.netbeans.swing.etable.ETableColumn.
+     */
+    public void testReadWriteSettings() {
+        System.out.println(&quot;testReadWriteSettings&quot;);
+        ETableColumn etc1 = new ETableColumn(1, 90, null);
+        etc1.setWidth(100);
+        etc1.setSorted(3, true);
+        Properties p = new Properties();
+        etc1.writeSettings(p, 1, &quot;test&quot;);
+        
+        ETableColumn etc2 = new ETableColumn(null);
+        etc2.readSettings(p, 1, &quot;test&quot;);
+        
+        assertEquals(3, etc2.getSortRank());
+        assertTrue(etc2.isSorted());
+        assertTrue(etc2.isAscending());
+        assertEquals(etc1.getWidth(), etc2.getWidth());
+        assertEquals(etc1.getPreferredWidth(), etc2.getPreferredWidth());
+    }
+
+    /**
+     * Test of compareTo method, of class org.netbeans.swing.etable.ETableColumn.
+     */
+    public void testCompareTo() {
+        System.out.println(&quot;testCompareTo&quot;);
+        ETableColumn etc1 = new ETableColumn(1, null);
+        ETableColumn etc2 = new ETableColumn(2, null);
+        assertTrue(etc1.compareTo(etc2) &lt; 0);
+    }
+}

Added: trunk/project/JFindMyFiles/tableview/test/unit/src/org/netbeans/swing/etable/ETableTest.java
===================================================================
--- trunk/project/JFindMyFiles/tableview/test/unit/src/org/netbeans/swing/etable/ETableTest.java	2008-07-08 16:49:26 UTC (rev 187)
+++ trunk/project/JFindMyFiles/tableview/test/unit/src/org/netbeans/swing/etable/ETableTest.java	2008-07-08 17:02:52 UTC (rev 188)
@@ -0,0 +1,311 @@
+/*
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the License). You may not use this file except in
+ * compliance with the License.
+ *
+ * You can obtain a copy of the License at <A HREF="http://www.netbeans.org/cddl.html">http://www.netbeans.org/cddl.html</A>
+ * or <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ *
+ * When distributing Covered Code, include this CDDL Header Notice in each file
+ * and include the License file at <A HREF="http://www.netbeans.org/cddl.txt.">http://www.netbeans.org/cddl.txt.</A>
+ * If applicable, add the following below the CDDL Header, with the fields
+ * enclosed by brackets [] replaced by your own identifying information:
+ * &quot;Portions Copyrighted [year] [name of copyright owner]&quot;
+ *
+ * The Original Software is the ETable module. The Initial Developer of the Original
+ * Software is Nokia. Portions Copyright 2004 Nokia. All Rights Reserved.
+ */
+
+package org.netbeans.swing.etable;
+
+import java.awt.event.InputEvent;
+import java.awt.event.KeyEvent;
+import java.util.Properties;
+import javax.swing.table.DefaultTableModel;
+import javax.swing.table.TableColumn;
+import javax.swing.table.TableColumnModel;
+import junit.framework.TestCase;
+
+/**
+ * Tests for class ETable.
+ * @author David Strupl
+ */
+public class ETableTest extends TestCase {
+
+    public ETableTest(String testName) {
+        super(testName);
+    }
+
+    /**
+     * Test of isCellEditable method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testIsCellEditable() {
+        System.out.println(&quot;testIsCellEditable&quot;);
+        ETable t = createTestingTable(true);
+        assertTrue(&quot;Should be editable according to the model&quot;, t.isCellEditable(0, 0));
+        t.setFullyNonEditable(true);
+        assertFalse(&quot;Should be non-editable when in fully non-ed mode&quot; , t.isCellEditable(0, 0));
+        t.setFullyEditable(true);
+        assertTrue(&quot;Should be editable after fully editable&quot;, t.isCellEditable(0, 0));
+    }
+
+    /**
+     * Test of convertRowIndexToModel method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testConvertRowIndexToModel() {
+        System.out.println(&quot;testConvertRowIndexToModel&quot;);
+        ETable t = createTestingTable(true);
+        t.setQuickFilter(0, &quot;b&quot;);
+        assertEquals(&quot;Filter should hide rows&quot;, 3, t.convertRowIndexToModel(1));
+        t.unsetQuickFilter();
+        assertEquals(&quot;Unsetting filter should return original value&quot;, 1, t.convertRowIndexToModel(1));
+        ETableColumnModel etcm = (ETableColumnModel)t.getColumnModel();
+        ETableColumn etc = (ETableColumn)etcm.getColumn(3);
+        etcm.toggleSortedColumn(etc, true);
+        t.sortingPermutation = null; // because that is what we do after calling toggleSortedColumn
+        assertEquals(&quot;Sort reorder (3) not ok&quot;, 3, t.convertRowIndexToModel(0));
+        assertEquals(&quot;Sort reorder (4) not ok&quot;, 4, t.convertRowIndexToModel(5));
+    }
+
+    
+    /**
+     * Test of getFullyEditable method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testGetFullyEditable() {
+        System.out.println(&quot;testGetFullyEditable&quot;);
+        ETable t = createTestingTable(true);
+        assertFalse(&quot;False after creation &quot;, t.isFullyEditable());
+        t.setFullyEditable(true);
+        assertTrue(&quot;Should be editable after setting&quot; , t.isFullyEditable());
+        t.setFullyNonEditable(true);
+        assertFalse(&quot;Should be false if fully non-editable&quot;, t.isFullyEditable());
+    }
+
+    /**
+     * Test of getFullyNonEditable method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testGetFullyNonEditable() {
+        System.out.println(&quot;testGetFullyNonEditable&quot;);
+        
+        ETable t = createTestingTable(true);
+        assertFalse(&quot;False after creation &quot;, t.isFullyNonEditable());
+        t.setFullyNonEditable(true);
+        assertTrue(&quot;Should be non-editable after setting&quot; , t.isFullyNonEditable());
+        t.setFullyEditable(true);
+        assertFalse(&quot;Should be false if fully editable&quot;, t.isFullyNonEditable());
+    }
+
+    /**
+     * Tests passing a QuickFilter object as a parameter to setQuickFilter method.
+     */
+    public void testSetQuickFilter() {
+        System.out.println(&quot;testSetQuickFilter&quot;);
+        ETable t = createTestingTable(true);
+        QuickFilter quick = new QuickFilter() {
+            public boolean accept(Object object) {
+                return &quot;x&quot;.equals(object);
+            }
+        };
+        t.setQuickFilter(1, quick);
+        assertEquals(1, t.getRowCount());
+    }
+    
+    /**
+     * Test of createDefaultColumnsFromModel method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testCreateDefaultColumnsFromModel() {
+        System.out.println(&quot;testCreateDefaultColumnsFromModel&quot;);
+        ETable t = createTestingTable(true);
+        assertTrue(&quot;Should create ETableColumnModel&quot;, t.createDefaultColumnModel() instanceof ETableColumnModel);
+    }
+
+    /**
+     * Test of createColumn method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testCreateColumn() {
+        System.out.println(&quot;testCreateColumn&quot;);
+        final boolean [] called = new boolean[1];
+        ETable t = new ETable(1, 1) {
+            public TableColumn createColumn(int index){ 
+                TableColumn tc = super.createColumn(index);
+                called[0] = tc instanceof ETableColumn;
+                return tc;
+            }
+        };
+        assertTrue(&quot;createColumn should have been called and returned correct type&quot;, called[0]);
+    }
+
+    /**
+     * Test of createDefaultColumnModel method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testCreateDefaultColumnModel() {
+        System.out.println(&quot;testCreateDefaultColumnModel&quot;);
+        final boolean [] called = new boolean[1];
+        ETable t = new ETable(1, 1) {
+            protected TableColumnModel createDefaultColumnModel() {  
+                TableColumnModel tcm = super.createDefaultColumnModel();
+                called[0] = tcm instanceof ETableColumnModel;
+                return tcm;
+            }
+        };
+        assertTrue(&quot;createColumn should have been called and created correct type&quot;, called[0]);
+    }
+
+    /**
+     * Test of getValueAt method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testGetValueAt() {
+        System.out.println(&quot;testGetValueAt&quot;);
+        System.out.println(&quot;testSetValueAt&quot;);
+        ETable t = createTestingTable(true);
+        t.setQuickFilter(0, &quot;b&quot;);
+        assertEquals(&quot;Filter should hide rows&quot;, t.getValueAt(1,1), t.getModel().getValueAt(3, 1));
+        t.unsetQuickFilter();
+        ETableColumnModel etcm = (ETableColumnModel)t.getColumnModel();
+        ETableColumn etc = (ETableColumn)etcm.getColumn(3);
+        etcm.toggleSortedColumn(etc, true);
+        t.sortingPermutation = null; // because that is what we do after calling toggleSortedColumn
+        assertEquals(&quot;Sort reorder (3) not ok&quot;, t.getValueAt(0,1), t.getModel().getValueAt(3, 1));
+        assertEquals(&quot;Sort reorder (4) not ok&quot;, t.getValueAt(5,1), t.getModel().getValueAt(4, 1));
+    }
+
+    /**
+     * Test of setValueAt method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testSetValueAt() {
+        System.out.println(&quot;testSetValueAt&quot;);
+        ETable t = createTestingTable(true);
+        t.setQuickFilter(0, &quot;b&quot;);
+        t.setValueAt(&quot;ahoj&quot;, 1, 1);
+        assertEquals(&quot;Filter should hide rows&quot;, &quot;ahoj&quot;, t.getModel().getValueAt(3, 1));
+        t.unsetQuickFilter();
+        ETableColumnModel etcm = (ETableColumnModel)t.getColumnModel();
+        ETableColumn etc = (ETableColumn)etcm.getColumn(3);
+        etcm.toggleSortedColumn(etc, true);
+        t.sortingPermutation = null; // because that is what we do after calling toggleSortedColumn
+        t.setValueAt(&quot;ahoj1&quot;, 0, 1);
+        t.setValueAt(&quot;ahoj2&quot;, 5, 1);
+        assertEquals(&quot;Sort reorder (3) not ok&quot;, &quot;ahoj1&quot;, t.getModel().getValueAt(3, 1));
+        assertEquals(&quot;Sort reorder (4) not ok&quot;, &quot;ahoj2&quot;, t.getModel().getValueAt(4, 1));
+    }
+
+    /**
+     * Test of getRowCount method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testGetRowCount() {
+        System.out.println(&quot;testGetRowCount&quot;);
+        
+        ETable t = createTestingTable(true);
+        t.setQuickFilter(0, &quot;b&quot;);
+        assertEquals(&quot;Filter should hide rows&quot;, 2, t.getRowCount());
+    }
+
+    /**
+     * Test of setModel method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testSetModel() {
+        System.out.println(&quot;testSetModel&quot;);
+        ETable t = createTestingTable(true);
+        t.setQuickFilter(0, &quot;b&quot;);
+        t.setModel(new DefaultTableModel(100, 100));
+        assertEquals(&quot;row count should be according to the new model&quot;, 100, t.getRowCount());
+    }
+
+    /**
+     * Test of initializeLocalVars method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testInitializeLocalVars() {
+        System.out.println(&quot;testInitializeLocalVars&quot;);
+        ETable t = createTestingTable(true);
+        for (int i = 0; i &lt; t.getColumnCount(); i++) {
+            int pw = t.getColumnModel().getColumn(i).getPreferredWidth();
+            if ((pw == 0) || (pw == 75)) { // the default values
+                fail(&quot;PreferredWidth is &quot; + pw);
+            }
+        }
+    }
+
+    /**
+     * Test of processKeyBinding method, of class org.netbeans.swing.etable.ETable.
+     */
+    public void testProcessKeyBinding() {
+        System.out.println(&quot;testProcessKeyBinding&quot;);
+        final boolean []called = new boolean[1];
+        ETable t = new ETable() {
+            void updatePreferredWidths() {
+                super.updatePreferredWidths();
+                called[0] = true;
+            }
+        };
+        KeyEvent ke = new KeyEvent(t, 0, System.currentTimeMillis(), InputEvent.CTRL_MASK, 0, '+');
+        t.processKeyBinding(null, ke, 0, true);
+        assertTrue(&quot;update pref size not called&quot;, called[0]);
+    }
+
+    /**
+     * Test of readSettings and writeSettings methods, 
+     * of class org.netbeans.swing.etable.ETable.
+     */
+    public void testWriteReadSettings() {
+        System.out.println(&quot;testWriteReadSettings&quot;);
+        ETable t = createTestingTable(false);
+        ETableColumnModel etcm = (ETableColumnModel) t.getColumnModel();
+        ETableColumn etc = (ETableColumn)etcm.getColumn(3);
+        etcm.setColumnHidden(etcm.getColumn(0), true);
+        etcm.toggleSortedColumn(etc, true);
+
+        assertEquals(&quot;One column should be hidden&quot;, 3, t.getColumnCount());
+        assertEquals(&quot;Sort reorder (3) not ok&quot;, 3, t.convertRowIndexToModel(0));
+        assertEquals(&quot;Sort reorder (4) not ok&quot;, 4, t.convertRowIndexToModel(5));
+        assertEquals(&quot;Sort reorder (3) not ok&quot;, t.getValueAt(0, 0), t.getModel().getValueAt(3, 1));
+        assertEquals(&quot;Sort reorder (4) not ok&quot;, t.getValueAt(5, 0), t.getModel().getValueAt(4, 1));
+        
+        Properties p = new Properties();
+        t.writeSettings(p, &quot;blabla&quot;);
+        
+        ETable t2 = createTestingTable(false);
+        t2.readSettings(p, &quot;blabla&quot;);
+        
+        assertEquals(&quot;One column should be hidden&quot;, 3, t2.getColumnCount());
+        assertEquals(&quot;Sort reorder (3) not ok&quot;, 3, t2.convertRowIndexToModel(0));
+        assertEquals(&quot;Sort reorder (4) not ok&quot;, 4, t2.convertRowIndexToModel(5));
+        assertEquals(&quot;Sort reorder (3) not ok&quot;, t2.getValueAt(0, 0), t2.getModel().getValueAt(3, 1));
+        assertEquals(&quot;Sort reorder (4) not ok&quot;, t2.getValueAt(5, 0), t2.getModel().getValueAt(4, 1));
+    }
+    
+    /**
+     * Create a test ETable instance with some dummy data. BUT please
+     * be aware that the tests result depend on this data so if you do
+     * any change here make sure you fix all the tests.
+     */
+    private ETable createTestingTable(final boolean cellsEditable) {
+        ETable eTable1 = new ETable();
+        eTable1.setModel(new javax.swing.table.DefaultTableModel(
+            new Object [][] {
+                {&quot;a&quot;, &quot;x&quot;, &quot;tttttttt&quot;, new Integer(5)},
+                {&quot;a&quot;, &quot;y&quot;, &quot;ggggggggg&quot;, new Integer(10)},
+                {&quot;b&quot;, &quot;z&quot;, &quot;nnnnnnnn&quot;, new Integer(7)},
+                {&quot;b&quot;, &quot;w&quot;, &quot;mmmmmm&quot;, new Integer(1)},
+                {&quot;c&quot;, &quot;m&quot;, &quot;kkkkkkkkkk&quot;, new Integer(10000)},
+                {&quot;c&quot;, &quot;n&quot;, &quot;kkkkk&quot;, new Integer(4)}
+            },
+            new String [] { &quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;, &quot;DD&quot;}
+        ) {
+            Class[] types = new Class [] {
+                java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Integer.class
+            };
+            boolean[] canEdit = new boolean [] {
+                cellsEditable, cellsEditable, cellsEditable, cellsEditable
+            };
+            
+            public Class getColumnClass(int columnIndex) {
+                return types [columnIndex];
+            }
+            
+            public boolean isCellEditable(int rowIndex, int columnIndex) {
+                return canEdit [columnIndex];
+            }
+        });
+        return eTable1;
+    }
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000182.html">[Jfindmyfiles-commits] r187 - in trunk/docs: . Documentos	Externos/images
</A></li>
	<LI>Next message: <A HREF="000184.html">[Jfindmyfiles-commits] r189 - in trunk/project/JFindMyFiles:	JFindMyFilesGui/src/de/berlios/jfindmyfiles/jfindmyfilesgui	org-netbeans-swing-outline	org-netbeans-swing-outline/nbproject tableview tableview/nbproject
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#183">[ date ]</a>
              <a href="thread.html#183">[ thread ]</a>
              <a href="subject.html#183">[ subject ]</a>
              <a href="author.html#183">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/jfindmyfiles-commits">More information about the Jfindmyfiles-commits
mailing list</a><br>
</body></html>
